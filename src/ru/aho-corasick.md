# Алгоритм Ахо-Корасик

Пусть дан набор строк в алфавите размера $k$ суммарной длины $n$. Алгоритм Ахо-Корасик за $O(nk)$ времени и памяти строит [бор](https://algorithmica.org/ru/trie) для этого набора строк, а затем по этому бору строит автомат, который может использоваться в различных строковых задачах — например, нахождения всех вхождений каждой строки из данного набора в произвольный текст за линейное время.

Алгоритм был назван именами создателей — Альфреда Ахо и Маргарет Корасик.

<img width='100%' src='https://www.fishingsib.ru/files/image/1articles/2017/10/10/4.jpg'>

Автор специализируется на компьютерной лингвистике и когда-то работал над созданием разговорного интеллекта — этот модуль назывался «Болталка», говорящая на произвольные темы.

> Пусть заданы $n$ *плохих* слов и большой текст $t$. Нужно найти суммарное количество их вхождений в этот текст.

Эту и много других задач помогают решать *суффиксные ссылки*. Суффиксная ссылка для вершины $v$ — это вершина, которой соответствует наидлиннейший суффикс строки, соответствующей вершине $v$, и присутствующий в боре. Будем считать, что мы их умеем быстро находить.

Добавим все плохие слова в бор. Будем считывать строку и с помощью суффиксных ссылок поддерживать самый длинный суффикс текущей строки, который принимает бор. Тогда, для конкретной позиции, мы можем быстро посчитать, какие плохие слова на нём заканчиваются — ровно те, до которых можно дойти по суффиксным ссылкам (по определению, суффиксная ссылка ведёт в наидлиннейший суффикс, присутствующий в боре). Информацию о количестве таких слов можно посчитать заранее динамикой в графе из суффиксных ссылок.

Алгоритм Ахо-Корасик позволяет строить суффиксные ссылки для произвольного бора за $O(nk)$, где $n$ и $k$ это суммарный размер строк и размер алфавита соответственно. Его описание вынесенов в [отдельную статью](https://algorithmica.org/ru/aho-corasick).

## Зачем это нужно

> Пусть заданы $n$ *плохих* слов и большой текст $t$. Нужно найти суммарное количество их вхождений в этот текст.

Добавим все плохие слова в бор, и будем считывать строку и с помощью суффиксных ссылок поддерживать самый длинный суффикс текущей строки, который принимает бор.

Тогда, для конкретной позиции, мы можем быстро посчитать, какие плохие слова на нём заканчиваются — ровно те, по которым можно дойти по суффиксным ссылкам. Информацию о количестве таких слов можно посчитать заранее динамикой в графе из суффиксных ссылок.

Помимо суффиксных ссылок, нужно найти ещё *переходы*, чтобы поддерживать самый длинный суффикс.

## Алгоритм Ахо-Корасик*

Заметим, что всего суффиксных ссылок нужно найти $O(n)$, а переходов — $O(nk)$. Суффиксные ссылки и переходы можно быстро найти динамикой.

**Ссылки**. Мы можем сделать так: пройти на символ назад, а оттуда пройти по суффиксной ссылке, и уже оттуда вызвать переход.

**Переходы**. Вот к нашей строке прибавился символ — нужно найти самую длинную строку. Для этого можно откатываться по суффиксным ссылкам, пока не придем в вершину, из которой данный переход есть. Рано или поздно мы либо попадем в такую вершину, либо попадем в корень. Но можно поступить лениво, и просто откатиться на *одну* суффиксную ссылку и взять уже посчитанный переход оттуда.

<img src='https://www.parazitakusok.ru/images/item/5728/item_1109_1510080296_558.jpg' width='250px'>

```c++
const int k = 26;

struct Vertex {
    Vertex *to[k] = {0}, *go[k] = {0};
    Vertex *link = 0, *p;
    int pch;
    Vertex (int _pch, Vertex *_p) { pch = _pch, p = _p; }
};

Vertex *root = new Vertex(-1, 0);
```

```c++
void add_string (string s) {
    Vertex *v = root;
    for (char _c : s) {
        c -= 'a';
        if (!v->to[c])
            v->to[c] = new Vertex(c, v);
        v = v->to[c];
    }
}
```

Нам нужно объявить две функции, которые будут ссылаться друг на друга. В интерпретируемых языках (например, в питоне) можно просто объявить две функции, а вот C++ так не умеет — нужно сначала все объявить, а потом ссылаться.

```c++
Vertex* go (Vertex *v, int c);

Vertex* link (Vertex *v) {
    if (!v->link) {
        if (v == root || v->p == root) v->link = root;
        else v->link = go(link(v->p), v->pch);
    }
    return v->link;
}

Vertex* go (Vertex *v, int c) {
    if (!v->go[c]) {
        if (v->to[c]) v->go[c] = v->to[c];
        else if (v == root) v->go[c] = root;
        else v->go[c] = go(link(v), c);
    }
    return v->go[c];
}
```



Например, через него реализована утилита `grep`.

Рассмотрим следующую [задачу](http://acm.timus.ru/problem.aspx?space=1&num=1269): дан набор строк $s_1, s_2, \ldots, s_n$, называемый *cловарём* и большой текст $t$. Необходимо найти все позиции, где строки словаря входят в текст. Для простоты дополнительно предположим, что строки из словаря не являются подстроками друг друга (позже мы увидим, что это требование избыточно).

**Алгоритм.** Будем обрабатывать символы текста по одному и поддерживать наибольшую строку, являющуюся префиксом строки из словаря, и при этом также суффиксом считанного на данный момент текста. Если эта строка совпадает с каким-то $s_i$, то будем отмечать текущий символ — в нём заканчивается какая-то строка из словаря.

Для этой задачи нам нужно как-то сжато хранить все префиксы слов из словаря. Это можно делать в единой структуре — в префиксном дереве.

-описание или ссылка на бор-

Нам нужно научиться при добавлении очередного символа быстро находить вершину в префиксном дереве, которая приписыванием этого символа к какому-то суффиксу текущей вершины, а из всех таких вершин — наибольшую.

**Формализм.** Введём функцию $s(v)$, равную строке, соответствующей вершине $v$.

**Определение.** *Суффиксная ссылка* $l(v)$ ведёт в вершину $u \neq v$, которая соответствует наидлиннейшему суффиксу $v$.

**Определение.** *Автоматный переход* $\delta(v, c)$ равен вершине, соответствующей минимальному суффиксу строки $s(v) + c$.

Автоматный переход существует для любой пары $(v, c)$. Если в префиксном дереве уже существовал переход из вершины $v$ по символу $c$, то автоматный переход будет вести туда же.

Заметим следующую связь суффиксных ссылок и автоматных переходов:

* $l(s_{:n}) = \delta(s_{:n-1}, s_n)$.

* Если существует переход $v \to_c u$, то $\delta(v, c) = u$, иначе  $\delta(v, c) = \delta(l(v), c)$.

Отметим, что мы выразили $l$ и $\delta$ от строки через $l$ и $\delta$ от строк меньшего размера. Значит, можно применить динамику: посчитать 

### Построение через BFS

### Построение через ленивую динамику





Будем приписывать символы к тексту по одному и отмечать новый символ, если в нём заканчивается вхождение какой-нибудь из S_i. Для решения данной задачи логично действовать следующим образом: Будем поддерживать наибольшую строку, являющуюся префиксом строки из словаря и при этом также суффиксом считанного на данный момент текста. Тогда мы должны отметить текущее состояние если поддерживаемая строка является одной из S_i.

Все префиксы S_i удобно хранить в единой структуре -- префиксном дереве. На его рёбрах написаны символы, а пути из корня в листья при конкатенации символов на рёбрах дают строки из S_i. простейший алгоритм построения префиксного дерева имеет следующий вид:

```{.c++
const int maxn = 1e5 + 42, sigma = 26; // Наибольшая суммарная длина строк словаря и размер алфавита.
int to[maxn][sigma]; // to[v][c] -- ребро из v с пометкой c.
int sz = 1; // Количество использованных вершин.

void add_str(string s)
{
    int v = 0; // Корень дерева.
    for(char c: s)
    {
        c -= 'a'; // Переводим в [0; 26)
        if(!to[v][c]) // Если ещё нет перехода по данному символу, создаём его в вершину sz.
            to[v][c] = sz++;
        v = to[v][c];
    }
}
```

Теперь нам нужно научиться при добавлении очередного символа находить вершину в префиксном дереве, которая получена приписыванием этого символа к какому-то суффиксу текущей вершины, а из всех таких вершин -- наибольшую. Будем записывать эти вершины в переходы по недостающим символам, рассматривая префиксы в порядке увеличения их длины (то есть, в порядке bfs вершин дерева). Введём понятие суффиксной ссылки link_v -- Она ведёт из вершины v в вершину u с наибольшей длиной, являющуюся её собственным суффиксом.

Алгоритм аналогичен принципу математической индукции -- мы считаем, что когда мы пришли в вершину v, все вершины с меньшей длиной уже обаботаны корректно, то есть, их переходы выставлены в нужные места, а для вершины v известна суффиксная ссылка u. Рассмотрим переходы по всем возможным символам c из v. Если по данному символу уже выставлен переход, то мы можем сказать, что суффиксной ссылкой вершины to_{v,c}, в которую ведёт переход будет вершина to_{u,c}. Если же перехода нет, то выставим вместо него to_{u,c}. Корректность данного построения очевидна -- если бы искомый переход шёл из суффикса большего, чем u, то в него бы и вела суффиксная ссылка, а не в u, а переходы из суффиксов меньших, чем u учтены в ней по предположению индукции.

\newpage В реализации ниже есть один нюанс -- суффиксная ссылка из корня ведёт в него же, что заставляет рассматривать его отдельно, но в целом упрощает реализацию.

```{.c++
int link[maxn];
void push_links()
{
    int que[sz];
    int st = 0, fi = 1;
    que[st] = 0; 
    while(st < fi)
    {
        int v = que[st++];
        int u = link[v];
        for(int c = 0; c < sigma; c++)
        {
            if(to[v][c])
            {
                link[to[v][c]] = v ? to[u][c] : 0;
                que[fi++] = to[v][c];
            }
            else
            {
                to[v][c] = to[u][c];
            }
        }
    }
}
```

Таким образом, чтобы решить задачу, нам следует поддерживать требуемую вершину v и при каждом приписывании нового символа совершать переход по нему. В общем случае если строки словаря могут быть подстроками друг друга, всё, что нам нужно будет сделать -- проверить, что по пути из суффиксных ссылок текущей вершины встречается какая-то из строк словаря.

Данный алгоритм работает за O(|S|\Sigma), где |S| -- размер словаря, а \Sigma -- размер алфавита. Заметим, что существуют также алгоритмы построения подобной структуры за O(|S| \log \Sigma) с помощью персистентного массива или через стандартные амортизационные трюки. Второй вариант очень похож на алгоритм префикс-функции, приведём его здесь без подробных комментариев.

```{.c++
map to[maxn];
...
void push_links()
{
    int que[sz];
    int st = 0, fi = 1;
    que[st] = 0;
    while(st < fi)
    {
        int v = que[st++];
        for(auto it: to[v])
        {
            int c = it.first;
            int u = it.second;
            int j = link[v];
            while(j != 0 && to[j][c] == 0)
                j = link[j];
            if(to[j][c] != u)
                link[u] = to[j][c];
            que[fi++] = u;
        }
    }
}
```
