# Splay-дерево

**Splay-дерево** (дерево Тарьяна-Слейтора) - двоичное дерево поиска, созданное Робертом Тарьяном и Даниелем Слейтером специально для ускорения работы другой структуры данных, которую мы рассмотрим позже. Splay-дерево позволяет быстро получать доступ к недавно использованным данным (вершинам) засчёт их "поднятия" к корню и имеет амортизированное время работы $\hat{O}(n\,log\,n)$.

## Свойства

Основная операция в splay-дереве - это операция $expose(v)$, выполняющая балансировку дерева. Она при помощи серии операций $rotate$ делает вершину $v$ корнем дерева. *Поворот* вокруг ребра $(v, u)$ (где $u$ - предок $v$; будем обозначать эту операцию за $rotate(v)$) "поднимает" $v$ на уровень вверх, при этом "опуская" $u$ и не нарушая свойств двоичного дерева поиска.
![](https://neerc.ifmo.ru/wiki/images/2/24/Зиг.png)
По сути, splay-дерево - это детерминированное [декартово дерево](https://algorithmica.org/ru/treap) с амортизированным временем работы (из-за чего нельзя эффективно сделать splay-дерево персистентным). Базовая функция для работы splay-дерева - $find(x)$ - находит вершину $u$ с максимальным ключом, не большим $x$. Реализуется $find(x)$ так же, как и в других деревьях поиска - обычным спуском,  но после  обязательно нужно выполнить $expose(u)$. Через $find(x)$ реализуются операции $split$ и $merge$: 
+ $split(x, k)$ - так же, как и в декартовом дереве, принимает исходное дерево $x$ и возвращает два дерева $l$ и $r$, причём все ключи в $l$ меньше $k$, а все ключи в $r$ - не меньше $k$. Выполним операцию $find(k)$ в дереве $x$, после которой найденная вершина $u$ окажется корнем $x$; заметим, что тогда ключи всех вершин в поддереве левого сына $u$ (обозначим его за $l$) будут меньше $k$, то есть мы можем "отрезать" левое поддерево от $u$ и вернуть пару ${l, u}$. 
+ $merge(l, r)$ - принимает два дерева $l$ и $r$ (причём все ключи в $l$ меньше всех ключей в $r$) и возвращает новое дерево $x$, состоящее из всех вершин $l$ и $r$. При помощи операции $find$ найдём в $r$ вершину с минимальным ключом, после чего она станет корнем $r$; заметим, что у неё не будет левого сына, тогда мы просто сделаем этим левым сыном всё дерево $l$.
