# Выпуклые оболочки

**Выпуклое множество** — такое множество точек, что, для любых двух точек множества, все точки на отрезке между ними тоже принадлежат этому множеству.

**Выпуклая оболочка** множества точек — такое выпуклое множество точек, что все точки фигуры также лежат в нем.

**Минимальная выпуклая оболочка** множества точек — это минимальная по площади выпуклая оболочка.

Для экономии времени дальше минимальные выпуклые оболочки мы будем называть просто выпуклыми оболочками.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/de/ConvexHull.svg/220px-ConvexHull.svg.png)

Для практических целей выпуклые оболочки полезны тем, что компактно хранят  всю необходимую информацию о множестве точек, что позволяет быстро отвечать на разнообразные запросы на этом множестве.

Научимся их строить по какому-то множеству из $n$ точек на плоскости.

## Алгоритм Джарвиса

Выберем какую-нибудь точку $p_0$, которая гарантированно попадёт в выпуклую оболочку. Например, нижнюю, а если таких несколько, то самую левую из них.

Дальше будем действовать так: найдём самую «правую» точку от последней добавленной (то есть с минимальным полярным углом) и добавим её в оболочку. Будем так итеративно добавлять точки, пока не «замкнёмся», то есть пока самой правой не станет $p_0$. 

![alt text](http://neerc.ifmo.ru/wiki/images/b/b3/Graham1.png)

Корректность алгоритма легко доказывается по индукции:

* На первом шаге мы выбрали точку, точно лежащую в МВО.

* На $i$-м шаге мы взяли такую точку, что все остальные лежат по «правильную» сторону отрезка $(p_i, p_{i+1})$.

Алгоритм Джарвиса также называют алгоритмом заворачивания подарка.

Для каждой точки выпуклой оболочки (обозначим их количество за $h$) мы из всех оставшихся $O(n)$ точек будем искать оптимальную, что суммарно будет работать за $O(n h)$.

В реализации будем пользоваться тем же классом для точки, что и в [статье про вычислительную геометрию](https://algorithmica.org/ru/geometry).

Для краткости, будем считать, что все точки различны, имеют целочисленные координаты, а также что нет трёх точек на одной прямой.

```
vector<r> convex_hull(vector<r> points) {
    r p0 = points[0];
    for (r p : points)
        if (p.x < p0.x || (p.x == p0.x && p.y < p0.y))
        p0 = p;
    vector<r> hull = {p0};
    do {
        for (int p = 0; p < n; p++) {
            
        }
        
    } while()
}
```

Важно помнить, что асимптотика именно $O(nh)$, а не $O(n^2)$: существуют задачи, где оболочка маленькая, и это существенно.

## Алгоритм Грэхема

Алгоритм Грэхема — это оптимизация алгоритма Джарвиса, основанная на следующей идее: давайте не искать следующую точку каждый раз, а сделаем так, чтобы у нас всегда была оптимальная точка и мы могли бы просто ее достать и проверить.

В прошлом алгоритме мы искали точку, оптимальную по полярному углу, тогда давайте сейчас сразу отсортируем точки по полярному углу и сразу возьмем две первые точки в МВО.

Теперь будем делать следующий алгоритм, пока все точки не будут просмотрены : 

1) Возьмем первую из отсортированных точек.

2) Проверем последние три точки из взятых, если они образуют правый поворот, то удалим предпоследнюю точку

Сделать это можно, например, стеком. Код есть ниже.

![alt text](https://cdn.turkaramamotoru.com/ru/algoritm-grehema-4131.jpg)

Асимптотика : Мы просмотрим одну точку и либо удалим ее, либо оставим, то есть сам поиск МВО работает за линейное время, но мы еще делаем сортировку, а $\rightarrow$ алгоритм работает за  $O(n\log(n))$, при этом его корректность вытекает из предыдущего алгоритма.

```
int main() {
    sort(all(p2), comp);
    vector<Point> s;
    s.push_back(p[min_ind]);
    for (int i = 0; i < n - 1; i++) {
        if (p2[i].x == s[s.size() - 1].x && p2[i].y == s[s.size() - 1].y)
            continue;
        while (s.size() > 1 && (vect(s[s.size() - 1], s[s.size() - 2]) ^
               vect(s[s.size() - 1], p2[i])) > 0)
            s.pop_back();
        s.push_back(p2[i]);
    }
}
```

## Верхние и нижние огибающие

Для некоторых

## Алгоритм Эндрю

Алгоритм Эндрю опирается на то, что вещественные числа не точны и предлагает поменять компаратор и строить не одну выпуклую оболочку, а две : 

Давайте выберем самую нижнюю и самую правую точку, затем отсортируем точки по самому простому из возможных компараторов, теперь будем строить две оболочки от самой правой точки и самой левой, в итоге мы получим верхнюю и нижнюю части выпуклой оболочки

```
bool comp(Point a, Point b) {
    if(a.x == b.x) {
        return a.y < b.y;
    }
    return a.x < b.x;
}

int main() {
    sort(all(p), comp);
    vector<Point> up, down;
    up.pb(p[0]);
    down.pb(p[0]);
    Point p1 = p[0], p2 = p.back();
    for(int i = 1; i < n; i++) {
        if (i == n - 1 || cw(p1, p[i], p2)) {
            while (up.size() >= 2 && !cw(up[up.size() - 2], up[up.size() - 1], p[i])) {
                up.pop_back();
            }
            up.pb(p[i]);
        }
        if (i == n - 1 || ccw(p1, p[i], p2)) {
            while (down.size() >= 2 && !ccw(down[down.size() - 2], down[down.size() - 1], p[i])) {
                down.pop_back();
            }
            down.pb(p[i]);
        }
    }
}
```

## Пересечение оболочек

### Пересечение полуплоскостей

Например, так можно строить подобные клёвые картинки:

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Coloured_Voronoi_2D.svg/220px-Coloured_Voronoi_2D.svg.png)

## Алгоритм Чана

Алгоритм Чана — это объединение алгоритмов Джарвиса и Грэхэма (или Эндрю) .

Разделим все точки на группы по $m$ точек в каждой. В каждой группе построим выпуклую оболочку за $O(m \log m)$. Точки никак не упорядочены, и эти оболочки могут пересекаться, это нормально. Суммарно для всех групп понадобится $O(n \log m)$.

Затем, так же начиная с самой левой нижей точки, мы будем строить общую выпуклую оболочку алгоритмом Джарвиса, но теперь «самую правую точку» можно находить каждый раз не за $O(n)$, а за $O(\frac{n}{m} \log m)$, если делать бинарный поиск в каждой из $\frac{n}{m}$ оболочек.

Такое решение будет работать за $O(h \frac{n}{m} \log m + n \log m)$. Если заранее примерно знать $h$, то можно положить $m = h$, и тогда асимптотипа составит $O(n \log h)$.

## Динамические выпуклые оболочки

## Применения не в геометрии
