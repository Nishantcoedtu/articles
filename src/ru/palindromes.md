# Алгоритм Ахо-Корасик

Рассмотрим следующую задачу
([](http://acm.timus.ru/problem.aspx?space=1&num=1269)): Дан набор строк
$S_1, \dots, S_n$, называемый словарём и текст $T$. Необходимо найти все
позиции где строки из словаря входят в текст. Пусть строки из словаря не
являются подстроками друг друга (позже мы увидим, что это требование
избыточно)

Будем приписывать символы к тексту по одному и отмечать новый символ,
если в нём заканчивается вхождение какой-нибудь из $S_i$. Для решения
данной задачи логично действовать следующим образом: Будем поддерживать
наибольшую строку, являющуюся префиксом строки из словаря и при этом
также суффиксом считанного на данный момент текста. Тогда мы должны
отметить текущее состояние если поддерживаемая строка является одной из
$S_i$.

Все префиксы $S_i$ удобно хранить в единой структуре -- префиксном
дереве. На его рёбрах написаны символы, а пути из корня в листья при
конкатенации символов на рёбрах дают строки из $S_i$. простейший
алгоритм построения префиксного дерева имеет следующий вид:

``` {.c++ language="C++"}
const int maxn = 1e5 + 42, sigma = 26; // Наибольшая суммарная длина строк словаря и размер алфавита.
int to[maxn][sigma]; // to[v][c] -- ребро из v с пометкой c.
int sz = 1; // Количество использованных вершин.

void add_str(string s)
{
    int v = 0; // Корень дерева.
    for(char c: s)
    {
        c -= 'a'; // Переводим в [0; 26)
        if(!to[v][c]) // Если ещё нет перехода по данному символу, создаём его в вершину sz.
            to[v][c] = sz++;
        v = to[v][c];
    }
}
```

Теперь нам нужно научиться при добавлении очередного символа находить
вершину в префиксном дереве, которая получена приписыванием этого
символа к какому-то суффиксу текущей вершины, а из всех таких вершин --
наибольшую. Будем записывать эти вершины в переходы по недостающим
символам, рассматривая префиксы в порядке увеличения их длины (то есть,
в порядке $bfs$ вершин дерева). Введём понятие суффиксной ссылки
$link_v$ -- Она ведёт из вершины $v$ в вершину $u$ с наибольшей длиной,
являющуюся её собственным суффиксом.

Алгоритм аналогичен принципу математической индукции -- мы считаем, что
когда мы пришли в вершину $v$, все вершины с меньшей длиной уже
обаботаны корректно, то есть, их переходы выставлены в нужные места, а
для вершины $v$ известна суффиксная ссылка $u$. Рассмотрим переходы по
всем возможным символам $c$ из $v$. Если по данному символу уже
выставлен переход, то мы можем сказать, что суффиксной ссылкой вершины
$to_{v,c}$, в которую ведёт переход будет вершина $to_{u,c}$. Если же
перехода нет, то выставим вместо него $to_{u,c}$. Корректность данного
построения очевидна -- если бы искомый переход шёл из суффикса большего,
чем $u$, то в него бы и вела суффиксная ссылка, а не в $u$, а переходы
из суффиксов меньших, чем $u$ учтены в ней по предположению индукции.

\newpage
В реализации ниже есть один нюанс -- суффиксная ссылка из корня ведёт в
него же, что заставляет рассматривать его отдельно, но в целом упрощает
реализацию.

``` {.c++ language="C++"}
int link[maxn];
void push_links()
{
    int que[sz];
    int st = 0, fi = 1;
    que[st] = 0; 
    while(st < fi)
    {
        int v = que[st++];
        int u = link[v];
        for(int c = 0; c < sigma; c++)
        {
            if(to[v][c])
            {
                link[to[v][c]] = v ? to[u][c] : 0;
                que[fi++] = to[v][c];
            }
            else
            {
                to[v][c] = to[u][c];
            }
        }
    }
}
```

Таким образом, чтобы решить задачу, нам следует поддерживать требуемую
вершину $v$ и при каждом приписывании нового символа совершать переход
по нему. В общем случае если строки словаря могут быть подстроками друг
друга, всё, что нам нужно будет сделать -- проверить, что по пути из
суффиксных ссылок текущей вершины встречается какая-то из строк словаря.

Данный алгоритм работает за $O(|S|\Sigma)$, где $|S|$ -- размер словаря,
а $\Sigma$ -- размер алфавита. Заметим, что существуют также алгоритмы
построения подобной структуры за $O(|S| \log \Sigma)$ с помощью
персистентного массива или через стандартные амортизационные трюки.
Второй вариант очень похож на алгоритм префикс-функции, приведём его
здесь без подробных комментариев.

``` {.c++ language="C++"}
map<int, int> to[maxn];
...
void push_links()
{
    int que[sz];
    int st = 0, fi = 1;
    que[st] = 0;
    while(st < fi)
    {
        int v = que[st++];
        for(auto it: to[v])
        {
            int c = it.first;
            int u = it.second;
            int j = link[v];
            while(j != 0 && to[j][c] == 0)
                j = link[j];
            if(to[j][c] != u)
                link[u] = to[j][c];
            que[fi++] = u;
        }
    }
}
```

\newpage
Алгоритм Манакера
=================

Напомним, что палиндром -- это строка, которая читается одинаково слева
направо и справа налево.

Пусть есть строка $S$ и мы хотим найти в ней все подпалиндромы. Мы сразу
сталкиваемся с очевидной тудностью -- их в строке может быть $O(n^2)$,
что можно видеть на примере строки $S = aa\dots a$. Поэтому будет
использован следующий формат: Для каждой позиции $S_i$ мы найдём
наибольший палиндром, центр которого совпадает с $S_i$. При этом пока
что не будем учитывать палиндромы чётной длины
([](http://informatics.mccme.ru/mod/statements/view3.php?id=241&chapterid=1326#1)).

Рассмотрим наиболее наивный алгоритм: Перебираем $S_i$, а для него
вторым циклом находим наибольшую искомую длину.

``` {.c++ language="C++"}
vector<int> pal_array(string s)
{
    int n = s.size();
    s = "@" + s + "$"; // Окружим спецсимволами, чтобы не рассматривать выход за границы
    vector<int> len(n + 1);
    for(int i = 1; i <= n; i++)
    {
        len[i] = 0;
        while(s[i - len[i]] == s[i + len[i]])
            len[i]++;
    }
    len.erase(begin(len));
    return len;
}
```

$len_i$ здесь обозначает не совсем искомую длину, а расстояние от центра
до границы палиндрома, которое в дальнейшем будем называть радиусом
палиндрома. Тот же пример $S = aa\dots a$ показывает, что данная
реализация работает за $O(n^2)$.

Применим идею, которая, возможно, знакома вам по алгоритму z-функции:
При инициализации $len_i$ будем пользоваться посчитанными $len$. Будем
хранить $(l, r)$ -- интервал, соответствующий самому правому из
найденных подпалиндромов. Тогда мы можем сказать, что та часть
наибольшего палиндрома с центром в $S_i$, которая лежит в $S_{(l, r)}$
имеет радиус $\min(r-i,len_{l+r-i})$. $r-i$ означает длину при которой
произошёл бы выход за $S_{(l, r)}$, а $len_{l+r-i}$ -- значение $len$ в
позиции, зеркальной относительно центра $S_{(l, r)}$.

``` {.c++ language="C++"}
vector<int> pal_array(string s)
{
    int n = s.size();
    s = "@" + s + "$";
    vector<int> len(n + 1);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++)
    {
        len[i] = min(r - i, len[l + (r - i)]);
        while(s[i - len[i]] == s[i + len[i]])
            len[i]++;
        if(i + len[i] > r)
        {
            l = i - len[i];
            r = i + len[i];
        }
    }
    len.erase(begin(len));
    return len;
}
```

Покажем, что алгоритм линейный. Очевидно, что цикл $while$ запускается
только если $len_i = r-i$ (иначе палиндром уже во что-то упёрся).
Значит, каждая его итерация сдвигает $r$ на единицу вправо. Таким
образом, так как $r \leq n$, получаем, что суммарно эти циклы отработают
за $O(n)$.

Чтобы учесть чётные палиндромы, сделаем замену:
$S = s_1 s_2 \dots s_n \to S^* = s_1 \# s_2 \# \dots \# s_n$. Теперь
нечётные палиндромы с центром в $s_i$ соответствуют нечётным палиндромам
исходной строки, а нечётные палиндромы с центром в $\#$ -- чётным.

\newpage
Дерево палиндромов
==================

Данная структура, предложенная Михаилом Рубинчиком, представляет собой
другой формат хранения информации обо всех подпалиндромах строки, более
мощный по своей сути. Сперва докажем, что у любой строки есть не больше,
чем $n$ палиндромов. Пусть мы наращиваем строку по одному символу и в
данный момент имеем наибольший суффикс-палиндром $S_{l,r}$. Пусть у него
есть суффикс-палиндром $S_{l',r}$. Тогда он уже имеет вхождение в
позиции $S_{l,l+r-l'}$. Таким образом, с каждым новым символом у строки
появляется не более одного нового палиндрома и если таковой есть, то это
всегда наибольший суффикс-палиндром.

Всем палиндромам строки удобно сопоставить следующую структуру, которая
и называется деревом палиндромов: возьмём от каждого палиндрома его
правую половинку (например, $caba$ для $abacaba$ или $ba$ для $abba$) и
добавим в префиксное дерево. Чётные и нечётные палиндромы при этом
рассматриваем отдельно. Таким образом будет получено взаимооднозначное
соответствие между вершинами дерева и подпалиндромами.

Пусть мы построили дерево палиндромов для первых $n$ символов строки и
хотим добавить очередной символ. Для этого будем поддерживать наибольший
суффикс-палиндром. Когда к нам придёт очередной символ, нам нужно будет
найти наибольший суффикс указанного палиндрома, который может быть
дополнен новым символом до палиндрома, это и будет новый
суффикс-палиндром. Для этих целей будем поддерживать суффиксную ссылку,
аналогичную таковой в алгоритме Ахо-Корасик, она будет вести из $v$ в
наибольший собственный суффикс-палиндром $v$. При добавлении очередного
символа, будем подниматься по суффиксным ссылкам, пока не найдём место,
где можно совершить переход. Там нам, возможно, придётся создать новую
вершину в дереве и для неё понадобится суффиксная ссылка. Чтобы найти
её, будем продолжать подниматься по суффиксным ссылкам предыдущего
суффикс-палиндрома, пока не найдём второе место, которое можно дополнить
очередным символом.

Покажем линейность. Рассмотрим длину наибольшего суффикс-палиндрома
строки. Каждый новый символ увеличивает её не более, чем на $2$. При
этом каждый подъём по суффиксной ссылке в цикле уменьшает её, поэтому
основной цикл работает линейное время. Аналогичными рассуждениями о
втором суффикс-палиндроме получаем, что пересчёт суффиксных ссылок при
создании новых вершин также работает за линейное время суммарно.

Наконец, приведём реализацию указанного алгоритма:

``` {.c++ language="C++"}
const int maxn = 1e5 + 42;
map<char, int> to[maxn];
int len[maxn], link[maxn], s[maxn];
int sz, n, last;

void init() // Начальные значения, чтобы не возиться с границами
{
    link[0] = 1;
    len[1] = -1;
    s[n++] = -1;
    sz = 2;
}

int get_link(int v) // Суффикс v, который дополняется до палиндрома
{
    while(s[n - len[v] - 2] != s[n - 1])
        v = link[v];
    return v;
}

void add_letter(char c)
{
    s[n++] = c;
    last = get_link(last);
    if(!to[last][c])
    {
        len[sz] = len[last] + 2;
        link[sz] = to[get_link(link[last])][c];
        to[last][c] = sz++;
    }
    last = to[last][c];
}
```

Как и в случае с Ахо-Корасик, существуют неамортизированные
$O(n \Sigma)$ и $O(n \log \Sigma)$ версии.
