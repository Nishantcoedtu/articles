# Палиндромы

**Палиндром** — это строка, которая читается одинаково слева направо и справа налево. Например:

* «abba»

* «abacaba»

* «was it a car or a cat I saw?»

* «а роза упала на лапу Азора»

Палиндромы — не самые часто встречающиеся в реальной жизни объекты, однако задачи на палиндромы любят давать на соревнованиях по спортивному программированию. В этой статье мы опишем эффективные способы их представления.

## Алгоритм Манакера

Пусть есть строка $s$ и мы хотим найти в ней все подпалиндромы.

Мы сразу сталкиваемся с очевидной тудностью: их в строке может быть $O(n^2)$, что можно видеть на примере строки $s = aa \ldots a$. Поэтому будем использовать следующий формат: для каждой позиции $s_i$ найдём наибольший палиндром, центр которого совпадает с $s_i$. Половину его длины назовём *радиусом*. Чётные и нечётные палиндромы будем рассматривать отдельно.

Наивное решение — перебрать $s_i$, а для него вторым циклом находить наибольшую искомую длину: 

```{.c++
vector<int> pal_array(string s) {
    int n = s.size();

    // окружим строку спецсимволами, чтобы не рассматривать выход за границы
    s = "#" + s + "$";

    // в этом массиве будем хранить расстояние от центра до границы палиндрома
    vector<int> t(n, 0);

    for(int i = 1; i <= n; i++)
        while (s[i - t[i - 1]] == s[i + t[i - 1]])
            r[i-1]++;

    return r;
}
```

Тот же пример $s = aa\dots a$ показывает, что данная реализация работает за $O(n^2)$. Для оптимизации применим идею, знакомую из алгоритма [z-функции](https://algorithmica.org/ru/string-searching): при инициализации $t_i$ будем пользоваться уже посчитанными $t$.

Будем поддерживать $(l, r)$ — интервал, соответствующий самому правому из найденных подпалиндромов. Тогда мы можем сказать, что часть наибольшего палиндрома с центром в $s_i$, которая лежит в $s_{l:r}$ имеет радиус хотя бы: $\min(r-i, t{l+r-i})$.

$(r-i)$ означает длину при которой произошёл бы выход за $S_{(l, r)}$, а $len_{l+r-i}$ -- значение $len$ в
позиции, зеркальной относительно центра $S_{(l, r)}$.

```{.c++
vector<int> manacher_odd(string s) {
    int n = s.size();
    s = "@" + s + "$";
    vector<int> len(n + 1);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        len[i] = min(r - i, len[l + (r - i)]);
        while(s[i - len[i]] == s[i + len[i]])
            len[i]++;
        if(i + len[i] > r) {
            l = i - len[i];
            r = i + len[i];
        }
    }
    len.erase(begin(len));
    return len;
}
```

Так же, как и z-функция, алгоритм работает за линейное время.

Цикл $while$ запускается только если $len_i = r-i$ (иначе палиндром уже во что-то упёрся).
Значит, каждая его итерация сдвигает $r$ на единицу вправо. Таким
образом, так как $r \leq n$, получаем, что суммарно эти циклы отработают
за $O(n)$.

Чтобы учесть чётные палиндромы, сделаем замену:
$S = s_1 s_2 \dots s_n \to S^* = s_1 \# s_2 \# \dots \# s_n$. Теперь
нечётные палиндромы с центром в $s_i$ соответствуют нечётным палиндромам
исходной строки, а нечётные палиндромы с центром в $\#$ -- чётным.

## Дерево палиндромов

Дерево палиндромов (англ. *palindromic tree*, *EERTREE*) — структура данных, использующая другой, более мощный формат хранения информации обо всех подпалиндромах, чем размеры $n$ палиндромов. Она была предложена Михаилом Рубинчиком на летних петрозаводских сборах в 2014-м году.

**Лемма.** В строке есть не более $n$ различных подпалиндромов.

**Доказательство.** Пусть мы дописываем к строке по одному символу и в данный момент, записав $r$ символов, имеем наибольший суффикс-палиндром $s_{l:r}$. Пусть у него, в свою очередь, есть суффикс-палиндром $s_{l':r} = t$. Тогда он также имеет более раннее вхождение в строку как $s_{l:l+r-l'} = t$. Таким образом, с каждым новым символом у строки появляется не более одного нового палиндрома, и если таковой есть, то это всегда наибольший суффикс-палиндром.

Этот факт позволяет сопоставить всем палиндромам строки сопоставить следующую структуру: возьмём от каждого плаиндрома его правую половину (например, $caba$ для $abacaba$ или $ba$ для $abba$; будем рассматривать пока что только чётные палиндромы) и добавим все эти половины в префиксное дерево — получившуюся структуру и будем называть *деревом палиндромов*.

### Построение за линейное время

Научимся его строить эффективно. Будем поддерживать наибольший суффикс-палиндром. Когда мы будем дописывать очередной символ $c$, нужно найти наибольший суффикс этого палиндрома, который может быть дополнен символом $c$ — это и будет новый наидлиннейший суффикс-палиндром.

Для этого поступим аналогично [алгоритму Ахо-Корасик](https://algorithmica.org/ru/aho-corasick): будем поддерживать для каждого палиндрома суффиксную ссылку $l(v)$, ведущую из $v$ в её наибольший суффиксный палиндром. При добавлении очередного символа, будем подниматься по суффиксным ссылкам, пока не найдём вершину, из которой можно совершить нужный переход.

Если в подходящей вершине этого перехода не существовало, то нужно создать новую вершину, а для неё тоже понадобится своя суффиксная ссылка. Чтобы найти её, будем продолжать подниматься по суффиксным ссылкам предыдущего суффикс-палиндрома, пока не найдём второе такое место, которое мы можем дополнить символом $c$.

**Асимптотика.** Покажем линейность алгоритма. Рассмотрим длину наибольшего суффикс-палиндрома строки. Каждый новый символ увеличивает её не более, чем на 2. При этом каждый переход по суффиксной ссылке уменьшает её, поэтому нахождение первого суффикс-палиндрома амортизированно работает за линеейное время.

Аналогичными рассуждениями о длине второго суффикс-палиндрома получаем, что пересчёт суффиксных ссыдлк при создании новых вершин тоже суммарно работает за линейное время.

```c++
const int maxn = 1e5, k = 25;

map<char, int> to[maxn];
int len[maxn], link[maxn], s[maxn];
int sz, n, last;
void init() // Начальные значения, чтобы не возиться с границами
{
 link[0] = 1;
 len[1] = -1;
 s[n++] = -1;
 sz = 2;
}
int get_link(int v) // Суффикс v, который дополняется до палиндрома
{
 while(s[n - len[v] - 2] != s[n - 1])
 v = link[v];
 return v;
}
void add_letter(char c)
{
 s[n++] = c;
 last = get_link(last);
 if(!to[last][c])
 {
 len[sz] = len[last] + 2;
 link[sz] = to[get_link(link[last])][c];
 to[last][c] = sz++;
 }
 last = to[last][c];
}
```

Здесь мы использовали массив для хранения переходов.

Как и в случае с Ахо-Корасик, существуют неамортизированные O(n \Sigma) и O(n \log \Sigma) версии.

TODO

Покажем линейность. Рассмотрим длину наибольшего суффикс-палиндрома
строки. Каждый новый символ увеличивает её не более, чем на $2$. При
этом каждый подъём по суффиксной ссылке в цикле уменьшает её, поэтому
основной цикл работает линейное время. Аналогичными рассуждениями о
втором суффикс-палиндроме получаем, что пересчёт суффиксных ссылок при
создании новых вершин также работает за линейное время суммарно.

Наконец, приведём реализацию указанного алгоритма:

```{.c++
const int maxn = 1e5 + 42;
map<char, int> to[maxn];
int len[maxn], link[maxn], s[maxn];
int sz, n, last;

void init() // Начальные значения, чтобы не возиться с границами
{
    link[0] = 1;
    len[1] = -1;
    s[n++] = -1;
    sz = 2;
}

int get_link(int v) // Суффикс v, который дополняется до палиндрома
{
    while(s[n - len[v] - 2] != s[n - 1])
        v = link[v];
    return v;
}

void add_letter(char c)
{
    s[n++] = c;
    last = get_link(last);
    if(!to[last][c])
    {
        len[sz] = len[last] + 2;
        link[sz] = to[get_link(link[last])][c];
        to[last][c] = sz++;
    }
    last = to[last][c];
}
```

Как и в случае с Ахо-Корасик, существуют неамортизированные
$O(n \Sigma)$ и $O(n \log \Sigma)$ версии.
