# Алгоритм Евклида

*Наименьшим общим делителем* (англ. *greatest common divisor*) целых неотрицательных чисел $a$ и $b$ называется наибольшое число $x$, которое делит одновременно и $a$, и $b$.

$$
\gcd(a, b) = \max_{k: \; k|a \, \land \, k | b} k
$$

Когда оба числа равны нулю, результат не определён — подойдёт сколько угодно большое число. Однако в этом случае мы положим в этом случае $\gcd$ равным тоже нулю, чтобы можно было использовать следующее правило: если одно из чисел равно нулю, то их $\gcd$ равен второму числу.

Алгоритм Евклида находит $gcd$ двух чисел $a$ и $b$ за $O(\log \min(a, b))$. Он известен с IV века до нашей эры, а возможно и ранее.

Сам алгоритм основывается на следующей формуле, которую мы докажем позже:

$$
\gcd(a, b) = \begin{cases}
a, & b = 0 \\
\gcd(b,\, a \bmod b), & b > 0
\end{cases}
$$

Эту формулу очень просто реализовать:

```c++
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}
```

Чуть более быстрая итеративная форма:

```c++
int gcd(int a, int b) {
    wihle (b > 0) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

В компиляторе `gcc` для этого уже есть встроенная функция `__gcd`.

## Корректность

Из того, что второй аргумент $\gcd$ всегда уменьшается и не может стать отрицательным, будет следовать, что алгоритм Евклида всегда хотя бы завершается.

Чтобы доказать корректность алгоритма, нам нужно доказать равенство $g = \gcd(a, b) = \gcd(b, a \bmod b)$ для любых $a \geq 0$, $b > 0$. 

Разложим остаток от деления $a$ на $b$ через их частное:

$$
a \bmod b = a - b \cdot \Big \lfloor \frac{a}{b} \Big \rfloor
$$

По определению, $g = \gcd(a, b)$ делит $a$ и $b$. Следовательно, $g$ делит и эту разность, а значит и $(a \bmod b)$.

Так как $g$ делит числа $b$ и $(a \bmod b)$, то оно должно также делить $\gcd(b, a \bmod b)$.

Мы получили, что $g = \gcd(a, b)$ делит $\gcd(b, a \bmod b)$. Можно провести симметричные рассуждения и показать, что $\gcd(b, a \bmod b)$ делит $\gcd(a, b)$, из чего будет следовать, что они равны.

## Асимптотика

Заметим, что в алгоритме поддерживается инвариант $a > b$, кроме, возможно, первой итерации. Так как $a \bmod b < b$ и $a > b$, то $a$ уменьшится хотя бы в два раза.

Самые худшие входные данные для алгоритма — последовательность Фибоначчи.

Также по этой причине нахождение $\gcd$ от $n$ чисел будет работать за $O(n + \log x)$, где $x$ это минимальное из них.

## Решение диофантовых уравнений

Для обычного использования $gcd$ не нужно даже знать, как алгоритм устроен — он есть даже в компиляторе.

*Расширенный алгоритм Евклида* находит помимо $g = \gcd(a, b)$ также коэффициенты $x$ и $y$ такие, что

$$
a \cdot x + b \cdot y = g
$$

Эта версия значима, потому что с помощью неё можно искать обратный элемент по модулю: нужно найти такой элемент $a^{-1}$, что $a \cdot a^{1} \equiv 1$, что то же самое, что:

$$
a^{-1} \cdot a + k \cdot m = 1
$$

Модифицируем стандартный алгоритм Евклида, чтобы учесть в нём нахождение этих коэффициентов.

Пусть мы посчитали эти коэффициенты когда рекурсивно считали $gcd(b, a \bmod b)$. Иными словами, у нас есть решение $(x, y)$ для пары $(b, a \bmod b)$:

$$

$$

Чтобы получить решение для исходной пары, преобразуем величину $(a \bmod b)$ как $todo$ и подставим в преведённое выше выражение:

$$

$$

Если выполнить перегруппировку слагаемых, можно получить:

$$

$$

### Реализация

```c++
int gcd(int a, int b, int & x, int & y) {
	if (a == 0) {
		x = 0;
		y = 1;
		return b;
	}
	int x1, y1;
	int d = gcd(b%a, a, x1, y1);
	x = y1 - (b / a) * x1;
	y = x1;
	return d;
}
```

Эта рекурсивная функция по прежнему возвращает значение $gcd(a, b)$, но помимо этого записывает в $x$ и $y$ искомые коэффициенты.
