# Решето Эратосфена

**Определение.** Целое положительное число называется **простым**, если оно имеет ровно два различных натуральных делителя — единицу и самого себя. Единица простым числом не считается.

**Решето Эратосфена** (англ. *slieve of Eratosphenes*) — алгоритм нахождения всех простых чисел от $1$ до $n$.

Основная идея соответствует названию алгоритма: запишем ряд чисел $1, 2,\ldots, n$, а затем будем вычеркивать

* сначала числа, делящиеся на $2$, кроме самого числа $2$,

* потом числа, делящиеся на $3$, кроме самого числа $3$,

* с числами, делящимися на $4$, ничего делать не будем — мы их уже вычеркивали,

* потом числа, делящиеся на $5$, кроме самого числа $5$

...и так далее.

Самая простая реализация может выглядеть так:

```c++
vector<bool> slieve(int n) {
    vector<bool> is_prime(n+1, true);
    for (int i = 2; i <= n; i++)
        if (is_prime[i])
            for (int j = 2*i; j <= n; j += i)
                prime[j] = false;
    return is_prime;            
}
```

Этот код сначала помечает все числа, кроме нуля и единицы, как простые, а затем начинает процесс отсеивания составных чисел. Для этого мы перебираем в цикле все числа от $2$ до $n$, и, если текущее число простое, то помечаем все числа, кратные ему, как составные.

## Асимптотика

Выясняется, что даже такой способ работает достаточно быстро — асимптотика  алгоритма состовляет $O(n \log \log n)$.

Алгоритм уже работает за $O(n \log \log n)$

Про простые числа полезно знать два факта:

1. Простые числа распределены почти равномерно.

2. Простых чисел от $1$ до $n$ примерно $\frac{n}{\ln n}$ .



## Линейное решето

Этот алгоритм на самом деле интересен не своей асимптотикой (на самом деле, он требует больше времеи из-за константы)
