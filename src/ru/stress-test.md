
# Стресс-тестирование

* Метод поиска багов, заключающийся в генерации случайных тестов и сравнивании результатов двух решений
* Очень полезен на школьных олимпиадах, когда есть много времени, или когда уже написано решение на маленькие подгруппы

Суть такая:

* Есть решение `smart` — быстрое, но в котором есть баг, который хотим найти
* Пишем решение `stupid` — медленное, но точно корректное
* Пишем генератор `gen` — печатает какой-то корректный тест, сгенерированный случайно
* Кормим всё в скрипт `checker`, который n раз генерирует тест, даёт его на ввод `stupid`-у и `smart`-у, сравнивает выводы и останавливается, когда они отличаются

## Как это выглядит в реальной жизни

**Задача**. Есть два числа $a$ и $b$, $1 \le a, b \le 2 * 10^9$. Вычислите $a *b$.

*Примечание*. На пробных турах всех школьных олимпиад автор проверял свои стресс-тесты именно на этой задаче.

Приведем код решения `smart`, которое не учитывает проблему переполнения 32-битного типа данных `int`:

```c++
void stupid() {
    int a, b;
    cin >> a >> b;
    cout << a * b;
}
```

Приведем код решения `stupid`:

```c++
void smart() {
    int a, b;
    cin >> a >> b;
    cout << 1ll * a * b;
}
```

Если программист начнёт тестировать код руками, то проверить так называемый макстест ему придет в голову далеко не сразу. При этом, если сказать, что решение не работает на тесте `1234567890 1987654321`, то программист сразу поймет, в чем ошибка.

## Стресс-тестирование inline

*Примечание*. Автор не рекомендует так делать, но многим такой подход кажется проще для понимания.

Суть в следующем:

* Все решения и генераторы помещаются в отдельные методы.
* Тесты рекомендуется передавать либо строками, либо через файл, но особо уверенные в себе могут использовать глобальные переменные.
* Быть аккуратным с очищением глобальных переменных.
* Запустить и получить тест.
* Profit.

``` c++
int a, b;

int smart()
    return a * b;

long long stupid() // с точки зрения сигнатуры функций 
                   // пример неудачный — баг очевидный
    return 1ll * a * b;

void gen() {
    a = rand(); // автор рекомендует нормальный рандом, но и так сойдет
    b = rand();
}

int main() {
    for (int i = 0; i < 100; i++) {
        gen();
        if (smart() != stupid()) {
            cout << "WA" << endl;
            cout << a << ' ' << b << endl;
            break;
        }
        cout << "OK" << endl;
    }
    return 0;
}

```

## Script-based стресс-тестирование

Суть в следующем:

* Все решения и генераторы помещаются в отдельные файлы.
* Тесты рекомендуется передавать через перенаправление потоков ввода-вывода.
* Быть аккуратным не надо — мы работаем с тем же самым решением, которое отправим в тестирующую систему.
* Запустить и получить тест.
* Если вы не работаете под Linux, то начните уже наконец работать под Linux.
* Если вы не знаете Python, то выучите уже наконец Python.
* Profit.

Файлы `stupid.cpp`, `smart.cpp` и `gen.py` содержат уже понятный нам код.

Вот примерный код скрипта `checker.py`:

```python
import os, sys

f1, f2, gen, iters = sys.argv

for i in range(int(iters)):
    print('Test', i+1)
    os.popen('python3 %s > test.txt' % gen)
    v1 = os.popen('./%s < test.txt' % f1).read()
    v2 = os.popen('./%s < test.txt' % f2).read()
    if v1 != v2:
        print test
        print("Correct:")
        print v1
        print("Wrong:")
        print v2
        break
```

Автор обычно запускает его командой `python3 checker.py stupid smart gen.py 100`, предварительно скомпилировав `stupid` и `smart` в ту же директорию, что и сам `checker.py`. При желании можно компилировать прямо внутри скрипта.

Скрипт написан под Linux. Для Windows нужно убрать «`./`» во всех системных вызовах. 

*Примечание*. Ну такой вот примерно рецепт усредненный, потому что вариаций масса. Берется неправильное решение, оно не работает, рабочий код — это не про код моего бати. Он берет это решение, вываливает его в скрипт и начинает запускать. Добавляет огромное количество тестов, крайних случаев, рандома и МАКСТЕСТОВ! для проверки. Все это прогоняется вместе с медленным решением. Потом скрипт находит баг и системный блок остужается на балконе. Потом батя заносит тест и щедро заполнив код отладочным выводом начинает дебажить. При этом параллельно ест и засыпает крошками клавиатуру. Ест и приговаривает полушепотом ух ###. При этом у него на лбу аж пот выступает. Любезно мне иногда предлагает подебажить, но я отказываюсь. Надо ли говорить о том какой код получается потом? Вонища такая, что тестирующая система падает.