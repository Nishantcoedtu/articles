# Разреженная таблица

Разреженная таблица (англ. *sparse table*) — структура данных, позволяющая отвечать на запросы минимума на отрезке за $O(1)$ с препроцессингом за $O(n \log n)$ времени и памяти.

Разреженная таблица — это следующий двумерный массив размера $n \times\log n$:

$$
t[i][k] = \min \{ a_i, a_{i+1}, \ldots, a_{i+2^k-1} \}
$$

По-русски: считаем минимумы на каждом отрезке длины $2^k$.

Такой массив можно посчитать за его размер, итерируясь либо по $i$, либо по $k$:

$$
t[i][k] = \min(t[i][k-1], t[i+2^{k-1}][k-1])
$$

Имея таком массив, мы можем для любого отрезка быстро посчитать минимум на нём. Заметим, что у любого отрезка имеется два отрезка длины степени двойки, которые пересекаются, и, главное, покрывают его и только его целиком. Значит, мы можем просто взять минимум из значений, которые соответствуют этим отрезкам.

![](https://neerc.ifmo.ru/wiki/images/7/75/SparseTableRMQ.png)

Последняя деталь: для того, чтобы константа на запрос стала настоящей, вместо функции log нужно предпосчитать массив округленных вниз логарифмов.

```c++
int a[maxn], lg[maxn], mn[maxn][logn];

int rmq (int l, int r) { // полуинтервал [l; r)
    int t = lg[r-l];
    return min(mn[l][t], mn[r-(1<<t)][t]);
}

// Это считается уже где-то в первых строчках main:

for (int l = 0; l < logn; l++)
    for (int i = (1<<l); i < maxn; i++)
        lg[i] = l;

for (int i = n-1; i >= 0; i--) {
    mn[i][0] = a[i];
    for (int l = 0; l < logn-1; l++)
        mn[i][l+1] = min(mn[i][l], mn[i+(1<<l)][l]);
}
```

## 2d Static RMQ

Эту структуру тоже можно обобщить на б*о*льшие размерности. Пусть мы хотим посчитать RMQ на подквадратах. Тогда вместо массива `t[i][k]` у нас будет массив `t[i][j][k]`, в котором вместо минимума на отрезах будет храниться минимум на *квадратах* тех же степеней двоек. Получение минимума на произвольном квадрате тогда уже распадется на четыре минимума на квадратах длины $2^k$.

В общем же случае от нас просят минимум тоже на прямоугольниках. Тогда делаем предподсчет, аналогичный предыдущему случаю, только теперь тут будет $O(n \log^d n)$ памяти и времени на предподсчет.

## Примечания

В отличие от дерева отрезков, разреженная таблица является статической структурой данных, то есть её нельзя дёшево обновлять (но можно достраивать на ходу — см. задачу «[Антиматерия](http://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-roi-2017-editorial.pdf)» с РОИ-2017).

Разреженную таблицу часто применяют для решения задачи о [наименьшем общем предке](http://algorithmica.org/ru/lca), так как её можно свести к RMQ.

Разреженную таблицу можно применять не только для минимума или максимума. От операции требуется только ассоциативность ($a ∘ (b ∘ c) = (a ∘ b) ∘ c$), коммутативность ($a ∘ b = b ∘ a$) и идемпотентность ($a ∘ a = a$). Например, её можно применять для нахождения gcd.

Для больших таблиц порядок итерирования и расположение данных в памяти сильно влияет на скорость построения — это связано с работой кэшей.

**Упражнение.** Какой из 4 вариантов итерирования и layout-а самый эффективный? (Подсказка: не тот, который приведен в этой статье.)

## Disjoint Sparse Table

Представим себе, что мы очень-очень хотим написать  `sparse table` для нахождения функции `f` на отрезке, но `f` не удовлетворяет идемпотентности. Тогда мы не можем испольовать наш стандартный трюк — нельзя взять $O(1)$ пересекающихся отрезков. Но можно придумать способ разбивать запрос на $O(1)$ непересекающихся отрезков. Реализация окажется медленнее и сложнее, но будет более гибкой, чем обычный `sparse table`.

Мысленно построим на массиве [дерево отрезков](http://algorithmica.org/ru/segtree). Пусть корень дерева отвечает за отрезок длины $n$, его сыновья за отрезки длины $\frac{n}{2}$, итд. Введем понятие **центрального элемента** — для полуинтервала $[l; r)$ назовем центральным элемент с индексом $\frac{l + r}{2}$.

![](https://i.imgur.com/7sOeJ14.png)

Для каждого отрезка преподсчитаем `f` на всех подотрезках с правыми концами в центральном элементе и с левыми концами в его правом соседе: $T([l; r)) = \{[l; \frac{l + r}{2} + 1), ..., [\frac{l + r}{2} + 1, r) \}$. 

*Утверждение*. Любой полуинтервал запроса $[l, r)$ разбивается на $O(1)$ непересекающихся преподсчитанных интервалов.

*Доказательство*. Возьмем самый высокий центральный элемент, принадлежащий запросу. Если он разбивает запрос на три и более интервалов, то тогда он не самый высокий. Противоречие.

Тогда отвечать на запрос достаточно просто — надо найти нужный центральный элемент, и сделать два запроса для него. Осталось найти центральный элемент за $O(1)$. Тут мы подходим к тонкостям реализации:

* Будем писать код так, как будто говорим про [дерево отрезков](http://algorithmica.org/ru/segtree), причем дополним его размер до степени двойки
* Будем хранить всю структуру данных так же, как и обычный sparse table, в массиве $t[logn][maxn]$, где первым параметром мы будем хранить глубину центрального элемента, а вторым — правую границу соответствующего полуинтервала
* Если предыдущий пункт непонятен, то представьте себе разрезанное по слоям дерево отрезков.
* Для ответа на запрос нам нужно найти глубину оптимального центрального элемента. Посмотрим на двоичную запись $l$ и $r$. $h_{[l, r)} = maxlog - 1 - maxbit(l \oplus r)$, если $n = 2^{maxlog}$, а $maxbit(x) = \lfloor{\log_2{x}}\rfloor$. Доказательство методом пристального изучения картинки.

```c++
int a[maxn], lg[maxn], t[maxn][logn];

int neutral = 1; // зависит от f
int f(int a, int b) { // любая f, в нашем случае
    return (a * b) % 228; // произведение по составному модулю
}

void build(int l, int r, int level=0) {
    int mid = (l + r) / 2;
    int cur = neutral;
    for (int i = mid + 1; i < r; i++) {
        cur = f(cur, a[i]);
        t[level][i] = cur;
    }
    cur = neutral;
    for (int i = mid; i >= l; i--) {
        cur = f(cur, a[i]);
        t[level][i] = cur;
    }
    if (r - l == 1)
        return;
    build(l, mid, level+1);
    build(mid, r, level+1);
}

int rmq (int l, int r) { // полуинтервал [l; r)
    int level = logn-1-lg[l^r];
    int res = t[level][l];
    if (r & ((1 << lg[l ^ r]) - 1))) // проверяем, что правый отрезок не пустой
        res = f(res, t[level][r]);
    return res;
}

for (int l = 0; l < logn; l++)
    for (int i = (1<<l); i < maxn; i++)
        lg[i] = l;

```