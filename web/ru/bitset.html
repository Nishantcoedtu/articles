<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="битовое-сжатие">Битовое сжатие</h1>
<ul>
<li>Из-за него в «асимптотиках» появляется <code>/64</code></li>
<li>На Всеросе часто дают задачи, где оно может принести «бесплатные» ~20 баллов</li>
<li><code>bitset</code> есть в stl; говорят, самописный быстрее</li>
</ul>
<p>Процессор так устроен, что работает сразу с блоками по 32 или 64 бита (зависит от архитектуры, но получить что-то меньше одного байта он в принципе не может). Иными словами, сделать <code>&amp;</code> двух <code>bool</code>-ом и двух <code>long</code>-ов примерно одинаково по скорости.</p>
<p>Часто нам требуется сделать много одинаковых операций над элементами булевого массива. Проксорить два массива, например. Здесь появляется такая идея: сгруппировать элементы массива в блоки по 64 и каждый блок считать двоичным числом. Тогда мы можем ксорить сразу все 64 бита за одну операцию.</p>
<p>Это всё можно кодить и вручную, но в STL это уже сделали до нас, создав структуру, ведущую себя как большое двоичное число со всеми стандартными битовыми операциями — <code>bitset</code>.</p>
<p>Работать с ним нужно вот так:</p>
<p><code>c++ const int lim = 1000; bitset&lt;lim&gt; b; // создать битсет размера lim (должно быть константой) b.set();       // заполнить единицами b.reset();     // заполнить нулями b.flip();      // заменить единички на нули и наоборот b.count();     // посчитать число единичек cout &lt;&lt; b;     // вывести битовую строку</code></p>
<p>Также для битсетов работает вся битовая арифметика — <code>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</code> и их варианты с <code>[operator]=</code>.</p>
<h2 id="рюкзак">Рюкзак</h2>
<p>Задача: даны <span class="math">\(n\)</span> предметов с положительными целыми весами <span class="math">\(a_i\)</span> и рюкзак размера <span class="math">\(lim\)</span>, выбрать подмножество предметов с максимальной суммой, не превышающий размер рюкзака.</p>
<p>Обычно его решают так:</p>
<p><code>c++ bool dp[lim] = {}; // так можно его заполнить нулями dp[0] = 1; for (int i = 0; i &lt; n; i++)     for (int x = lim - a[i]; x &gt;= 0; x--)         dp[x + a[i]] |= dp[x];</code></p>
<p>…а с битсетом оно разгоняется так:</p>
<p><code>c++ bitset&lt;lim&gt; b; b[0] = 1; for (int i = 0; i &lt; n; i++)     b |= b &lt;&lt; a[i];</code></p>
<h2 id="цикл-длины-3">Цикл длины 3</h2>
<p>Пусть нам нужно узнать, есть ли цикл длины 3 в ориентированном графе из <span class="math">\(n\)</span> вершин, заданном своей матрицей смежности. Обернем матрицу в битсет, и тогда задача решается за <span class="math">\(O(\frac{n^3}{64})\)</span> следующим образом:</p>
<p><code>c++ bitset&lt;maxn&gt; g[maxn]; // матрица смежности for (int a = 0; a &lt; n; a++) {     for (int b = 0; b &lt; n; b++) {         if (g[a][b] &amp;&amp; (~g[a] &amp; g[b]).any()) {             // цикл найден         }     } }</code></p>
<p>Benchmark: на серверах CodeForces этот код при <span class="math">\(n = 5000\)</span> работает за 7 секунд.</p>
<h2 id="перемножение-матриц">Перемножение матриц</h2>
<p>Матрица смежности графа, возведенная в степень <span class="math">\(n\)</span>, имеет комбинаторный смысл: количество способов дойти из <span class="math">\(a\)</span> в <span class="math">\(b\)</span>, используя ровно <span class="math">\(n\)</span> переходов. Иногда нам не нужно знать число способов, и нам просто хватит знания, можно ли вообще через <span class="math">\(n\)</span> ходов там оказаться. Тогда вместо числового умножения нам хватит битового умножения:</p>
<p>```c++ typedef bitset<maxn> t; typedef array<t, maxn> matrix;</p>
<p>matrix operator* (matrix a, matrix b) { matrix c; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) if(a[i][j]) c[i] |= b[j]; return c; } ```</p>
<h2 id="гаусс">Гаусс</h2>
<p>Иногда встречаются задачи, требующие решения системы линейных уравнений. Очень большая часть из них на самом деле над полем <span class="math">\(\mathbb{Z}_2\)</span> — то есть все числа по модулю 2. К примеру: есть <span class="math">\(n\)</span> переключателей лампочек, каждый активированный переключатель меняет состояние (включает или выключает) какого-то подмножества из <span class="math">\(n\)</span> лампочек. Известно состояние всех лампочек, нужно восстановить состояние переключаетелей.</p>
<p>Нас по сути просят решить следующую систему:</p>
<p><span class="math">\[
\begin{cases}
a_{11} x_1 + a_{12} x_2 + \ldots + a_{1n} x_n \equiv b_1 \pmod 2\\
a_{21} x_1 + a_{22} x_2 + \ldots + a_{2n} x_n \equiv b_2 \pmod 2\\
\ldots \\
a_{n1} x_1 + a_{n2} x_2 + \ldots + a_{nn} x_n \equiv b_n \pmod 2
\end{cases}
\]</span></p>
<p>Здесь <span class="math">\(x\)</span> — состояния переключателей, <span class="math">\(b\)</span> — состояния лампочек, <span class="math">\(A\)</span> — информация о том, влияет ли переключатель на лампочку.</p>
<p>В таком случае можно значительно ускорить и упростить обычный метод Гаусса:</p>
<p><code>c++ t gauss (matrix a) {     for (int i = 0; i &lt; n; i++) {         int nonzero = i;         for (int j = i+1; j &lt; n; j++)             if (a[j][i])                 nonzero = j;         swap(a[nonzero], a[i]);         for (int j = 0; j &lt; n; j++)             if (j != i &amp;&amp; a[j][i])                 a[j] ^= a[i];     }     t x;     for (int i = 0; i &lt; n; i++)         x[i] = a[i][n] ^ a[i][i];     return x; }</code></p>
<p>Код находит вектор <span class="math">\(x\)</span> из уравнения <span class="math">\(Ax = b\)</span> при условии, что решение существует и единственно. Для простоты кода, предполагается, что вектор <span class="math">\(b\)</span> приписан справа к матрице <span class="math">\(A\)</span>.</p>
</body>
</html>
