<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="бор">Бор</h1>
<p>Бор — это структура данных для компактного хранения строк.</p>
<p>Он устроен в виде дерева, где на ребрах между вершинами написана символы, а некоторые вершины помечены терминальными. Бор хранит ровно те строки, которые получаются, если выписать подряд все буквы на путях от корня до терминальных вершин.</p>
<div class="figure">
<img src="https://koenig-media.raywenderlich.com/uploads/2016/10/SwiftAlgClub_TrieData-trie-1.png" alt="trie" /><p class="caption">trie</p>
</div>
<p>Бор можно удобно использовать для разных задач: * Хранение строк — занимает гораздо меньше места, чем массив или сет строк. * Сортировка строк — по бору можно пройтись dfs-ом и вывести все строки в лексикографическом порядке.</p>
<ul>
<li>Сет строк — как мы увидим, в нем легко добавлять и удалять слова, а также проверять, если ли слово в бореи.</li>
</ul>
<h2 id="реализация">Реализация</h2>
<p>Бор состоит из ссылающихся друг на друга вершин. В вершине обычно хранится такая информация: * терминальная ли вершина, * ссылки на детей, * возможно, какая-нибудь дополнительная зависящая от задачи информация о слове, если вершина терминальная. Например, количество таких слов — так можно реализовать мультисет.</p>
<p>```c++ const int k = 26;</p>
<p>struct Vertex { Vertex* to[k] = {0}; bool terminal = 0; };</p>
<p>Vertex *root = new Vertex(); ```</p>
<p>Чтобы добавить слово в бор, нужно пройти от корня по символам слова. Если перехода по для очередного символа нет — создать его, иначе пройти по уже существующему. Последнюю вершину нужно пометить терминальной.</p>
<p><code>c++ void add_string (string &amp;s) {     v = root;     for (char c : s) {         c -= 'a';         if (!v-&gt;to[c])              v-&gt;to[c] = new Vertex();         v = v-&gt;to[c];     }     v-&gt;terminal = true; }</code></p>
<p>Чтобы проверить, есть ли слово в боре, нужно пройти от корня по символам слова. Если в конце оказались в терминальной вершине — то есть. Если оказались в нетерминальной или когда-нибудь потребовалось пройтись по несуществущей ссылке — то есть.</p>
<p>Удалить слово можно лениво, просто дойдя до него и убрав флаг терминальности.</p>
<h3 id="как-хранить-ссылки">Как хранить ссылки</h3>
<p>Хранить ссылки на детей не обязательно в массиве. Возможно, наш алфавит большой — у нас тогда просто не хватит памяти инициализировать столько массивов, большинство из которых будут пустыми.</p>
<p>В этом случае можно придумать какой-нибудь другой способ хранить отображение из символа в ссылку на вершину, например бинарном дереве (<code>map</code>) или хэш-таблице (<code>unordered_map</code>). Они будут работать дольше (но лишь в константу раз), но зато потребление памяти в них будет линейным. У <code>map</code>-а есть ещё одно преимущество, что он хранит ссылки уже отсортированными по символам — так можно отсортировать строки, например.</p>
<p>Учитывайте, что писать бор можно по-разному, особенно когда решаете задачи с жестокими ограничениями.</p>
<h2 id="суффиксные-ссылки">Суффиксные ссылки</h2>
<blockquote>
<p>Пусть заданы <span class="math">\(n\)</span> <em>плохих</em> слов и большой текст <span class="math">\(t\)</span>. Нужно найти суммарное количество их вхождений в этот текст.</p>
</blockquote>
<p>Эту и много других задач помогают решать <em>суффиксные ссылки</em>. Суффиксная ссылка для вершины <span class="math">\(v\)</span> — это вершина, которой соответствует наидлиннейший суффикс строки, соответствующей вершине <span class="math">\(v\)</span>, и присутствующий в боре. Будем считать, что мы их умеем быстро находить.</p>
<p>Добавим все плохие слова в бор. Будем считывать строку и с помощью суффиксных ссылок поддерживать самый длинный суффикс текущей строки, который принимает бор. Тогда, для конкретной позиции, мы можем быстро посчитать, какие плохие слова на нём заканчиваются — ровно те, до которых можно дойти по суффиксным ссылкам (по определению, суффиксная ссылка ведёт в наидлиннейший суффикс, присутствующий в боре). Информацию о количестве таких слов можно посчитать заранее динамикой в графе из суффиксных ссылок.</p>
<p>Алгоритм Ахо-Корасик позволяет строить суффиксные ссылки для произвольного бора за <span class="math">\(O(nk)\)</span>, где <span class="math">\(n\)</span> и <span class="math">\(k\)</span> это суммарный размер строк и размер алфавита соответственно. Его описание вынесенов в <a href="http://sereja.me/a/aho-corasick">отдельную статью</a>.</p>
</body>
</html>
