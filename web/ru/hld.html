<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="heavy-light-декомпозиция">Heavy-light декомпозиция</h1>
<p>HL-декомпозиция — это мощный метод решения задач на запросы на путях, когда также есть запросы обновлений. Если запросов обновления нет, то лучше написать <a href="http://sereja.me/a/centroid">что-нибудь попроще</a>.</p>
<p><img width='400px' src='http://i38.tinypic.com/6yjmvb.jpg'></p>
*
<center>
TODO: найти менее уродливую иллюстрацию
</center>
<ul>
<li></li>
</ul>
<p>Heavy-light декомпозицией корневого дерева называется результат следующего процесса: каждой вершины <span class="math">\(v\)</span> посмотрим на всех её непосредственных детей <span class="math">\(u\)</span>, выберем среди них ребёнка <span class="math">\(u_{max}\)</span> (с самым большим размером поддерева) и назовём ребро <span class="math">\((v, u)\)</span> <em>тяжелым</em> (heavy), а все остальные рёбра — <em>лёгкими</em> (light). При этом, если самых «тяжелых» детей будет больше одного, то выберем любого.</p>
<p>Таким образом, дерево распалось на тяжелые и лёгкие рёбра. Докажем несколько полезных свойств такого разбиения.</p>
<p><strong>Утверждение.</strong> Дерево разбивается на непересекающиеся пути из тяжелых рёбер.</p>
<p><strong>Доказательство.</strong> В каждую вершину входит не более одного тяжелого ребра, и из каждой вершины исходит не более одного тяжелого ребра.</p>
<p>Назовём <em>блоком</em> либо лёгкое ребро, либо вертикальный путь из тяжелых рёбер.</p>
<p><strong>Утверждение.</strong> На любом вертикальном пути будет не более <span class="math">\(O(\log n)\)</span> блоков.</p>
<p><strong>Доказательство</strong> разбивается на две части:</p>
<ul>
<li>Лёгких ребер на вертикальном пути будет не более <span class="math">\(O(\log n)\)</span>: рассмотрим самую нижнюю вершину и будем идти по вертикальному пути снизу вверх. Каждый раз, когда мы переходим по лёгкому ребру, размер поддерева текущей вершины увеличивается в два раза, потому что если вершина связана с родителем лёгким ребром, то у него есть какой-то другой ребёнок, который не легче текущего.</li>
<li>Непрерывных путей из тяжелых рёбер будет не более <span class="math">\(O(\log n\)</span>: если это не конец или начало пути, то каждый такой путь окружают два лёгких ребра, а их всего <span class="math">\(O(\log n)\)</span>.</li>
</ul>
<p><strong>Следствие.</strong> На любом пути будет не более <span class="math">\(O(\log n)\)</span> блоков.</p>
<p>Ради этого мы всё и делали: теперь построим какую-нибудь структуру на каждом тяжелого пути (например, дерево отрезков), а при ответе на запрос (скажем, суммы на пути) разобъём его на <span class="math">\(O(\log n)\)</span> запросов либо к подотрезкам тяжелых путей, либо к лёгким рёбрам.</p>
<h2 id="реализация">Реализация</h2>
<p>Большинство публичных реализаций HLD — это 120-150 строк кода. Мы же воспользуемся следующим трюком, который сильно упростит нам жизнь: перенумеруем вершины дерева так, что для каждого тяжелого пути все его вершины будут иметь последовательные номера.</p>
<p>А именно, на этапе подсчёта размера поддеревьев, изменим список смежности каждой вершины так, чтобы в самом начале шел её «тяжелый» ребёнок. Тогда, если запустить обычный эйлеров обход графа, то <code>tin</code>-ы и будут нужной нумерацией, потому что в каждой вершине мы шли в своего тяжелого ребёнка в первую очередь.</p>
<p>Теперь мы можем построить какую-нибудь структуру поверх массива размера <span class="math">\(n\)</span> (дерево отрезков) и при запросе к какому-нибудь тяжелому пути делать запрос к отрезку в структуре.</p>
<p>```c++ vector<int> g[maxn]; int s[maxn], p[maxn], tin[maxn], tout[maxn]; int head[maxn]; // «голова» тяжелого пути, которому принадлежит v int t = 0;</p>
<p>void sizes (int v = 0) { s[v] = 1; for (int &amp;u : g[v]) { sizes(u); s[v] += s[u]; if (s[u] &gt; s[g[v][0]]) // &amp;u -- это ссылка, так что её легально использовать при swap-е swap(u, g[v][0]); } }</p>
<p>void hld (int v = 0) { rin[t] = v; tin[v] = t++; for (int u : g[v]) { // если это тяжелый ребенок -- его next нужно передать // в противном случае он сам является головой нового пути head[u] = (u == g[v][0] ? head[v] : u); hld(u); } tout[v] = t; } ```</p>
<h2 id="как-им-решать-задачи">Как им решать задачи</h2>
<p>Простейший пример задачи на HLD: дано дерево, каждой вершине которого приписано какое-то число, и поступают запросы двух типов:</p>
<ol style="list-style-type: decimal">
<li>Узнать минимальное число на пути между <span class="math">\(v_i\)</span> и <span class="math">\(u_i\)</span>.</li>
<li>Изменить число у <span class="math">\(v_i\)</span>-той вершины на <span class="math">\(x_i\)</span>.</li>
</ol>
<p>Подвесим дерево за произвольную вершину и построим на нём HL-декомпозицию с деревом отрезков в качестве внутренней структуры. Его код мы приводить не будем и посчитаем, что оно реализовано примерно так же, как в <a href="http://sereja.me/a/segtree">соответствующей статье</a> и имеет методы <code>upd(k, x)</code> и <code>get_min(l, r)</code>.</p>
<p><code>c++ int val[maxn]; segtree st(0, n);</code></p>
<p>При операции обновления нам нужно просто обновить нужную ячейку в дереве отрезков:</p>
<p><code>c++ void upd (int v, int x) {     st.upd(tin[v], x); }</code></p>
<p>Запрос минимума сложнее: нам нужно разбить исходный запрос на запросы к вертикальным путям.</p>
<p>```c++ int ancestor (int a, int b) { return tin[a] &lt;= tin[b] &amp;&amp; tin[b] &lt;= tout[a]; }</p>
<p>void up (int &amp;a, int &amp;b, int &amp;ans) { while (!ancestor(head[a], b)) { ans = min(ans, st.get_min(tin[head[a]], tin[a])); a = p[head[a]]; } }</p>
<p>int get_min (int a, int b) { int ans = inf; up(a, b, ans); up(b, a, ans); if (!ancestor(a, b)) swap(a, b); ans = min(ans, st.get_min(tin[a], tin[b])); return ans; } ```</p>
<p><img src='https://codeforces.com/predownloaded/be/01/be019bbaa15bbf621a0cf018b15e778c02aeb104.jpg'></p>
</body>
</html>
