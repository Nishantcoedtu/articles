<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="геометрия-и-ооп">Геометрия и ООП</h1>
<p>Напомним, что отрезок, для которого указано, какой из его концов считается началом, а какой — концом, называется <strong>вектором</strong>. Вектор на плоскости можно задать двумя числами — его координатами по горизонтали и вертикали.</p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/7aa/2e5/f55/7aa2e5f550583a65de28560234e055e8.jpg" alt="vector" /><p class="caption">vector</p>
</div>
<p>Помимо очевидных сложения, вычетания и умножения на константу (скаляр — одно число), у векторов можно ввести и свои особенные операции, которые нам упростят жизнь.</p>
<p><strong>Скалярное произведение</strong> (англ. dot product) — произведение длин векторов на косинус угла между ними. Для него справедлива формула, которая муторно и чисто технически доказывается:</p>
<p><span class="math">\[ a \cdot b = x_a x_b + y_a y_b \]</span></p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/747/242/79b/74724279b3aa34f4f7c5f0b024fa23da.jpg" alt="dot" /><p class="caption">dot</p>
</div>
<p>У него есть полезные свойства:</p>
<ul>
<li>Скалярное произведение симметрично (<span class="math">\(a \cdot b = b \cdot a\)</span>).</li>
<li>Геометрически, это проекция вектора b на вектор a, помноженынй на длину а.</li>
<li>Перпендикулярные вектора должны иметь нулевое скалярное произведение.</li>
<li>Если угол острый, то оно положительное</li>
<li>Если угол тупой, то отрицательное</li>
</ul>
<p><strong>Векторное произведение</strong> (англ. cross product) — произведение длин векторов на синус угла между ними, причём знак этого синуса зависит от порядка операндов. Оно тоже удобно выражается в координатах:</p>
<p><span class="math">\[ a \times b = x_a y_b - y_a x_b \]</span></p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/a28/585/04b/a2858504bc917e2b084bf6f3e5827ca3.jpg" alt="cross" /><p class="caption">cross</p>
</div>
<p>Его свойства:</p>
<ul>
<li>Скалярное произведение <em>анти</em>симметрично (<span class="math">\(a \times b = - (b \times a)\)</span>).</li>
<li>Геометрически, это ориентированный объем параллелограмма, натянутого на эти вектора.</li>
<li>Коллинеарные вектора должны иметь нулевое векторное произведение.</li>
<li>Если b «слева» от a, то оно положительное.</li>
<li>Если b «справа» — то отрицательное.</li>
</ul>
<h2 id="всякие-проверки">Всякие проверки</h2>
<p>Из-за этих классных свойств, почти все проверки можно описать через них, а не уравнениями.</p>
<p><strong>Принадлежность точки треугольнику</strong>. Пусть у нас есть треугольник ABC (заданный против часовой стрелки) и точка P. Тогда она должна лежать слева от всех трёх векторов AB, BC и CA. Это условие задаст пересечение трёх полуплоскостей, которое и будет нужным треугольником.</p>
<p><span class="math">\[
\text{P лежит внутри ABC} \iff \begin{cases}
(B-A) \times (P-A) \geq 0 \\
(C-B) \times (P-B) \geq 0 \\
(A-C) \times (P-C) \geq 0 \\
\end{cases}
\]</span></p>
<p><strong>Площадь треугольника</strong>. Можно пользоваться готовыми формулами, а можно и свойством векторного произведения.</p>
<p><span class="math">\[ V = \frac{1}{2} (B-A) \times (C-A) \]</span></p>
<p><strong>Площадь произвольного многоугольника</strong>. Если многоугольник задан последовательностью вершин в каком-то порядке, то можно считать так: для каждого ребра добавим его ориентированную площадь от начала координат. Какие-то слагаемые будут положительными (которые на последнем слое, а какие-то — отрицательными).</p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/1b3/b00/8c0/1b3b008c0c074b0e38111a95ad421605.jpg" alt="any" /><p class="caption">any</p>
</div>
<p>Забудьте о формуле Герона и всегда считайте площади через векторное произведение.</p>
<p>Кстати, из формулы тря треугольника следует, что площадь любой фигуры будет либо целым числом, либо рациональным с двойкой в знаменателе. Чтобы оставаться в целых числах, иногда имеет смысл умножить все входные данные на 2.</p>
<p><strong>Проверка на выпуклость</strong>. Можно пройтись по сторонам многоугольника и проверять векторным произведением, что мы поворачиваем всегда в одну сторону (то есть если у нас последовательные точки a, b и c, то <span class="math">\((b-a)\times(c-a) &gt; 0\)</span>).</p>
<p><strong>Пересекаются ли отрезки</strong>.</p>
<div class="figure">
<img src="https://habrastorage.org/storage2/a03/5b4/ffa/a035b4ffa74057e35428196b55a4154b.png" alt="segments" /><p class="caption">segments</p>
</div>
<h2 id="уравнение-прямой">Уравнение прямой</h2>
<p>Прямая задается уравнением вида <span class="math">\(Ax + By + C = 0\)</span>. Полуплоскость можно задать таким же неравенством.</p>
<p>У прямой есть <em>вектор нормали</em> с координатами <span class="math">\((A, B)\)</span>. Он перпендиуклярен прямой, а в случае с полуплоскостью <span class="math">\(Ax + By + C \geq 0\)</span> будет указывать в сторону самой полуплоскости.</p>
<p>Чтобы найти расстояние от точки <span class="math">\((x_0, y_0)\)</span> до прямой <span class="math">\(Ax + By + C = 0\)</span>, можно воспользоваться следующей формулой:</p>
<p><span class="math">\[ d = \frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}} \]</span></p>
<p><strong>Точка пересечения</strong>. По сути, найти точку пересечения двух прямых — это то же самое, что и найти точку, которая удовлетворяет обоим условиям их уравнений:</p>
<p><span class="math">\[
\begin{cases}
A_1 x + B_1 y + C_1 = 0 \\
A_2 x + B_2 y + C_2 = 0
\end{cases}
\implies 
\begin{cases}
-x = \frac{B_1 y + C_1}{A_1} \\
-x = \frac{B_2 y + C_2}{A_2}
\end{cases}
\implies 
\frac{B_1 y + C_1}{A_1} = \frac{B_2 y + C_2}{A_2}
\implies 
y = - \frac{A_1 C_2 - A_2 C_1}{A_1 B_2 - A_2 B_1}
\]</span></p>
<p>Аналогично, <span class="math">\(x = \frac{B_1 C_2 - B_2 C_1}{A_1 B_2 - A_2 B_1}\)</span> (обратите внимание на знаки).</p>
<p>Заметьте, что знаменатель может оказаться нулем. Это означает, что векторное произведение векторов нормали нулевое, а значит прямые параллельны (в частности, это могут быть совпадающие прямые). Этот случай нужно отдельно обрабатывать.</p>
<h1 id="как-это-кодить-в-c">Как это кодить в C++</h1>
<p>Сначала мы создадим класс, который будет отвечать за все операции с точками. В C++ есть два способа это сделать: через <code>struct</code> и через <code>class</code>. Их основное отличие в том, что по умолчанию в <code>class</code> все поля <em>приватные</em> — к ним нет прямого доступа снаружи. Это нужно для дополнительной защиты, чтобы в крупных промышленных проектах никто случайно ничего не поломал, но на олимпиадах это не очень актуально.</p>
<p><strong>Точка <span class="math">\(\simeq\)</span> вектор</strong>. Мы будем считать точка и вектор это один и тот же объект, так как они оба — это просто пара чисел. Будем сопоставлять точке её <em>радиус-вектор</em> — вектор из начала координат, ведущий в эту точку. По <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D0%B8%D1%83%D1%81-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80">принятой</a> в математике и физике нотации, будем обозночать вектора как <code>r</code>. Вы можете обозвать их как <code>point</code>, <code>pt</code>, <code>vec</code> — как угодно.</p>
<p><code>c++ struct r {     double x, y;     r () {}     r (int _x, int _y) { x = _x, y = _y; } };</code></p>
<p>Функция <code>r</code> внутри класса вызывается при инциализации объекта. Она называется конструктор, и её можно указывать разную для разных параметров. Таким образом, <code>r()</code> вернёт точку с неопределенными (какие оказались в памяти в тот момент) координатами, а r(x, y) вернет точку с координатами <span class="math">\((x, y)\)</span>.</p>
<h2 id="операции-над-векторами">Операции над векторами</h2>
<p>Давайте напишем функцию, которая принимает вектора и что-то с ними делает. Например, считает длину:</p>
<p><code>c++ double len (r a) { return sqrt(a.x*a.x + a.y*a.y); }</code></p>
<h2 id="операторы">Операторы</h2>
<p>В C++ можно <em>перегружать</em> почти все стандартные операторы, например, <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> и т. д.</p>
<p>Давайте для будущих нужд определим <code>+</code> и <code>-</code>:</p>
<p><code>c++ r operator+(r a, r b){ return r(a.x+b.x, a.y+b.y); } r operator-(r a, r b){ return r(a.x-b.x, a.y-b.y); }</code></p>
<h2 id="скалярное-произведение">Скалярное произведение</h2>
<p><code>c++ int operator*(r a, r b){ return a.x*b.x + a.y*b.y; }</code></p>
<h2 id="векторное-произведение">Векторное произведение</h2>
<p>Формально оно определяется не так. Оно определяется как вектор той же длины, но перпендикулярный обоим исходным векторам. Это имеет применение в 3d геометрии (ещё не разу не встречавшейся на школьных олимпиадах) и физике.</p>
<p><code>c++ int operator^(r a, r b){ return a.x*b.y - b.x*a.y; }</code></p>
<h3 id="ввод-вывод">Ввод-вывод</h3>
<p>Как вы думаете, как на самом деле работает <code>cin &gt;&gt; x;</code>? Это тоже перегрузка оператора <code>&gt;&gt;</code>. Делать это нужно так:</p>
<p>```c++ istream&amp; operator&gt;&gt;(istream &amp;in, r &amp;p){ in &gt;&gt; p.x &gt;&gt; p.y; return in; }</p>
<p>ostream&amp; operator&lt;&lt;(ostream &amp;out, r &amp;p){ out &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; return out;<br />} ```</p>
<h2 id="алгебра-vs-алгоритмы-или-зачем-мы-всё-это-делали">Алгебра VS Алгоритмы или зачем мы всё это делали</h2>
<p>Мы могли не создавать никаких структур и работать с уравнениями, описывающими математические объекты. Такой подход будет популярен на олимпиадах по математике, а не по программированию. Когда математик говорит «пересечем две прямые», он представляет громоздкое уравнение, с которым он потом будет работать. Программист же хочет абстрагироваться и просто написать <code>intersect(a, b)</code>, в корректности которого он точно уверен.</p>
<h3 id="векторное-представление-прямой-ax-by-c-0-rightarrow-r-at-b">Векторное представление прямой (<span class="math">\(Ax + By + C = 0 \rightarrow r = at + b\)</span>)</h3>
<p>Тут нужно просто выбрать две любые точки на прямой.</p>
<p><code>c++ // даны A, B, C (A^2 + B^2 != 0) r a, b; if (eq(A, 0)) // значит, это горизонтальная прямая     a = r(0, -C/B), b = r(1, -C/B); else     a = r(-C/A, 0), b = (1, -(C+B)/A, 1)</code></p>
<h3 id="пример-отражение-от-прямой">Пример: отражение от прямой</h3>
<p>Пусть нам надо отразить точку <span class="math">\((x_0, y_0)\)</span> симметрично относительно заданной прямой <span class="math">\(ax+by+c=0\)</span>. Чисто в педагогических целях, решим эту задачу как математики, чтобы никогда потом так не делать.</p>
<p><span class="math">\(\Pr_a b = \frac{a \cdot b}{|a|} \frac{a}{|a|} = \frac{|a| |b| \cos \alpha}{|a|} \frac{a}{|a|} = |b| \cos \alpha \frac{a}{|a|} \)</span></p>
<p>Формула имеет смысл: длина на единичный вектор направления.</p>
<p>Мы <strong>не</strong> хотим раскрывать эти формулы покоординатно и предъявлять готовый ответ. Мы знаем, что он получится громоздким. Нам не жално посчитать всё по частям — здесь нет смысла заниматься оптимизациями. Также мы хотим делать всё по частям, потому что так более наглядна логика алгоритма, и как следствие его проще дебажить.</p>
<p>```c++ // прямая r = at + b, точка c r pr (r a, r b, r c) { c -= b; // пусть c и a выходят из одной точки return b + (a<em>b / len(a) / len(a)) </em> a; }</p>
<p>r reflect (r a, r b, r c) { return c + 2*(pr(a, b, c)-c); } ```</p>
<h2 id="типичные-баги">Типичные баги</h2>
<h3 id="точность">Точность</h3>
<blockquote>
<p>Первое правило действительных чисел — не использовать действительные числа</p>
</blockquote>
<p>Все переменные типа <code>double</code> хранятся в компьютере неточно (ну а как вы представите ⅓ в двоичной системе счисления?). Поэтому при работе с даблами нужно <strong>всегда</strong> учитывать эту погрешность. Например, чтобы сравнить два дабла, надо проверить, что они отличаются по модулю меньше, чем на очень маленькое число <code>eps</code>:</p>
<p>```c++ const double eps = 1e-8;</p>
<p>bool eq (double a, double b) { return abs(a-b) &lt; eps } ```</p>
<p>Чтобы так не делать, старайтесь по возможности использовать только инты и абсолютную точность. Иногда есть трюки, позволяющие так делать: например, если в задаче все входные точки целочисленные и нас просят посчитать какую-то площадь, то можно все координаты домножить на два, и тогда ответ тоже будет целым (см. векторное произведение), который только при выводе нужно будет поделить на четыре.</p>
<h3 id="neq--0"><span class="math">\(0 \neq -0\)</span></h3>
<p>Действительные числа так хрянятся, что 0 и -0 могут быть разными числами. Имейте это ввиду.</p>
<h3 id="область-определения-обратных-функций">Область определения обратных функций</h3>
<p><code>acos</code>, <code>asin</code> и прочие обратные тригонометрические функций требуют, чтобы им на вход подавалось число от -1 до 1. Для безопасности, масштабируйте числа, перед тем как брать от них эти функции.</p>
</body>
</html>
