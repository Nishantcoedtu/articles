<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="декартово-дерево">Декартово дерево</h1>
<p>Рене Декарт (фр. <em>René Descartes</em>) — великий французский математик и философ XVII века.</p>
<p>Рене Декарт не является создателем декартова дерева, но он является создателем декартовой системы координат, которую мы все знаем и любим.</p>
<p>Декартово дерево же определяется и строится так:</p>
<ul>
<li>Нанесём на плоскость набор из <span class="math">\(n\)</span> точек. Их <span class="math">\(x\)</span> зачем-то назовем <em>ключем</em>, а <span class="math">\(y\)</span> <em>приоритетом</em>.</li>
<li>Выберем самую верхнюю точку (с наибольшим <span class="math">\(y\)</span>, а если таких несколько — любую) и назовём её <em>корнем</em>.</li>
<li>От всех вершин, лежащих слева (с меньшим <span class="math">\(x\)</span>) от корня, рекурсивно запустим этот же процесс. Если слева была хоть одна вершина, то присоединим корень левой части в качестве левого сына текущего корня.</li>
<li>Аналогично, запустимся от правой части и добавим корню правого сына.</li>
</ul>
<p>Заметим, что если все <span class="math">\(y\)</span> и <span class="math">\(x\)</span> различны, то дерево строится однозначно.</p>
<p>Если нарисовать получившуюся структуру на плоскости, то получится действительно дерево — по традиции, корнем вверх:</p>
<div class="figure">
<img src="https://hsto.org/storage/habraeffect/a1/0a/a10a744def8f325a1019502ecc175ef6.png" alt="treap" /><p class="caption">treap</p>
</div>
<p>Таким образом, декартово дерево — это одновременно <em>бинарное дерево</em> по <span class="math">\(x\)</span> и <em>куча</em> по <span class="math">\(y\)</span>. Поэтому ему придумали много альтернативных названий:</p>
<ul>
<li>Дерамида (дерево + пирамида)</li>
<li>ПиВо (пирамида + дерево)</li>
<li>КуРево (куча + дерево)</li>
<li>Treap (tree + heap)</li>
</ul>
<p>## Бинарные деревья</p>
<p>С небольшими модификациями, декартово дерево умеет всё то же, что и любое <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">бинарное дерево поиска</a>, например:</p>
<ul>
<li>добавить число <span class="math">\(x\)</span> в множество</li>
<li>определить, есть ли в множестве число <span class="math">\(x\)</span></li>
<li>найти первое число, не меньшее <span class="math">\(x\)</span> (<code>lower_bound</code>)</li>
<li>найти количество чисел в промежутке <span class="math">\([l, r]\)</span></li>
</ul>
<p>При этом все операции — за <span class="math">\(O(\log n)\)</span>.</p>
<p>На самом деле, бинарных деревьев очень много. В большинстве из них время выполнения операций пропорционально высоте дерева, поэтому в них придумываются разные инварианты, позволяющие эту высоту минимизировать до <span class="math">\(O(\log n)\)</span>.</p>
<h2 id="приоритеты-и-асимптотика">Приоритеты и асимптотика</h2>
<p>В декартовом дереве логарифмическая высота дерева гарантируется не инвариантами и эвристиками, а законами теории вероятностей: оказывается, что если все приоритеты (<span class="math">\(y\)</span>) выбирать случайно, то средняя глубина вершины будет логарифмической. Поэтому ДД ещё называют рандомизированным деревом поиска.</p>
<p><strong>Теорема</strong>. Ожидание глубины вершины в декартовом дереве равно <span class="math">\(O(n \log n)\)</span>.</p>
<p>Если не знаете, что такое ожидание, то на доказательство забейте: это будет на занятии по теорверу в конце года. Сейчас его можно пропустить.</p>
<p><strong>Доказательство</strong><em>. Введем функцию <span class="math">\(a(x, y)\)</span> равную единице, если <span class="math">\(x\)</span> является предком <span class="math">\(y\)</span>, и нулем в противном случае. Такие функции называются </em>индикаторами*.</p>
<p>Глубина вершины равна количеству её предков — прим. К. О. Таким образом, она равна</p>
<p><span class="math">\[d_i = \sum_{j=1}^n a(j, i)\]</span></p>
<p>Её матожидание равно</p>
<p><span class="math">\[E[d_i] = E[\sum_{j \neq i} a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} p(j, i)\]</span></p>
<p>где <span class="math">\(p(x, y)\)</span> это веряотность, что <span class="math">\(a(x, y) = 1\)</span>. Здесь мы воспользовались важным свойством <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D0%BE%D0%B9_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D1%8B#.D0.9B.D0.B8.D0.BD.D0.B5.D0.B9.D0.BD.D0.BE.D1.81.D1.82.D1.8C_.D0.BC.D0.B0.D1.82.D0.B5.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BE.D0.B6.D0.B8.D0.B4.D0.B0.D0.BD.D0.B8.D1.8F">линейности</a>: матожидание суммы чего угодно равна сумме матожиданий этого чего угодно.</p>
<p>Ок, теперь осталось посчитать эти вероятности и сложить. Но сначала нам понадобится вспомогательное утверждение.</p>
<p><strong>Лемма</strong>. Вершина <span class="math">\(x\)</span> является предком <span class="math">\(y\)</span>, если у неё приоритет больше, чем у всех вершин из отрезка <span class="math">\((x, y]\)</span> (без ограничения общности, будем считать, что <span class="math">\(x &lt; y\)</span>).</p>
<p><strong>Необходимость</strong>. Если это не так, то где-то между <span class="math">\(x\)</span> и <span class="math">\(y\)</span> есть вершина с большим приоритетом, чем <span class="math">\(x\)</span>. Она не может быть потомком <span class="math">\(x\)</span>, а значит <span class="math">\(x\)</span> и <span class="math">\(y\)</span> будут разделены.</p>
<p><strong>Достаточность</strong>. Если справа будет какая-то вершина с большим приоритетом, то её левым сыном будет какая-то вершина, которая будет являться предком <span class="math">\(x\)</span>. Таким образом, всё, что справа от <span class="math">\(y\)</span>, ни на что влиять не будет.</p>
<p>У всех вершин на любом отрезке одинаковая вероятность иметь наибольший приоритет. Объединяя этот факт с результатом леммы, мы можем получить выражение для искомых вероятностей:</p>
<p><span class="math">\[p(x, y) = \frac{1}{y-x+1}\]</span></p>
<p>Теперь, чтобы найти матожидание, эти вероятности надо просуммировать:</p>
<p><span class="math">\[E[d_i] = \sum_{j \neq i} p(j, i) = \sum_{j \neq i} \frac{1}{|i-j|+1} \leq \sum_{i=1}^n \frac{1}{n} = O(\log n)\]</span></p>
<p>Перед последним переходом мы получили сумму гармонического ряда.</p>
<p>Примечательно, что ожидаемая глубина вершин зависит от их позиции: вершина из середины должна быть примерно в два раза глубже, чем крайняя.</p>
<p><strong>Упражнение</strong>*. Выведите из этого доказательства асимптотику <code>quicksort</code>.</p>
<h2 id="реализация">Реализация</h2>
<p>Декартово дерево удобно писать на указателях и структурах. Поэтому мы <a href="http://sereja.me/a/segtree">рассказали</a> дерево отрезков на указателях, а не стандартную <a href="http://e-maxx.ru/algo/segment_tree">рекурсию на 5 параметрах</a>. Не знаете, что это такое — посмотрите в предыдущем конспекте.</p>
<p>Создадим структуру <code>Node</code>, в которой будем хранить ключ и приоритет, а также указатели на левого и правого сына. Указателя на корень дерева достаточно для идентификации всего дерева. Поэтому, когда мы будем говорить «функция принимает два дерева» на самом деле будут иметься в виду указатели на их корни. К нулевому указателю же мы будем относиться, как к «пустому» дереву.</p>
<p><code>c++ struct Node {     int key, prior;     Node *l = 0, *r = 0;     Node (int _key) { key = _key, prior = rand(); } };</code></p>
<p>Объявим две вспомогательные функции, изменяющие структуру деревьев: одна будет разделять деревья, а другая объединять. Как мы увидим, через них можно легко выразить почти все функции, которые нам потом понадобятся.</p>
<h3 id="merge">Merge</h3>
<p>Принимает два дерева (два корня, <span class="math">\(L\)</span> и <span class="math">\(R\)</span>), про которые известно, что в левом все вершины имеют меньший ключ, чем все в правом. Их нужно объединить в одно дерево так, чтобы ничего не сломалось: по ключам это всё ещё дерево, а по приоритетами — куча.</p>
<p>Сначала выберем, какая вершина будет корнем. Здесь всего два кандидата — левый корень <span class="math">\(L\)</span> или правый <span class="math">\(R\)</span> — просто возьмем тот, у кого приоритет больше.</p>
<p>Пусть, для однозначности, это был левый корень. Тогда левый сын корня итогового дерева должен быть левым сыном <span class="math">\(L\)</span>. С правым сыном сложнее: возможно, его нужно смерджить с <span class="math">\(R\)</span>. Поэтому рекурсивно сделаем <code>merge(l-&gt;r, r)</code> и запишем результат в качестве правого сына.</p>
<p><code>c++ Node* merge (Node *l, Node *r) {     if (!l) return r;     if (!r) return l;     if (l-&gt;prior &gt; r-&gt;prior) {         l-&gt;r = merge(l-&gt;r, r);         return l;     }     else {         r-&gt;l = merge(l, r-&gt;l);         return r;     } }</code></p>
<h3 id="split">Split</h3>
<p>Принимает дерево и ключ <span class="math">\(x\)</span>, по которому его нужно разделить на два: <span class="math">\(L\)</span> должно иметь все ключи не больше <span class="math">\(x\)</span>, а <span class="math">\(R\)</span> должно иметь все ключи больше <span class="math">\(x\)</span>.</p>
<p>В этой функции мы сначала решим, в каком из деревьев должен быть корень, а потом рекурсивно разделим его правую или левую половину и присоединим, куда надо:</p>
<p>```c++ typedef pair<Node*, Node*> Pair;</p>
<p>Pair split (Node *p, int x) { if (!p) return {0, 0}; if (p-&gt;key &lt;= x) { Pair q = split(p-&gt;r, x); p-&gt;r = q.first; return {p, q.second}; } else { Pair q = split(p-&gt;l, x); p-&gt;l = q.second; return {q.first, p}; } } ```</p>
<h3 id="пример-вставка">Пример: вставка</h3>
<p><code>merge</code> и <code>split</code> сами по себе не очень полезные, но помогут написать все остальное.</p>
<p>Вот так, например, будет выглядеть код, добавляющий <span class="math">\(x\)</span> в сет.</p>
<p>```c++ Node *root = 0;</p>
<p>void insert (int x) { Pair q = split(root, x); Node *t = new Node(x); root = merge(q.first, merge(t, q.second)); } ```</p>
<h3 id="пример-модификация-для-суммы-на-отрезке">Пример: модификация для суммы на отрезке</h3>
<p>Иногда нам нужно написать какие-то модификации для более продвинутых операций.</p>
<p>Например, нам может быть интересно иногда считать сумму чисел на отрезке. Для этого в вершине нужно хранить также своё число и сумму на своем «отрезке».</p>
<p><code>c++ struct Node {     int val, sum;     // ... };</code></p>
<p>При <code>merge</code> и <code>split</code> надо будет поддерживать эту сумму актуальной.</p>
<p>Вместо того, чтобы модифицировать и <code>merge</code>, и <code>split</code> под наши хотелки, напишем вспомогательные функцию <code>upd</code>, которую будем вызывать при обновлении детей вершины.</p>
<p>```c++ void sum (Node* v) { return v ? v-&gt;sum : 0; } // обращаться по пустому указателю нельзя -- выдаст ошибку</p>
<p>void upd (Node* v) { v-&gt;sum = sum(v-&gt;l) + sum(v-&gt;r) + v-&gt;val; } ```</p>
<p>В <code>merge</code> и <code>split</code> теперь можно просто вызывать <code>upd</code> перед тем, как вернуть вершину, и тогда ничего не сломается:</p>
<p><code>c++ Node* merge (Node *l, Node *r) {     // ...     if (...) {         l-&gt;r = merge(l-&gt;r, r);         upd(l);         return l;     }     else {         // ...     } }</code></p>
<p>```c++ typedef pair<Node*, Node*> Pair;</p>
<p>Pair split (Node *p, int x) { // ... if (...) { // ... upd(p); return {p, q.second}; } else { // ... } } ```</p>
<p>Тогда при запросе суммы нужно просто вырезать нужный отрезок и запросить эту сумму:</p>
<p><code>c++ int sum (int l, int r) {     Pair rq = split(root, r);     Pair lq = split(rq.first, l);     int res = sum(lr.second);     root = merge(lq.first, merge(lq.second, rq.second));     return res; }</code></p>
<h1 id="неявный-ключ">Неявный ключ</h1>
<p>Обычное декартово дерево — это структура для множеств, каждый элемент которых имеет какой-то ключ. Эти ключи задают на этом множестве какой-то порядок, и все запросы к ДД обычно как-то привязаны к этому порядку.</p>
<p>Но что, если у нас есть запросы, которые этот порядок как-то нетривиально меняют? Например, если у нас есть массив, в котором нужно уметь выводить сумму на произвольном отрезке и «переворачивать» произвольный отрезок. Если бы не было второй операции, мы бы просто использовали индекс элемента в качестве ключа, но с операцией переворота нет способа их быстро поддерживать актуальными.</p>
<p>Решение такое: выкинем ключи, а вместо них будем поддерживать информацию, которая поможет неявно восстановить ключ, когда он нам будет нужен. А именно, будем хранить вместе с каждой вершиной размер её поддерева:</p>
<p><code>c++ struct Node {     int key, prior, size = 1;     //              ^ размер поддерева     Node *l = 0, *r = 0;     Node (int _key) { key = _key, prior = rand(); } };</code></p>
<p>Размеры поддеревьев будем поддерживать по аналогии с суммой — напишем вспомогательную функцию, которую будем вызывать после каждого структурного изменения вершины.</p>
<p>```c++ int size (Node *v) { return v ? v-&gt;size : 0; }</p>
<p>void upd (Node *v) { v-&gt;size = 1 + size(v-&gt;l) + size(v-&gt;r); } ```</p>
<p><code>merge</code> не меняется, а вот в <code>split</code> нужно использовать позицию корня вместо его ключа.</p>
<p>Про <code>split</code> теперь удобнее думать как &quot;вырежи первые <code>k</code> элементов&quot;.</p>
<p>```c++ typedef pair<Node*, Node*> Pair;</p>
<p>Pair split (Node *p, int k) { if (!p) return {0, 0}; if (size(p-&gt;l) + 1 &lt;= k) { Pair q = split(p-&gt;r, k - size(p-&gt;l) - 1); // ^ правый сын не знает количество вершин слева от него p-&gt;r = q.first; upd(p); return {p, q.second}; } else { Pair q = split(p-&gt;l, k); p-&gt;l = q.second; upd(p); return {q.first, p}; } } ```</p>
<p>Всё. Теперь у нас есть клёвая гибкая структура, которую можно резать как угодно.</p>
<h3 id="пример-ctrlx-ctrlv">Пример: ctrl+x, ctrl+v</h3>
<p><code>c++ Node* ctrlx (int l, int r) {     Pair q1 = split(root, r);     Pair q2 = split(q1.first, l);     root = merge(q2.first, q1.second);     return q2.second; }</code></p>
<p><code>c++ void ctrlv (Node *v, int k) {     Pair q = split(root, k);     root = merge(q.first, merge(v, q.second)); }</code></p>
<h3 id="пример-переворот">Пример: переворот</h3>
<p>Нужно за <span class="math">\(O(\log n)\)</span> обрабатывать запросы переворота произвольных подстрок: значение <span class="math">\(a_l\)</span> поменять с <span class="math">\(a_r\)</span>, <span class="math">\(a_{l+1}\)</span> поменять с <span class="math">\(a_{r-1}\)</span> и т. д.</p>
<p>Будем хранить в кажой вершине флаг, который будет означать, что её подотрезок перевернут:</p>
<p><code>c++ struct Node {     bool rev;     // ... };</code></p>
<p>Поступим по аналогии с ДО — когда мы когда-либо встретим такую вершину, мы поменяем ссылки на её детей, а им самим передадим эту метку:</p>
<p><code>c++ void push (node *v) {     if (v-&gt;rev) {         swap(v-&gt;l, v-&gt;r);         if (v-&gt;l)             v-&gt;rev ^= 1;         if (v-&gt;r)             v-&gt;rev ^= 1;     }     v-&gt;rev = 0; }</code></p>
<p>Аналогично, эту функцию будем вызывать в начале <code>merge</code> и <code>split</code>.</p>
<p>Саму функцию <code>reverse</code> реализуем так: вырезать нужный отрезок, поменять флаг.</p>
<p><code>c++ void reverse (int l, int r) {     Pair q1 = split(root, r);     Pair q2 = split(q1.first, l)     q2.second-&gt;rev ^= 1;     root = merge(q2.first, merge(q2.second, q1.second)); }</code></p>
<h1 id="функциональное-программирование">Функциональное программирование*</h1>
<p>Реализация большинства операций всегда примерно одинаковая — вырезаем отрезок с <span class="math">\(l\)</span> по <span class="math">\(r\)</span>, что-то с ним делаем и склеиваем обратно.</p>
<p>Дублирующийся код — это плохо. Давайте используем всю мощь плюсов и определим функцию, которая принимает другую функцию, которая уже делает полезные вещи на нужном отрезке.</p>
<p>```c++ auto apply (int l, int r, auto f) { Pair q1 = split(root, r); Pair q2 = split(q1.first, l) q2.second = f(q2.second); root = merge(q2.first, merge(q2.second, q1.second)); }</p>
<p>void reverse (Node *v) { if (v) v-&gt;rev ^= 1; } ```</p>
<p>Применять её нужно так:</p>
<p><code>c++ apply(l, r, reverse);</code></p>
<p>Это работает в плюсах, начиная с <code>g++14</code>.</p>
<p>Для простых операций можно даже написать лямбду:</p>
<p><code>c++ apply(l, r, [](Node *v){     if (v)         v-&gt;rev ^= 1; });</code></p>
<h1 id="персистентность">Персистентность*</h1>
<p>Так же, как и с ДО, персистентной версией ДД можно решать очень интересные задачи.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления и вставки в произвольные позиции.</p>
</blockquote>
<p>Построим персистентное ДД. Тогда просто вызвав два <code>split</code>-а, мы можем получить копию любой подстроки (указатель вершину), которую потом можно вставлять куда угодно, при этом оригинальную подстроку мы не изменим.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления, вставки в произвольные позиции <strong>и сравнение произвольных подстрок</strong>.</p>
</blockquote>
<p>Можно в вершинах хранить <strong>полиномиальный хэш</strong> соответствующей подстроки. Тогда мы можем проверять равенство подстрок сравниванием хэшей вершин, полученных теми же двумя сплитами.</p>
<p>Чтобы полноценно сравнивать стоки лексикографически, можно применить бинарный поиск: перебрать длину совпадающего суффикса, и, когда она найдется, посмотреть на следующий символ.</p>
<p>Реализация почти такая же, как и для всех персистентных структур на ссылках — перед тем, как идти в какую-то вершину, нужно создать её копию и идти в неё. Создадим для этого вспомогательную функцию <code>copy</code>:</p>
<p><code>c++ Node* copy (Node *v) { return new Node(*v); }</code></p>
<p>Во всех методах мы будем начинать с копирования всех упоминаемых в ней вершин. Например, персистентный <code>split</code> начнётся так:</p>
<p><code>c++ Pair split (Node *p, int x) {     p = copy(p);     // ... }</code></p>
<p>В ДО просто создавать копии вершин было достаточно. Этого обычно достаточно для всех детерминированных структур данных, но в ДД всё сложнее. Оказывается существует тест, который «валит» приоритеты: можно раскопировать много версий одной вершины, а все остальные — удалить. Тогда у всех вершин будет один и тот же приоритет, и дерево превратится в «бамбук», в котором все операции будут работать за линию.</p>
<p>У этой проблемы есть очень элегантное решение — избавиться от приоритетов, и делать теперь следующее переподвешивание: если размер левого дерева равен <span class="math">\(L\)</span>, а размер правого <span class="math">\(R\)</span>, то будем подвешивать за левое с вероятностью <span class="math">\(\frac{L}{L+R}\)</span>, иначе за правое.</p>
<p><strong>Теорема</strong>. Такое переподвешивание эквивалентно приоритетам.</p>
<p><strong>Доказательство</strong>. Покажем, что все вершины всё так же имеют равную вероятность быть корнем. Докажем по индукции:</p>
<ul>
<li>Лист имеет вероятность 1 быть корнем себя (база индукции)</li>
<li>Переход индукции — операция <code>merge</code>. Любая вершина левого дерева была корнем с вероятностью <span class="math">\(\frac{1}{L}\)</span> (по предположению индукции), а после слияния она будет корнем всего дерева с вероятностью <span class="math">\(\frac{1}{L} \cdot \frac{L}{L+R} = \frac{1}{L+R}\)</span>. С вершинами правого дерева аналогично.</li>
</ul>
<p>Получается, что при таком переподвешивании всё так же каждая вершина любого поддерева равновероятно могла быть его корнем, а на этом основывалось наше доказательство асимптотики ДД.</p>
<p><code>c++ Node* merge (Node *l, Node *r) {     if (!l) return r;     if (!r) return l;     l = copy(l), r = copy(r);     if (rand() % (size(l) + size(r)) &lt; size(l)) {         // ...     }     else {         // ...     } }</code></p>
<p>Философский вопрос: можно ли декартово дерево называть декартовым, если из него удалить и <span class="math">\(x\)</span>, и <span class="math">\(y\)</span>?</p>
</body>
</html>
