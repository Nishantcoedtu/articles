<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="паросочетания">Паросочетания</h1>
<p>Пусть есть <span class="math">\(n\)</span> мальчиков и <span class="math">\(m\)</span> девочек. Про каждого мальчика и про каждую девочку известно, с кем они не против танцевать. Нужно составить как можно больше пар, в которых партнёры хотят танцевать друг с другом.</p>
<p><img src="http://www.science4all.org/wp-content/uploads/2012/06/maximum_matching.png"  width="400px"></p>
<p><strong>Паросочетанием</strong> <span class="math">\(M\)</span> называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из <span class="math">\(M\)</span>).</p>
<p>Все вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном <span class="math">\(M\)</span>), назовём <em>насыщенными</em> этим паросочетанием.</p>
<p><em>Мощностью</em> паросочетания назовём количество рёбер в нём. <em>Наибольшим</em> (<em>максимальным</em>) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе, а <em>совершенным</em> — где все вершины левой доли им насыщенны.</p>
<p>Паросочетания <a href="http://e-maxx.ru/algo/matching_edmonds">можно искать</a> в любых графах, однако этот алгоритм неприятно кодить, и он работает за <span class="math">\(O(n^3)\)</span>, так что сегодня мы сфокусируемся только на двудольных графах. Будем в дальнейшем обозначать левую долю графа как <span class="math">\(L\)</span>, а правую долю как <span class="math">\(R\)</span>.</p>
<p><strong>Цепью</strong> длины <span class="math">\(k\)</span> назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий ровно <span class="math">\(k\)</span> рёбер.</p>
<p><strong>Чередующейся цепью</strong> относительно некоторого паросочетания назовём простой путь длины <span class="math">\(k\)</span> в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.</p>
<p><strong>Увеличивающей цепью</strong> относительно некоторого паросочетания назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.</p>
<div class="figure">
<img src="https://neerc.ifmo.ru/wiki/images/4/4a/Alternating_path.jpg" />
</div>
<p><em>Здесь красными помечены вершины паросочетания, а в графе есть увеличивающая цепь: <span class="math">\(1 \to 8 \to 4 \to 6 \to 3 \to 7\)</span>.</em></p>
<p>Зачем нужны увеличивающие цепи? Оказывается, можно с их помощью увеличивать паросочетание на единицу (отсюда и название). Можно взять такой путь и провести <strong>чередование</strong> — убрать из паросочетания все рёбра, принадлежащие цепи, и, наоборот, добавить все остальные. Всего в увеличивающей цепи нечетное число рёбер, а первое и последнее были не в паросочетании. Значит, мощность паросочетания увеличилась ровно на единицу.</p>
<p>В примере добавятся синие рёбра <span class="math">\((1, 8)\)</span>, <span class="math">\((3, 7)\)</span> и <span class="math">\((4, 6)\)</span>, а удалятся красные <span class="math">\((3, 6)\)</span> и <span class="math">\((4, 8)\)</span>. С ребром <span class="math">\((2, 5)\)</span> ничего не случится — оно не в увеличивающей цепи. Таким образом, размер паросочетания увеличится на единицу.</p>
<p><strong>Алгоритм Куна</strong> в этом и заключается — будем искать увеличивающую цепь, пока ищется, и проводить чередование в ней. Увеличивающие цепи удобны тем, что их легко искать: можно просто запустить поиск пути из произвольной свободной вершины из левой доли в какую-нибудь свободную вершину правой доли в том же графе, но в котором из правой доли можно идти только по рёбрам паросочетания (то есть у вершин правой доли будет либо одно ребро, либо ноль). Это можно делать как угодно (для упражнения автор рекомендует явно строить такой граф, искать путь и явно проводить чередования), однако устоялась эффективная реализация в виде dfs на 20 строчек кода, приведённая ниже.</p>
<p>```c++ const int maxn;</p>
<p>vector<int> g[maxn]; // будем хранить только рёбра из левой доли в правую int mt[maxn]; // с какой вершиной сматчена вершина правой доли (-1, если ни с какой) bool used[maxn]; // вспомогательный массив для поиска пути dfs-ом</p>
<p>// dfs возвращает, можно ли найти путь из вершины v // в какую-нибудь вершину правой доли // если можно, то ещё и проводит чередование bool dfs (int v) { if (used[v]) return false; used[v] = true; for (int u : g[v]) { // если вершина свободна, то можно сразу с ней соединиться // если она занята, то с нейможно соединиться только тогда, // когда из её текущей пары можно найти какую-нибудь другую вершину if (mt[u] == -1 || dfs(mt[u])) { mt[u] = v; return true; } } return false; }</p>
<p>// где-то в main:</p>
<p>memset(mt, -1, sizeof(mt)); for (int i = 0; i &lt; n; i++) { memset(used, 0, sizeof(mt)); if (dfs(i)) cnt++; } ```</p>
<h2 id="корректность">Корректность</h2>
<p>Для доказательства алгоритма нам будет достаточно ещё доказать, что если увеличивающие цепи уже не ищутся, то паросочетание в принципе нельзя увеличить.</p>
<p><strong>Теорема (Бержа)</strong>. Паросочетание без увеличивающих цепей является максимальным.</p>
<p><strong>Доказательство</strong> проведём от противного: пусть есть два паросочетания вершин <span class="math">\(|A| \leq |B|\)</span>, и для <span class="math">\(A\)</span> нет увеличивающих путей, и покажем, как найти этот путь и увеличить <span class="math">\(A\)</span> на единицу.</p>
<p>Раскрасим ребра из паросочетания, соответствующего <span class="math">\(A\)</span> в красный цвет, <span class="math">\(B\)</span> — в синий, а ребра из обоих паросочетаний — в пурпурный. Рассмотрим граф из только красных и синих ребер. Любая компонента связности в нём представляет собой либо путь, либо цикл, состоящий из чередующихся красных и синих ребер. В любом цикле будет равное число красных и синих рёбер, а так как всего синих рёбер больше, то должен существовать путь, начинающийся и оканчивающийся синим ребром — он и будет увеличивающей цепью для <span class="math">\(A\)</span>, а значит <span class="math">\(A\)</span> не оптимальное, и мы получили противоречие.</p>
<h2 id="скорость-работы">Скорость работы</h2>
<p>Такой алгоритм ровно <span class="math">\(n\)</span> раз ищет увеличивающий путь, каждый раз просматривая не более <span class="math">\(m\)</span> рёбер, а значит работает за <span class="math">\(O(nm)\)</span>.</p>
<p>Что примечательно, его можно не бояться запускать на ограничениях и побольше (<span class="math">\(n, m \approx 10^4\)</span>), потому что для него есть мощные неасимптотические оптимизации:</p>
<ul>
<li><p>Eго можно жадно инициализировать (просто заранее пройтись по вершинам левой доли и сматчить их со свободной вершиной правой, если она есть).</p></li>
<li><p>Можно не заполнять нулями на каждой итерации массив <code>used</code>, а использовать следующий трюк: хранить в нём вместо булева флага версию последнего изменения, а конкретно -- номер итерации, на которой это значение стало <code>true</code>. Если этот номер меньше текущего номера итерации, то мы можем воспринимать это значение как <code>false</code>. В каком-то смысле это позволяет эмулировать очищение массива за константу.</p></li>
<li><p>Очень часто граф приходит из какой-то другой задачи, природа которой накладывает ограничения на его вид. Например, в задачах на решетках (когда есть двумерный массив, и соседние клетки связаны друг с другом) граф двудольный, но степень каждой вершины маленькая, и граф имеет очень специфичную структуру, и на нём алгоритм Куна работает быстрее, чем ожидается из формулы <span class="math">\(n \times m\)</span>. Контрпримеры в таких задачах на самом деле почти всегда можно сгенерировать, но авторы редко так заморачиваются.</p></li>
</ul>
<p>Вообще говоря, увлекаться ускорением алгоритма Куна не стоит — существует более асимптотически быстрый алгоритм. Задача нахождения максимального паросочетания — частный случай задачи о максимальном потоке, и если применить <a href="http://e-maxx.ru/algo/dinic">алгоритм Диница</a> к двудольным графам с единичной пропускной способностью, то выясняется, что работать он будет за <span class="math">\(O(n \sqrt m)\)</span>.</p>
<h2 id="покрытие-путями-dag-а">Покрытие путями DAG-а</h2>
<p>Сводить задачи к поиску максимального паросочетания обычно не очень трудно, но в некоторых случаях самому додуматься сложно. Разберём одну такую известную задачу. Дан ориентированный ациклический граф <span class="math">\(G\)</span> (англ. <em>directed acyclic graph</em>). Требуется покрыть его наименьшим числом путей, то есть найти наименьшее множество простых путей, где каждая вершина принадлежит ровно одному пути.</p>
<p>Построим соответствующие изначальному графу <span class="math">\(G\)</span> два двудольных графа <span class="math">\(H\)</span> и <span class="math">\(\overline{H}\)</span> следующим образом: * В каждой доле графа <span class="math">\(H\)</span> будет по <span class="math">\(n\)</span> вершин. Обозначим их через <span class="math">\(a_i\)</span> и <span class="math">\(b_i\)</span> соответственно. * Для каждого ребра <span class="math">\((i, j)\)</span> исходного графа <span class="math">\(G\)</span> проведём соответствующее ребро <span class="math">\((a_i, b_j)\)</span> в графе <span class="math">\(H\)</span>. * Теперь из графа <span class="math">\(H\)</span> сделаем граф <span class="math">\(\overline{H}\)</span>, добавив обратное ребро <span class="math">\((b_i, a_i)\)</span> для каждого <span class="math">\(i\)</span>.</p>
<p>Если мы рассмотрим любой путь <span class="math">\(v_1, v_2, \ldots, v_k\)</span> в исходном графе <span class="math">\(G\)</span>, то в графе <span class="math">\(\overline{H}\)</span> ему будет соответствовать путь <span class="math">\(a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, \ldots, a_{v_{k-1}}, b_{v_k}\)</span>. Обратное тоже верно: любой путь, начинающийся в левой доле <span class="math">\(\overline{H}\)</span> и заканчивающийся в правой будет соответствовать какому-то пути в <span class="math">\(G\)</span>.</p>
<p>Итак, есть взаимно однозначное соответствие между путями в <span class="math">\(G\)</span> и путями <span class="math">\(\overline{H}\)</span>, идущими из левой доли в правую. Заметим, что любой такой путь в <span class="math">\(\overline{H}\)</span> — это паросочетание в <span class="math">\(H\)</span> (напомним, это <span class="math">\(\overline{H}\)</span> без обратных рёбер). Получается, любому пути из <span class="math">\(G\)</span> можно поставить в соответствие паросочетание в <span class="math">\(H\)</span>, и наоборот. Более того, непересекающимся путям в <span class="math">\(G\)</span> соответствуют непересекающиеся паросочетания в <span class="math">\(H\)</span>.</p>
<p>Заметим, что если есть <span class="math">\(p\)</span> непересекающихся путей, покрывающих все <span class="math">\(n\)</span> вершин графа, то они вместе содержат <span class="math">\(r = n - p\)</span> рёбер. Отсюда получаем, что чтобы минимизировать число путей <span class="math">\(p\)</span>, мы должны максимизировать число рёбер <span class="math">\(r\)</span> в них.</p>
<p>Мы теперь можем свести задачу к нахождению максимального паросочетания в двудольном графе <span class="math">\(H\)</span>. После нахождения этого паросочетания мы должны преобразовать его в набор путей в <span class="math">\(G\)</span>. Это делается тривиальным алгоритмом: возьмем <span class="math">\(a_1\)</span>, посмотрим, с какой <span class="math">\(b_k\)</span> она соединена, посмотрим на <span class="math">\(a_k\)</span> и так далее. Некоторые вершины могут остаться ненасыщенными — в таком случае в ответ надо добавить пути нулевой длины из каждой из этих вершин.</p>
<h2 id="лемма-холла">Лемма Холла</h2>
<p><em>Лемма Холла</em> (или: <em>теорема о свадьбах</em>) — очень удобный критерий в задачах, где нужно проверить, что паросочетание существует, но при этом не требуется строить его явно.</p>
<div class="figure">
<img src="https://neerc.ifmo.ru/wiki/images/2/2f/Aba.gif" />
</div>
<p><strong>Лемма Холла</strong>. Полное паросочетание существует тогда и только тогда, когда любая группа вершин левой доли соединена с не меньшим количеством вершин правой доли.</p>
<p><strong>Доказательство</strong>. В одну сторону понятно — если совершенное паросочетание есть, то для любого подмножества вершин левой доли можно взять вершины правой, соединенные с ним паросочетанием.</p>
<p>В другую сложнее — нужно воспользоваться индукцией. Будем доказывать, что если паросочетание не полное, то можно в таком графе найти увеличивающую цепь, и с её помощью увеличить паросочетание на единицу.</p>
<p><strong>База индукции</strong>: одна вершина из <span class="math">\(L\)</span>, которая по условию соединена с хотя бы одной вершиной из <span class="math">\(R\)</span>.</p>
<p><strong>Индукционный переход</strong>: пусть после <span class="math">\(k &lt; n\)</span> шагов построено паросочетание <span class="math">\(M\)</span>. Докажем, что в <span class="math">\(M\)</span> можно добавить вершину <span class="math">\(v\)</span> из <span class="math">\(L\)</span>, не насыщенную паросочетанием.</p>
<p>Рассмотрим множество вершин <span class="math">\(H\)</span> — все вершины, достижимые из <span class="math">\(x\)</span>, если можно ходить из правой доли в левую только по рёбрам паросочетания, а из левой в правую — по любым (мы такой граф по сути строим, когда ищем увеличивающую цепь в алгоритме Куна)</p>
<p>Тогда в <span class="math">\(H\)</span> найдется вершина <span class="math">\(y\)</span> из <span class="math">\(R\)</span>, не насыщенная паросочетанием. Иначе, если такой вершины нет, то получается, что если рассмотреть вершины <span class="math">\(H_L\)</span> (вершины левой доли, насыщенные паросочетанием), то для них не будет выполнено условие, что <span class="math">\(|H_L| \leq |N(H_L)|\)</span> (здесь <span class="math">\(N(X)\)</span> — множество вершин, соединенным паросочетанием с <span class="math">\(X\)</span>).</p>
<p>Тогда должен существовать путь из <span class="math">\(x\)</span> в <span class="math">\(y\)</span>, и он будет увеличивающим для паросочетания <span class="math">\(M\)</span>, потому что из <span class="math">\(R\)</span> в <span class="math">\(L\)</span> мы всегда шли только по ребрам паросочетания. Проведя чередование вдоль этого пути, получим большее паросочетание, следовательно предположение индукции верно.</p>
<h2 id="для-ноулайферов-матроиды">Для ноулайферов: матроиды</h2>
<p>С весьма большой вероятностью матроиды вам никогда не пригодится в школьных олимпиадах, однако, если вам совсем нечего делать, <a href="http://sereja.me/a/matroid">можете про них почитать</a>.</p>
<p>Математика вообще занимается тем, что обобщает всякие объекты и старается формулировать все теоремы максимально абстрактно. Так, концепцию <em>хороших подмножеств</em> (паросочетаний) обобщает понятие <strong>матроида</strong>. Практическое применение — жадный алгоритм Радо-Эдмондса, который нужен для обоснования большого числа жадников, где нужно набрать какое-то подмножество минимального / максимального веса. Сам алгоритм максимально простой: давайте отсортируем эти объекты по весу и будем добавлять их в таком порядке в наше <em>хорошее</em> множество, если оно после добавления остается <em>хорошим</em>.</p>
<p><strong>Применимо к паросочетаниям</strong>: пусть у вершин левой доли есть вес, и нам нужно набрать максимальное паросочетание минимального веса. Тогда выясняется, что можно просто отсортировать вершины левой доли по весу и пытаться в таком порядке добавлять их в паросочетание стандартным алгоритмом Куна.</p>
</body>
</html>
