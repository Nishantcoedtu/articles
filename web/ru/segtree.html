<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="дерево-отрезков">Дерево отрезков</h1>
<p><strong>Замечание</strong>. Почти везде мы будем использовать полуинтервалы — обозначаемые как <span class="math">\([l, r)\)</span> — вместо отрезков. Несмотря на контринтуитивность, это немного упростит код и вообще является хорошей практикой в программировании, подобно нумерации с нуля.</p>
<p><strong>Дерево отрезков</strong> — очень мощная и гибкая структура данных, позволяющая быстро отвечать на самые разные запросы на отрезках.</p>
<p>Рассмотрим конкретную задачу:</p>
<blockquote>
<p>Дан массив <span class="math">\(a\)</span> из <span class="math">\(n\)</span> целых чисел, нужно уметь отвечать на запросы двух типов:</p>
</blockquote>
<blockquote>
<ol style="list-style-type: decimal">
<li>Изменить значение в ячейке (т. е. отреагировать на присвоение <code>a[k] = x</code>).</li>
<li>Вывести сумму элементов <span class="math">\(a_i\)</span> на отрезке с <span class="math">\(l\)</span> по <span class="math">\(r\)</span>.</li>
</ol>
</blockquote>
<blockquote>
<p>Оба запроса нужно обрабатывать за время <span class="math">\(O(\log n)\)</span>.</p>
</blockquote>
<p>Чтобы решить задачу, сделаем с исходным массивом следующие манипуляции:</p>
<p>Посчитаем сумму всего массива и где-нибудь запишем. Потом разделим его пополам и посчитаем сумму на половинах и тоже где-нибудь запишем. Каждую половину потом разделим пополам ещё раз, и так далее, пока не придём к отрезкам длины 1.</p>
<p>Эту последовательность разбиений можно представить в виде дерева. Корень этого дерева соответствует отрезку <span class="math">\([0, n)\)</span>, а каждая вершина (не считая листьев) имеет ровно двух сыновей, которые тоже соответствуют каким-то отрезкам. Отсюда и название — «дерево отрезков».</p>
<div class="figure">
<img src="http://i.imgur.com/GGBmcEP.png" alt="alt text" /><p class="caption">alt text</p>
</div>
<p>Строить его можно рекурсивной функцией: * Если вершина является листом, взять в качестве суммы значение соответствующей ячейки. * Если вершина является отрезком, разделить его на два и в качестве суммы взять сумму его детей.</p>
<h2 id="разные-свойства">Разные свойства</h2>
<p>Высота такого дерева есть величина <span class="math">\(\Theta(\log n)\)</span>: на каждом новом уровне длина отрезка уменьшается вдвое. Этот факт будет ключевым для оценки асимптотики.</p>
<p>Более того, любой полуинтервал разбивается на <span class="math">\(O(\log n)\)</span> неперекрывающихся полуинтервалов, соответствующих в вершинам дерева: с каждого уровня нам достаточно не более двух отрезков.</p>
<p>Дерево также содержит менее <span class="math">\(2n\)</span> вершин: первый уровень дерева отрезков содержит одну вершину (корень), второй уровень — в худшем случае две вершины, на третьем уровне в худшем случае будет четыре вершины, и так далее, пока число вершин не достигнет <span class="math">\(n\)</span>. Таким образом, число вершин в худшем случае оценивается суммой <span class="math">\(n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \ldots + 1 &lt; 2n\)</span>. Значит, оно линейное по памяти.</p>
<p>При <span class="math">\(n\)</span>, отличных от степеней двойки, не все уровни дерева отрезков будут полностью заполнены. Например, при <span class="math">\(n=3\)</span> левый сын корня есть отрезок <span class="math">\([0, 2)\)</span>, имеющий двух потомков, в то время как правый сын корня — отрезок <span class="math">\([2, 3)\)</span>, являющийся листом.</p>
<h2 id="ок-как-это-нам-поможет">Ок, как это нам поможет?</h2>
<p>Опишем теперь, как с помощью такой структуры решить задачу.</p>
<p><strong>Запрос обновления</strong>. Нам нужно обновить значения в вершинах таким образом, чтобы они соответствовали новому значению <span class="math">\(a[k] = x\)</span>.</p>
<p>Изменим все вершины, в суммах которых участвует <span class="math">\(k\)</span>-тый элемент. Их будет <span class="math">\(\Theta(\log n)\)</span> — по одной с каждого уровня.</p>
<p>Это можно реализовать как рекурсивную функцию: ей передаётся текущая вершина дерева отрезков, и эта функция выполняет рекурсивный вызов от одного из двух своих сыновей (от того, который содержит <span class="math">\(k\)</span>-ый элемент в своём отрезке), а после этого — пересчитывает значение суммы в текущей вершине точно таким же образом, как мы это делали при построении дерева отрезков.</p>
<p><strong>Запрос суммы</strong>. Мы знаем, что во всех вершинах лежат корректные значения.</p>
<p>Сделаем тоже рекурсивную функцию, рассмотрев три случая:</p>
<ul>
<li>Если отрезок вершины лежит целиком в отрезке запроса, то вернуть записанную в ней сумму.</li>
<li>Если отрезки вершины и запроса не пересекаются, то вернуть 0.</li>
<li>Иначе разделиться рекурсивно на 2 и вернуть сумму этой функции от обоих детей.</li>
</ul>
<p>Чтобы разобраться, почему это работает за <span class="math">\(O(\log n)\)</span>, нужно оценить количество «интересных» отрезков — тех, которые порождают новые вызовы рекурсии. Это будут только те, которые содержат границу запросов — остальные сразу завершатся. Обе границы отрезка содержатся в <span class="math">\(O(\log n)\)</span> отрезках, а значит и итоговая асимптотика будет такая же.</p>
<h2 id="ликбез-по-c">Ликбез по C++</h2>
<p>Наша реализация будет на указателях. Никто не говорит, что она самая лучшая (см. раздел «Другие реализации»), но она самая понятная. Вам может поначалу показаться, что она слишком сложная, но позже вы поймёте её преимущества.</p>
<p>Но сначала нам нужно рассказать про объектно-ориентированное программирование и некоторые фишки C++. Если вы их уже знаете, то можете пропускать этот раздел.</p>
<p>Объект — это сущность, которой можно посылать сообщения и которая может на них реагировать, используя свои данные. Инкапсулировать логику в объекты на самом деле очень удобно. Дереву отрезков не важно знать, как устроен окружающий мир, а миру не важно, как внутри устроено дерево отрезков — это просто какая-то структура, которая умеет делать нужные операции за <span class="math">\(O(\log n)\)</span>.</p>
<p>В C++ есть два способа объявлять классы (объект — это экземпляр класса): через <code>struct</code> и через <code>class</code>. Их основное отличие в том, что по умолчанию в <code>class</code> все поля приватные — к ним нет прямого доступа снаружи. Это нужно для дополнительной защиты, чтобы в крупных промышленных проектах никто случайно ничего не поломал, но на олимпиадах это не очень актуально.</p>
<p>У классов есть поля (переменные) и методы (функции, привязанные к объектам). Среди них есть особые, например <strong>конструктор</strong> — он вызывается при создании объекта. Чтобы объявить конструктор класса в C++, нужно объявить внутри него метод с тем же названием, что и у самого класса.</p>
<p><code>c++ struct A {     int param1, param2; // тут можно что-то хранить     char param3 = 'k';     A (int var) {         // эта часть называется конструктором         // ...     }     void do_something () {         // это какой-то другой метод         // ...     } }; // &lt;- не забудьте точку с запятой</code></p>
<p>Другое важное понятие — указатель. Память можно представлять как просто очень большой массив. На самом деле, когда мы создаем какой-то объект, отдельная программа (<em>аллокатор</em>) выделяет место в массиве (<em>оперативной памяти</em>) под этот объект и возвращает позицию (<em>указатель</em>) на место в этом массиве.</p>
<p>Указатели нам нужны для того, чтобы хранить ссылки на детей. Имея указатель на объект, можно делать всё то же, что и имея сам объект, только синтаксис немного поменяется:</p>
<p>```c++ A x(179); x.do_something(); x.param1 = 57;</p>
<p>A *y = new A(42); // new возвращает адрес, по которому можно найти объект y-&gt;do_something(); y.param3 = '!'; ```</p>
<p>Кстати, вы не задумывались, почему мы перешли с 32-битных процессоров на 64-битные? Каждый указатель ссылается на байт — более точный адрес менеджер памяти выделять не умеет. Поэтому 32-битный компьютер умеет работать только с не более, чем <span class="math">\(2^{32}\)</span> байтами памяти — ровно 4 гигабайта — что с какого-то момента начало нехватать. Большинство операций — это операции с памятью, и размерность повысили именно из-за этого, а не чтобы операции с <code>long long</code> быстрее считались</p>
<h2 id="реализация">Реализация</h2>
<p>Общий план реализации любых структур данных: 1. Полностью понять все <em>инварианты</em> — как должна выглядеть структура, какие значения должны принимать поля, etc. 2. Формально описать, что должны делать методы и за какую асимптотику. 3. Решить много отдельных задач, реализуя методы, не нарушающие инварианты.</p>
<p><code>c++ struct segtree {     int lb, rb; // левые и правые границы отрезков     int sum = 0; // сумма на текущем отрезке     segtree *l = 0, *r = 0;     segtree (int _lb, int _rb) {         lb = _lb, rb = _rb;         if (lb + 1 &lt; rb) {             // если не лист, создаем детей             int t = (lb + rb) / 2;             l = new segtree(lb, t);             r = new segtree(t, rb);         }     }     void add (int k, int x) {         sum += x;         if (l) {             if (k &lt; l-&gt;rb)                 l-&gt;add(k, x);             else                 r-&gt;add(k, x);         }     }     int get_sum (int lq, int rq) {         if (lb &gt;= lq &amp;&amp; rb &lt;= rq)             // если мы лежим полностью в отрезке запроса, вывести сумму             return sum;         if (max(lb, lq) &gt;= min(rb, rq))             // если мы не пересекаемся с отрезком запроса, вывести ноль             return 0;         // иначе всё сложно -- запускаемся от детей и пусть они там сами решают         return l-&gt;get_sum(lq, rq) + r-&gt;get_sum(lq, rq);     } };</code></p>
<blockquote>
<p>Посчитать число беспорядков в перестановке из <span class="math">\(n\)</span> элементов (беспорядок или инверсия — это пара чисел <span class="math">\(i &lt; j\)</span>, для которых <span class="math">\(p_i &gt; p_j\)</span>).</p>
</blockquote>
<p>Эта задача решается просто, если уметь писать сортировку слиянием вручную. Но мы пойдем по другому пути. Создадим ДО для суммы на <span class="math">\(n\)</span> элементов, изначально заполненное нулями. Теперь будем проходить по этому массиву слева направа. Когда обрабатываем очередное число <span class="math">\(x\)</span>, будем делать две вещи: * Запросим сумму от <span class="math">\(k\)</span> до <span class="math">\(n\)</span> в ДО. * Добавим единичку в <span class="math">\(k\)</span>-тую позицию в ДО.</p>
<p>Так мы для каждой инверсии учтём её, когда запросим сумму для её правого элемента. Таким образом, мы решили эту задачу за <span class="math">\(O(n \log n)\)</span> запросов.</p>
<blockquote>
<p>Даны <span class="math">\(n\)</span> точек на плоскости с целыми координатами от 1до <span class="math">\(n\)</span>. Требуется ответить на <span class="math">\(m\)</span> запросов количества точек на прямоугольнике.</p>
</blockquote>
<p>Ответим на все запросы в оффлайн, используя метод сканирующей прямой:</p>
<ul>
<li>Разобьем запросы суммы на прямоугольнике на два запроса суммы на префиксах — сумма на прямоугольнике <span class="math">\([x_1, x_2] \times [y_1, y_2]\)</span> равна сумме на прямоугольнике <span class="math">\([0, x_2] \times [y_1, y_2]\)</span> минус сумма на прямоугольнике <span class="math">\([0, x_1] \times [y_1, y_2]\)</span>.</li>
<li>Отсортируем теперь все точки и префиксные запросы по их <span class="math">\(x\)</span>. При этом, если у точки и запроса одинаковый <span class="math">\(x\)</span>, то точка должна идти раньше.</li>
<li>Пройдёмся по ним в таком порядке и будем решать задачу для одномерной суммы: у нас есть операция «сделать +1 в <span class="math">\(y_i\)</span>» и «вывести сумму с <span class="math">\(y_1\)</span> по <span class="math">\(y_2\)</span>».</li>
</ul>
<h2 id="отложенные-операции">Отложенные операции</h2>
<p>Пусть теперь наш запрос обновления — это присвоение значения <span class="math">\(x\)</span> всем элементам некоторого отрезка <span class="math">\([l, r)\)</span>, а не только одному.</p>
<p>Мы не хотим спускаться до каждого элемента, где меняется сумма — их может быть очень много. Мы схитрим, и при запросе присваивания будем, по возможности, помечать некоторые вершины, что они и все их дети «покрашены» в какое-то число. Непосредственно спускаться до листьев мы не будем.</p>
<p>Например, если пришел запрос «присвой число <span class="math">\(x\)</span> на всем массиве», то мы вообще фактических присвоений делать не будем — только оставим пометку в корне дерева, что оно покрашено.</p>
<p>Когда нам позже понадобятся правильные значения таких вершин и их детей, мы будем делать «проталкивание» информации из текущей вершины в её сыновей: если метка стоит, пересчитаем сумму текущего отрезка и передадим эту метку сыновьям. Когда нам потом понадобятся сыновья, мы будем делать то же самое. Подобная операция будет гарантировать корректность данных в вершине ровно к тому моменту, когда они нам понадобятся.</p>
<p>Понятно, что от использования таких «запаздывающих» обновлений асимптотика никак не уходшается, и мы можем всё так же решить задачу за <span class="math">\(O(n \log n)\)</span>.</p>
<p>При реализации создадим вспомогательную функцию <code>push</code>, которая будет производить проталкивание информации из этой вершины в обоих её сыновей. Вызывать её стоит в самом начале обработки любого запроса — тогда она гарантирует, что в текущей вершине и её сыновьях все значения корректны.</p>
<p><code>c++ struct segtree {     int lb, rb;     int sum = 0, assign = -1;     segtree *l = 0, *r = 0;     segtree (int _lb, int _rb) {         lb = _lb, rb = _rb;         if (lb + 1 &lt; rb) {             int t = (lb + rb) / 2;             l = new segtree(lb, t);             r = new segtree(t, rb);         }     }     void push () {         if (assign != -1) {             sum = (rb-lb) * assign;             if (l) { // если дети есть                 l-&gt;assign = assign;                 r-&gt;assign = assign;             }         }         assign = -1;     }     void upd (int lq, int rq, int x) {         push();         if (lq &lt;= lb &amp;&amp; rb &lt;= rq)             assign = x;         else if (l &amp;&amp; max(lb, lq) &lt; min(rb, rq)) {             // если есть дети и отрезок запроса хоть как-то пересекается с нашим             l-&gt;upd(lq, rq, x);             r-&gt;upd(lq, rq, x);             // ...дальше они сами разберутся         }     }     int get_sum (int lq, int rq) {         push();         if (lb &gt;= lq &amp;&amp; rb &lt;= rq)             return sum;         if (max(lb, lq) &gt;= min(rb, rq))             return 0;         return l-&gt;get_sum(lq, rq) + r-&gt;get_sum(lq, rq);     } };</code></p>
<p>По-английски эта техника называется <em>lazy propagation</em>. <strong>Очень важно научиться её писать</strong> — она часто встречается на олимпиадах.</p>
<p>Идея «давайте будем всё делать в последний момент» применима не только в ДО, но и в других структурах <s>и в реальной жизни</s>.</p>
<h2 id="динамическое-построение">Динамическое построение</h2>
<p>А что, если у нас все индексы лежать не от в пределах <span class="math">\(10^5\)</span>, а, например, <span class="math">\(10^9\)</span>. Все асимптотики нас по прежнему устраивают (<span class="math">\(\log_2 10^6 \approx 20\)</span>, <span class="math">\(\log_2 10^9 \approx 30\)</span>), кроме этапа построения.</p>
<p>Можно решить эту проблему так: откажемся от явного создания всех вершин дерева изначально. Изначально создадим только лишь корень, а остальные вершины будем создавать на ходу, когда в них потребуется записать что-то не дефолтное — как в lazy propagation.</p>
<p>Реализовать это можно так же, как и с <code>push</code>-ем: в начале всех методов будем проверять, что дети-вершины созданы, и создавать их, если это не так.</p>
<p><code>c++ struct segtree {     int lb, rb;     int sum = 0;     segtree *l = 0, *r = 0;     segtree (int _lb, int _rb) {         lb = _lb, rb = _rb;         // а тут ничего нет     }     void extend () {         if (!l &amp;&amp; lb + 1 &lt; rb) {             int t = (lb + rb) / 2;             l = new segtree(lb, t);             r = new segtree(t, rb);         }     }     void add (int k, int x) {         extend();         sum += x;         if (l) {             if (k &lt; l-&gt;rb)                 l-&gt;add(k, x);             else                 r-&gt;add(k, x);         }     }     int get_sum (int lq, int rq) {         if (lb &gt;= lq &amp;&amp; rb &lt;= rq)             return sum;         if (max(lb, lq) &gt;= min(rb, rq))             return 0;         extend();         return l-&gt;get_sum(lq, rq) + r-&gt;get_sum(lq, rq);     } };</code></p>
<p>Но вообще, в большинстве случаев, использовать динамическое построение — это как стрелять из пушки по воробьям. Если все запросы известны заранее, то их координаты можно просто сжать перед обработкой запросов. Автор обычно делает это так:</p>
<p><code>c++ vector&lt;int&gt; compress (vector&lt;int&gt; a) {     vector&lt;int&gt; b = a;     sort(b.begin(), b.end());     b.erase(unique(b.begin(), b.end()), b.end());     for (int &amp;x : a)          x = int(lower_bound(b.begin(), b.end(), x) - b.begin());     return a; }</code></p>
<h2 id="персистентность">Персистентность</h2>
<p>Структуры данных называют <strong>персистентными</strong>, если их можно быстро «откатить» до произвольного предыдущего состояния.</p>
<p>Известны персистентные версии многих структур: стэка, очереди, СНМ, ДО. В случае со структурами данных на ссылках есть следующий общий подход: во всех методах, меняющих значения в вершинах, будем копировать ссылки на детей перед тем, как в них переходить и что-либо менять. Таким образом, мы всегда будем делать копию вершины перед тем, как что-либо менять в ней самой или её потомках. Вершины в момент <span class="math">\(t\)</span> никогда не будут ссылаться на вершины, измененные после этого, и поэтому ничего не сломается.</p>
<p>У персистентных структур есть один минус: они обычно требуют больше памяти. В случае ДО мы будем создавать <span class="math">\(O(\log n)\)</span> новых вершин на запрос, что означает общее потребление памяти <span class="math">\(O(m \log n)\)</span>.</p>
<p><code>c++ struct segtree {     int lb, rb;     int sum = 0;     segtree *l = 0, *r = 0;     segtree (int _lb, int _rb) {         lb = _lb, rb = _rb;         if (lb != rb) {             int t = (lb + rb) / 2;             l = new segtree(lb, t);             r = new segtree(t, rb);         }     }     void copy () {         if (l) {             l = new segtree(l);             r = new segtree(r);         }     }     void add (int k, int x) {         copy();         sum += x;         if (l) {             if (k &lt; l-&gt;rb) l-&gt;add(k, x);             else r-&gt;add(k, x);         }     }     int get_sum (int lq, int rq) {         // этот метод ничего не меняет -- он и так хороший         if (lq &lt;= lb &amp;&amp; rb &lt;= rq)             return sum;         if (max(lb, lq) &gt;= min(rb, rq))             return 0;         return l-&gt;get_sum(lq, rq) + r-&gt;get_sum(lq, rq);     } };</code></p>
<blockquote>
<p>Даны <span class="math">\(n\)</span> точек на плоскости. Нужно <em>в онлайн</em> ответить на <span class="math">\(q\)</span> запросов суммы на прямоугольнике.</p>
</blockquote>
<p>Если бы можно было отвечать в оффлайн, мы бы воспользовались методом сканирующей прямой — но так делать мы не можем. Вместо этого мы будем таким же образом добавлять точки в порядке увеличения <span class="math">\(x_i\)</span> и декомпозировать запрос суммы на два, но при ответе на эти запросы мы будем доставать соответствующую версию ДО, которую мы получили, обработав нужное количество точек. Таким образом, можно отвечать на запросы в онлайн, но с <span class="math">\(O(n \log n)\)</span> памяти.</p>
<blockquote>
<p>Дан отрезок из <span class="math">\(n\)</span> чисел от 1 до <span class="math">\(n\)</span>. Требуется ответить на <span class="math">\(q\)</span> запросов <span class="math">\(k\)</span>-той порядковой статистики на подотрезке.</p>
</blockquote>
<p>Сделаем такой стандартный препроцессинг: пройдёмся с персистентным деревом отрезков для суммы по массиву. Когда будем обрабатывать элемент <span class="math">\(k\)</span>, добавим единицу к <span class="math">\(k\)</span>-ому элементу.</p>
<p>Дальше определим <em>разность деревьев</em> как дерево отрезков, которое соответствует разности массивов. Заметим, что он неотрицательный. Его можно получить неявно, спускаясь одновременно в двух ДО и вместо <code>sum</code> использовать везде <code>sum_r</code> - <code>sum_l</code>.</p>
<p>Что будет находиться в разности <span class="math">\(r\)</span>-го и <span class="math">\(l\)</span>-го дерева? Там будут количества вхождений чисел на этом отрезке. В таком ДО не составить труда сделать спуск, который находит последнюю позицию, у которой сумма на соответствующем префиксе не превышает <span class="math">\(k\)</span> — она и будет ответом.</p>
<blockquote>
<p>Дан массив из <span class="math">\(n\)</span> элементов. Требуется ответить на <span class="math">\(m\)</span> запросов, есть ли на отрезке <span class="math">\([l, r]\)</span> доминирующий элемент — тот, который встречается на нём хотя бы <span class="math">\(\frac{r-l}{2}\)</span> раз.</p>
</blockquote>
<p>У этой задачи есть удивительно простое решение — взять около 100 случайных элементов и каждый проверить, является ли он доминирующим (это можно проверить за <span class="math">\(O(\log n)\)</span>, посчитав для каждого значения отсортированный список позиций, на которых он встречается, и сделав два бинпоиска). Вероятность ошибки в худшем случае равна <span class="math">\(\frac{1}{2^{100}}\)</span>, и ей на практике можно пренебречь.</p>
<p>Но проверять 100 сэмплов — долго. Можно построить такое же ДО, как в прошлой задаче, и решать задачу «найти число, большее <span class="math">\(\frac{n}{2}\)</span> в массиве на <span class="math">\(n\)</span> элементов». Это тоже будет спуском по ДО: каждый раз идём в того сына, где сумма больше. Если в листе, куда мы пришли, значение больше нужного, возврашаем <code>true</code>, иначе <code>false</code>.</p>
<h2 id="другие-реализации">Другие реализации</h2>
<p>Эта реализация проста и легко расширяема, но весьма медленная и неэффективная по памяти. Есть альтернативы:</p>
<p><strong>На массивах</strong>. Можно ввести несложную нумерацию вершин, позволяющую при спуске в ребёнка пересчитывать его номер. Это позволит не хранить границы текущего отрезка. Подробнее у <a href="http://e-maxx.ru/algo/segment_tree">Емакса</a>.</p>
<p><strong>«ДО снизу»</strong>. Можно делать все операции итеративно — так получится раз в 7 быстрее, но писать что-либо нетривиальное (например, массовые операции) так будет намного труднее. Подробнее смотрите в одном посте с <a href="https://codeforces.com/blog/entry/18051">CodeForces</a>.</p>
<h2 id="задачи">Задачи</h2>
<ul>
<li><a href="https://informatics.msk.ru/mod/statements/view3.php?id=33853&amp;chapterid=752#1">Первый контест</a> — на базовые операции.</li>
<li>Второй контест — на отложенные операции.</li>
<li><a href="https://codeforces.com/group/g92L0id9Yb/contest/228565">Дополнительный контест</a> — на динамическое построение и персистентность.</li>
</ul>
</body>
</html>
