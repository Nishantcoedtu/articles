
# Наименьший общий предок

**Деревом** называется связный граф из $n-1$ рёбер и $n$ вершин. Дерево называется **корневым**, если оно ориентированно, и из какой-то (единственной) вершины можно попасть во все остальные — такая вершина называется корнем.

Примеры корневых деревьев: наследование классов в языках программирования (если множественное наследование запрещено), иерархия в какой-нибудь компании.

У каждой вершины, кроме корня, есть ровно один родитель, поэтому очень часто дерево представляют в виде списка родителей для каждой вершины.

Для очень многих задач на деревья требуется находить наименьшего общего предка. Эта задача называется LCA (англ. Least Common Ancestor). Мы рассмотрим два способа, как это делать в онлайн.

Тривиально (за линию на каждый запрос) это делается так:


```
int p[maxn];
vector<int> g[maxn];
int tin[maxn], tout[maxn];
int t = 0;

void dfs (int v) {
    tin[v] = t++;
    for (int u : g[v])
        dfs(u);
    tout[v] = t++;
}

bool ancestor (int v, int u) {
    return tin[v] <= tin[u] && tin[u] <= tout[v];
}

int lca (int a, int b) {
    while (!ancestor(a, b))
        a = p[a];
    return a;
}
```

# Двоичные подъемы


```
// помимо массивов и функций из предыдущего примера
int up[maxn][logn];

void dfs (int v) {
    for (int l = 1; l < logn; l++)
        up[v][l] = up[up[v][l-1]][l-1];
    tin[v] = t++;
    for (int u : g[v]) {
        up[u][0] = v;
        dfs(u);
    }
    tout[v] = t++;
}

int lca (int v, int u) {
    if (a(v, u)) return v;
    if (a(u, v)) return u;
    for (int l = logn-1; l >= 0; l--)
        if (!ancestor(up[v][l], u))
            v = up[v][l];
    return up[v][0];
}
```

# Сведение к RMQ

Другая идея — это пройтись dfs-ом и выписать два массива: глубины вершин и их номера.

Теперь, у нас есть запрос: найти LCA от вершин $a$ и $b$. Пусть мы посетили $a$ первой, тогда посмотрим на момент, когда мы из нее вышли и на момент, когда впервые вошли в $b$. Где-то по пути мы должны были прийти в наименьший общий предок, потому что путь от $a$ до $b$ в дереве единственный. Где-то на этом массиве выписанных глубин и будет LCA — на той позиции, где глубина минимальная. 

Получается, что можно свести задачу к RMQ на массиве глубин — для этого можно задействавать какую-нибудь структуру, например ДО.

# Разреженная таблица

Помимо, ДО есть более крутая структура, позволяющая отвечать на запрос минимума за O(1). Подробнее в соответствующей статье.


```

```

Примечание и интересное размышление: LCA сводится к RMQ, но не наоборот. На самом деле, существует алгоритм, и даже несколько, которые решают LCA быстрее, чем за $O(\log n)$ на запрос. Но из этого не следует, что можно с такой же асимптотикой решать RMQ. Подробнее смотрите алгоритм Фараха-Колтона-Бендера. У него линейная асимптотика, но очень плохая константа, поэтому на контестах писать его не надо. Это так, для общего образования.
