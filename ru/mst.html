<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Минимальные остовы</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" href="../favicon.ico" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<div id="header">
<h1 class="title">Минимальные остовы</h1>
</div>
<h1 id="минимальные-остовы">Минимальные остовы</h1>
<blockquote>
<p>Авиакомпания содержит <span class="math inline">\(m\)</span> рейсов между <span class="math inline">\(n\)</span> городами, <span class="math inline">\(i\)</span>-ый из них обходится в <span class="math inline">\(w_i\)</span> рублей, причём из любого города можно добраться до любого другого. В стране наступил кризис, и нужно отказаться от как можно большего числа из них таким образом, что содержание оставшиъся рейсов будет наиболее дешевым.</p>
</blockquote>
<p>Иными словами, нужно найти дерево минимального веса, которое является подграфом данного неориентированного графа. Такие деревья называют <em>остовами</em> (<em>каркас</em>, <em>скелет</em>; ударение на первый слог, но так мало кто произносит). По-английски — <em>minimum spanning tree</em> (дословно, минимальное покрывающее дерево).</p>
<p>Почему дерево? Потому в противном случае там был бы цикл из которго можно удалить какое-то ребро и получить ответ пооптимальней. А если это больше, чем одно дерево, то какие-то две вершины остаются несвязаны.</p>
<p>Вообще, следующие утверждения про деревья являются эквивалентными: * Граф — дерево. * В графе из <span class="math inline">\(n\)</span> вершин <span class="math inline">\(n-1\)</span> рёбер и нет циклов. * Из любой вершины можно дойти в любоую другую единственным образом.</p>
<h2 id="лемма-о-безопасном-ребре">Лемма о безопасном ребре</h2>
<p>Назовем подграф <span class="math inline">\(T\)</span> графа <span class="math inline">\(G\)</span> безопасным, если они является подграфом какого-то минимального остова.</p>
<p>Назовем ребро безопасным, если при добавлении его в подграф <span class="math inline">\(T\)</span> получившийся граф <span class="math inline">\(T&#39;\)</span> тоже является безопасным, то есть подграфом какого-то минимального остова.</p>
<p>Все алгоритмы для поиска минимального остова опираются на следующее утверждение:</p>
<blockquote>
<p>Рассмотрим произвольный разрез (удалили некоторые рёбра так, что граф распался на две части) какого-то подграфа минимального остова. Тогда ребро минимального веса, пересекающее этот разрез (то есть соединяющее их при добавлении) является безопасным.</p>
</blockquote>
<p><strong>Доказательство</strong>: Рассмотрим какой-то минимальный остов, в котором этого ребра нет. Если его добавить то образуется цикл, из которого можно выкинуть ребро не меньшего веса, получив ответ точно не хуже.</p>
<div class="figure">
<img src="https://neerc.ifmo.ru/wiki/images/thumb/8/81/%D0%9B%D0%B5%D0%BC%D0%BC%D0%B0_%D0%BE_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D0%BC_%D1%80%D0%B5%D0%B1%D1%80%D0%B5.png/300px-%D0%9B%D0%B5%D0%BC%D0%BC%D0%B0_%D0%BE_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D0%BC_%D1%80%D0%B5%D0%B1%D1%80%D0%B5.png" alt="safe" />
<p class="caption">safe</p>
</div>
<p>Получается, что мы можем действовать жадно — на каждом шаге добавлять ребро минимального веса, которое увеличивает наш остов.</p>
<h1 id="алгоритм-прима">Алгоритм Прима</h1>
<p>Минимальный остов строится постепенно, добавлением в него рёбер по одному.</p>
<ul>
<li>Изначально остов — одна произвольная вершина.</li>
<li>Пока минимальный остов не найден, выбирается ребро минимального веса, исходящее из вершины текущего остова в вершину, которую мы ещё не добавили. Добавляем это ребро в остов и начинаем заново, пока остов не будет найден.</li>
</ul>
<p>Очень похоже на алгоритм Дейкстры, только мы выбираем следующую вершину с другой весовой функцией — вес соединяющего ребра вместо суммарного расстояния до неё.</p>
<p>Совсем наивная реализация за <span class="math inline">\(O(nm)\)</span> — каждый раз перебираем все рёбра:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">const <span class="bu">int</span> maxn <span class="op">=</span> <span class="fl">1e5</span>, inf <span class="op">=</span> <span class="fl">1e9</span><span class="op">;</span>
vector<span class="op">&lt;</span><span class="bu">int</span><span class="op">&gt;</span> <span class="im">from</span>, to, weight<span class="op">;</span>
<span class="bu">bool</span> used[maxn]

<span class="op">//</span> считать все рёбра в массивы

used[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
<span class="cf">for</span> (<span class="bu">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="dv">-1</span><span class="op">;</span> i<span class="op">++</span>) {
    <span class="bu">int</span> opt_w <span class="op">=</span> inf, opt_from, opt_to<span class="op">;</span>
    <span class="cf">for</span> (<span class="bu">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++</span>)
        <span class="cf">if</span> (opt_w <span class="op">&gt;</span> weight[j] <span class="op">&amp;&amp;</span> used[<span class="im">from</span>[j]] <span class="op">&amp;&amp;</span> <span class="op">!</span>used[to[j]])
            opt_w <span class="op">=</span> weight[j], opt_from <span class="op">=</span> <span class="im">from</span>[j], opt_to <span class="op">=</span> to[j]
    used[opt_to] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
    cout <span class="op">&lt;&lt;</span> opt_from <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> opt_to <span class="op">&lt;&lt;</span> endl<span class="op">;</span>
}</code></pre></div>
<p>Реализация за <span class="math inline">\(O(n^2)\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">const <span class="bu">int</span> maxn <span class="op">=</span> <span class="fl">1e5</span>, inf <span class="op">=</span> <span class="fl">1e9</span><span class="op">;</span>
<span class="bu">bool</span> used[maxn]<span class="op">;</span>
vector<span class="op">&lt;</span> pair<span class="op">&lt;</span><span class="bu">int</span>, <span class="bu">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> g[maxn]<span class="op">;</span>
<span class="bu">int</span> min_edge[maxn] <span class="op">=</span> {inf}, best_edge[maxn]<span class="op">;</span>
min_edge[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>

<span class="op">//</span> ...

<span class="cf">for</span> (<span class="bu">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span>) {
    <span class="bu">int</span> v <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>
    <span class="cf">for</span> (<span class="bu">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> u <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++</span>)
        <span class="cf">if</span> (<span class="op">!</span>used[u] <span class="op">&amp;&amp;</span> (v <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> min_edge[u] <span class="op">&lt;</span> min_edge[v]))
            v <span class="op">=</span> u<span class="op">;</span>
 
    used[v] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
    <span class="cf">if</span> (v <span class="op">!=</span> <span class="dv">0</span>)
        cout <span class="op">&lt;&lt;</span> v <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> best_edge[v] <span class="op">&lt;&lt;</span> endl<span class="op">;</span>
 
    <span class="cf">for</span> (auto e : g[v]) {
        <span class="bu">int</span> u <span class="op">=</span> e.first, w <span class="op">=</span> e.second<span class="op">;</span>
        <span class="cf">if</span> (w <span class="op">&lt;</span> min_edge[u]) {
            min_edge[u] <span class="op">=</span> w<span class="op">;</span>
            best_edge[u] <span class="op">=</span> v<span class="op">;</span>
        }
    }
}</code></pre></div>
<p>Можно не делать линейный поиск оптимальной вершины, а поддерживать его в приоритетной очереди, как в алгоритме Дейкстры. Получается реализация за <span class="math inline">\(O(m \log n)\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">set</span><span class="op">&lt;</span> pair<span class="op">&lt;</span><span class="bu">int</span>, <span class="bu">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> q<span class="op">;</span>
<span class="bu">int</span> d[maxn]<span class="op">;</span>

<span class="cf">while</span> (q.size()) {
    v <span class="op">=</span> q.begin()<span class="op">-&gt;</span>second<span class="op">;</span>
    q.erase(q.begin())<span class="op">;</span>
 
    <span class="cf">for</span> (auto e : g[v]) {
        <span class="bu">int</span> u <span class="op">=</span> e.first, w <span class="op">=</span> e.second<span class="op">;</span>
        <span class="cf">if</span> (w <span class="op">&lt;</span> d[u]) {
            q.erase({d[u], u})<span class="op">;</span>
            d[u] <span class="op">=</span> w<span class="op">;</span>
            q.insert({d[u], u})<span class="op">;</span>
        }
    }
}</code></pre></div>
<p>Про алгоритм за <span class="math inline">\(O(n^2)\)</span> забывать не стоит — он работает лучше в случае плотных графов.</p>
<h1 id="алгоритм-крускала">Алгоритм Крускала</h1>
<p>Будем добавлять рёбра в порядке возрастания их весов. Если ребро соединяет какие-то две уже соединенные вершины, то проигнорируем его, иначе оно является безопасным, и его можно добавить.</p>
<p>Звучит очень просто — отсортировать все рёбра, пройтись по ним циклом и делать проверку, что вершины в разных компонентах. Однако для этой проверки нам нужна будет целая отдельная структура.</p>
<h1 id="система-непересекающихся-множеств">Система непересекающихся множеств</h1>
<p>Эта структура данных предоставляет следующие возможности. Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве. Структура поддерживает две операции: * объединить два каких-либо множества * запросить, в каком множестве сейчас находится указанный элемент</p>
<p>Обе операции будут выполняться в среднем почти за <span class="math inline">\(O(1)\)</span> (но не совсем — этот сложный вопрос будет разъяснен позже).</p>
<p>Множества элементов мы будем хранить в виде деревьев: одно дерево соответствует одному множеству. Корень дерева — это представитель (лидер) множества. Заведём массив <code>_p</code>, в котором для каждого элемента мы храним номер его предка в дерева. Для корней деревьев будем считать, что их предок — они сами.</p>
<p>Наивная реализация, которую мы потом ускорим:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">int</span> _p[maxn]<span class="op">;</span>

<span class="bu">int</span> p (<span class="bu">int</span> v) {
    <span class="cf">if</span> (_p[v] <span class="op">==</span> v)
        <span class="cf">return</span> v<span class="op">;</span>
    <span class="cf">else</span>
        <span class="cf">return</span> p(_p[v])<span class="op">;</span>
}

void unite (<span class="bu">int</span> a, <span class="bu">int</span> b) {
    a <span class="op">=</span> p(a), b <span class="op">=</span> p(b)<span class="op">;</span>
    _p[a] <span class="op">=</span> b<span class="op">;</span>
}

<span class="cf">for</span> (<span class="bu">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span>)
    _p[i] <span class="op">=</span> i<span class="op">;</span></code></pre></div>
<p><strong>Эвристика сжатия пути</strong>. Оптимизируем работу функции <code>p</code>. Давайте перед тем, как вернуть ответ, запишем его в <code>_p</code> от текущей вершины, то есть переподвесим его за самую высокую.</p>
<p>Насколько лучше это сделает асимптотику? Выясняется, что <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Тут должен быть мем из опросов.</p>
<p><strong>Ранговая эвристика</strong>. Эта штука напрямую пытается минимизировать высоту дерева. Давайте делать переподвешивание за то, которое менее глубоко. Ну понятно, что тогда любое дерево будет не более логарифма.</p>
<p><strong>Весовая эвристика</strong>. Давайте каждый раз подвешивать за более крупное. Работать будет быстро, так как .</p>
<p>Автор предпочитает именно её, потому что часто эти размеры компонент требуются сами по себе.</p>
<p>Оказывается, что сжатия + ранговая или сжатия + весовая работает быстро.</p>
<p>Асимптотика объединения обеих эвристик (сжатия путей и одной из ранговых) — O(a(n)), где a(n) — обратная функция Аккермана (очень медленно растущая функция, для всех адекватных чисел не превосходящая 4). Тратить время на изучения доказательства или даже чтения статьи на Википедии про функцию Аккермана автор не рекомендует.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">int</span> _p[maxn], s[maxn]<span class="op">;</span>

<span class="bu">int</span> p (<span class="bu">int</span> v) { <span class="cf">return</span> (_p[v] <span class="op">==</span> v) ? v : _p[v] <span class="op">=</span> p(_p[v])<span class="op">;</span> }

void unite (<span class="bu">int</span> a, <span class="bu">int</span> b) {
    a <span class="op">=</span> p(a), b <span class="op">=</span> p(b)<span class="op">;</span>
    <span class="cf">if</span> (s[a] <span class="op">&gt;</span> s[b]) swap(a, b)<span class="op">;</span>
    s[b] <span class="op">+=</span> s[a]<span class="op">;</span>
    _p[a] <span class="op">=</span> b<span class="op">;</span>
}

<span class="cf">for</span> (<span class="bu">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++</span>)
    _p[i] <span class="op">=</span> i<span class="op">;</span></code></pre></div>
<h2 id="полезные-свойства-и-классические-задачи">Полезные свойства и классические задачи</h2>
<ul>
<li>Если веса всех рёбер различны, то остов будет уникален.</li>
<li>Минимальный остов является также и остовом с минимальным произведением весов рёбер (замените веса всех рёбер на их логарифмы)</li>
<li>Минимальный остов является также и остовом с минимальным весом самого тяжелого ребра.</li>
<li>Если вы решаете задачу, где ребра не добавляются, а удаляются, то можно попробовать решать задачу «с конца» и применить алгоритм Крускала.</li>
</ul>
<h2 id="персистентная-снм">Персистентная СНМ*</h2>
<p>Как вы уже заметили, автор очень любит персистентные структуры данных.</p>
<p>СНМ — тоже структура, и её тоже можно сделать персистентной. В СНМ мы изменяем массивы, а массивы можно сделать персистентными через персистентное ДО (только так, проще не получается — многие пытались).</p>
<p>Здесь есть нюанс — амортизированные структуры не очень хорошо дружат с персистентностью. Поэтому нам придется отказаться от эвристики сжатия путей, и поэтому асимптотика составит <span class="math inline">\(O(n \log^2 n)\)</span> времени и памяти — один логарифм от СНМа, другой от персистентного ДО.</p>
<h2 id="динамическая-связность">Динамическая связность*</h2>
<p><em>Dynamic Connectivity Problem:</em></p>
<blockquote>
<p>Даны <span class="math inline">\(n\)</span> запросов добавления ребра (<code>+</code>), удаления ребра (<code>-</code> и какого-то запроса про граф (<code>?</code>), например, о связности двух вершин.</p>
</blockquote>
<p>О решении этой задачи в online и в offline можете почитать в <a href="https://codeforces.com/blog/entry/15296">этом посте</a>.</p>
</body>
</html>
