<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Выпуклые оболочки - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/convex-hulls.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/convex-hulls.md'>История</a>
    </div>
</div>
<h1 id="выпуклые-оболочки">Выпуклые оболочки</h1>
<p><strong>Выпуклое множество</strong> — такое множество точек, что, для любых двух точек множества, все точки на отрезке между ними тоже принадлежат этому множеству.</p>
<p><strong>Выпуклая оболочка</strong> множества точек — такое выпуклое множество точек, что все точки фигуры также лежат в нем.</p>
<p><strong>Минимальная выпуклая оболочка</strong> множества точек — это минимальная по площади выпуклая оболочка.</p>
<p>Для экономии времени дальше минимальные выпуклые оболочки мы будем называть просто выпуклыми оболочками.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/de/ConvexHull.svg/220px-ConvexHull.svg.png" /></p>
<p>Для практических целей выпуклые оболочки полезны тем, что они компактно хранят всю необходимую информацию о множестве точек, что позволяет быстро отвечать на разнообразные запросы на этом множестве.</p>
<p>Выпуклые оболочки можно рассматривать в любом пространстве, но в этой статье мы ограничимся двумерным и научимся их эффективно строить по какому-то множеству из <span class="math inline">\(n\)</span> точек на плоскости.</p>
<h2 id="алгоритм-джарвиса">Алгоритм Джарвиса</h2>
<p>Выберем какую-нибудь точку <span class="math inline">\(p_0\)</span>, которая гарантированно попадёт в выпуклую оболочку. Например, нижнюю, а если таких несколько, то самую левую из них.</p>
<p>Дальше будем действовать так: найдём самую «правую» точку от последней добавленной (то есть точку с минимальным полярным углом) и добавим её в оболочку. Будем так итеративно добавлять точки, пока не «замкнёмся», то есть пока самой правой точкой не станет <span class="math inline">\(p_0\)</span>.</p>
<p><img src="http://neerc.ifmo.ru/wiki/images/b/b3/Graham1.png" /></p>
<p>Корректность алгоритма легко доказывается по индукции:</p>
<ul>
<li><p>На первом шаге мы выбрали точку, точно лежащую в МВО.</p></li>
<li><p>На <span class="math inline">\(i\)</span>-м шаге мы взяли такую точку, что все остальные лежат по «правильную» сторону отрезка <span class="math inline">\((p_i, p_{i+1})\)</span>.</p></li>
</ul>
<p>Алгоритм Джарвиса также называют алгоритмом заворачивания подарка: мы каждый раз находим самый близкий «угол».</p>
<p>Для каждой точки выпуклой оболочки (обозначим их количество за <span class="math inline">\(h\)</span>) мы из всех оставшихся <span class="math inline">\(O(n)\)</span> точек будем искать оптимальную, что суммарно будет работать за <span class="math inline">\(O(n h)\)</span>.</p>
<p>В реализации будем пользоваться тем же классом для точки, что и в <a href="geometry">статье про вычислительную геометрию</a>. Для краткости, будем считать, что все точки различны, имеют целочисленные координаты, а также что нет трёх точек на одной прямой.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">vector&lt;r&gt; jarvis_convex_hull(vector&lt;r&gt; points) {</a>
<a class="sourceLine" id="cb1-2" title="2">    r p0 = points[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">for</span> (r p : points)</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="cf">if</span> (p.x &lt; p0.x || (p.x == p0.x &amp;&amp; p.y &lt; p0.y))</a>
<a class="sourceLine" id="cb1-5" title="5">        p0 = p;</a>
<a class="sourceLine" id="cb1-6" title="6">    vector&lt;r&gt; hull = {p0};</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="cf">while</span> (<span class="kw">true</span>) {</a>
<a class="sourceLine" id="cb1-8" title="8">        r t = p0; <span class="co">// кандидат на следующую точку</span></a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="cf">for</span> (r p : points)</a>
<a class="sourceLine" id="cb1-10" title="10">            <span class="co">// лучше никакие полярные углы не считать</span></a>
<a class="sourceLine" id="cb1-11" title="11">            <span class="cf">if</span> ((p - p0) ^ (t - p0) &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-12" title="12">                t = p;</a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="cf">if</span> (t == p0)</a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb1-15" title="15">        <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-16" title="16">            p0 = t;</a>
<a class="sourceLine" id="cb1-17" title="17">            hull.push_back(t);</a>
<a class="sourceLine" id="cb1-18" title="18">        }</a>
<a class="sourceLine" id="cb1-19" title="19">    }</a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="cf">return</span> hull;</a>
<a class="sourceLine" id="cb1-21" title="21">}</a></code></pre></div>
<p>Важно помнить, что асимптотика именно <span class="math inline">\(O(nh)\)</span>, а не <span class="math inline">\(O(n^2)\)</span>: существуют задачи, где оболочка маленькая, и это существенно.</p>
<h2 id="алгоритм-грэхема">Алгоритм Грэхема</h2>
<p>Алгоритм Грэхема — это оптимизация алгоритма Джарвиса, основанная на следующем наблюдении: если отсортировать все точки по полярному углу относительно точки <span class="math inline">\(p_0\)</span>, то выпуклая оболочка будет какой-то подпоследовательностью такого отсортированного массива точек.</p>
<p>Алгоритм последовательно строит выпуклые оболочки для каждого префикса этого отсортированного масива. При добавлении <span class="math inline">\(i\)</span>-й точки в оболочку нужно удалить сколько-то последних добавленных точек, которые не будут входить в новую оболочку. Чтобы это делать эффективно, мы можем хранить выпуклую оболочку в стеке и в цикле <code>while</code> смотреть на три последние точки и проверять, образуют ли они правый поворот. Если это так, то среднюю следует удалить — мы нашли треугольник <span class="math inline">\((p_0, p_i, p_{i-2})\)</span>, который содержит <span class="math inline">\(p_{i-1}\)</span>, значит её можно удалить.</p>
<figure>
<img src="https://cdn.turkaramamotoru.com/ru/algoritm-grehema-4131.jpg" alt="alt text" /><figcaption>alt text</figcaption>
</figure>
<p>Каждая точка будет добавлена один раз удалена не более одного раза, что занимает константное количество операций. Соответственно, время работы будет упираться во время работы сортировки, то есть <span class="math inline">\(O(n \log n)\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">vector&lt;r&gt; graham_convex_hull(vector&lt;r&gt; points) {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">// находим p0, как и раньше</span></a>
<a class="sourceLine" id="cb2-3" title="3">    r p0 = points[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="cf">for</span> (r p : points)</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="cf">if</span> (p.x &lt; p0.x || (p.x == p0.x &amp;&amp; p.y &lt; p0.y))</a>
<a class="sourceLine" id="cb2-6" title="6">            p0 = p;</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="co">// </span><span class="al">TODO</span><span class="co">: удалить p0</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="co">// сортируем точки по полярному углу</span></a>
<a class="sourceLine" id="cb2-11" title="11">    sort(points.begin(), points.end(), [&amp;](r a, r b){</a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="cf">return</span> (a - p0) ^ (b - p0) &gt; <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb2-13" title="13">    });</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15">    vector&lt;r&gt; s = {p0};</a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="cf">for</span> (r p : points) {</a>
<a class="sourceLine" id="cb2-17" title="17">        <span class="cf">while</span> (...) {</a>
<a class="sourceLine" id="cb2-18" title="18">             s[s.size()-<span class="dv">2</span>] = s[s.size()-<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb2-19" title="19">             s.pop_back();            </a>
<a class="sourceLine" id="cb2-20" title="20">        }</a>
<a class="sourceLine" id="cb2-21" title="21">        s.push_back(p);</a>
<a class="sourceLine" id="cb2-22" title="22">    }</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="cf">return</span> s;</a>
<a class="sourceLine" id="cb2-25" title="25">}</a></code></pre></div>
<h2 id="верхние-и-нижние-огибающие">Верхние и нижние огибающие</h2>
<p>Для весьма большого количества применений нам на самом деле нужны не выпуклые оболочки, а только их половины (правые и левые или верхние и нижние), которые называют <em>огибающими</em> (англ. <em>envelope</em>).</p>
<p>Огибающие строить немного проще: можно отсортировать точки по <span class="math inline">\(x\)</span> и пройтись по ним в таком порядке, поддерживая на стеке верхнюю огибающую для текущего префикса. При добавлении очередной точки нам нужно аналогичным образом проверить и удалить сколько-то верхних точек на стеке:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">vector&lt;r&gt; upper_envelope(vector&lt;r&gt; points) {</a>
<a class="sourceLine" id="cb3-2" title="2">    sort(points.begin(), points.end(), [](r a, r b){</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="cf">return</span> a.x &lt; b.x;</a>
<a class="sourceLine" id="cb3-4" title="4">    });</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    vector&lt;r&gt; s = {p0};</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="cf">for</span> (r p : points) {</a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="cf">while</span> (...) {</a>
<a class="sourceLine" id="cb3-9" title="9">            s[s.size()-<span class="dv">2</span>] = s[s.size()-<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb3-10" title="10">            s.pop_back();</a>
<a class="sourceLine" id="cb3-11" title="11">        }</a>
<a class="sourceLine" id="cb3-12" title="12">        s.push_back(p);</a>
<a class="sourceLine" id="cb3-13" title="13">    }</a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="cf">return</span> s;</a>
<a class="sourceLine" id="cb3-16" title="16">}</a></code></pre></div>
<p>С огибающими работать легче, чем с целыми оболочками: их легко пересекать, объединять и делать бинпоиск (например, чтобы находить касательные). Кстати, объединение можно производить за линейное время (пройдясь двумя указателями по обеим оболочкам одновременно), что позволяет альтернативно строить огибающую методом «разделяй и властвуй», тоже за <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Иногда имеет смысл разбить оболочку на две огибающие и работать с ними. Основном минус такого подхода: нужно либо писать в два раза больше кода, либо писать его так, чтобы внутренние процедуры не отличали выше от ниже — тогда точки нижней огибающей можно передовать в те же рутины, что и для верхней, заменив <span class="math inline">\(y_i\)</span> на <span class="math inline">\(-y_i\)</span>.</p>
<h3 id="алгоритм-эндрю">Алгоритм Эндрю</h3>
<p>Для построения выпуклой оболочки можно поступить следующим образом: построить верхнюю огибающую, построить нижнюю огибающую, а затем просто объединить их списки.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">vector&lt;r&gt; andrew_convex_hull(vector&lt;r&gt; points) {</a>
<a class="sourceLine" id="cb4-2" title="2">    vector&lt;r&gt; lower = <span class="co">// ...</span></a>
<a class="sourceLine" id="cb4-3" title="3">    vector&lt;r&gt; upper = <span class="co">// ...</span></a>
<a class="sourceLine" id="cb4-4" title="4">    vector&lt;r&gt; hull = <span class="co">// </span><span class="al">TODO</span><span class="co">     </span></a>
<a class="sourceLine" id="cb4-5" title="5">}</a></code></pre></div>
<h3 id="динамические-выпуклые-оболочки">Динамические выпуклые оболочки</h3>
<p>Оперируя с оболочкой как с двумя огибающими, можно относительно просто обрабатывать запросы добавления точек, обернув огибающие, например, в <code>std::set</code> так, что они оказываются отсортированными по <span class="math inline">\(x\)</span>. При добавлении точки нужно просто найти её позицию в дереве и проверить и, возможно, удалить сколько-то её левых и правых соседей.</p>
<p>Обрабатывать <em>удаление</em> точки из множества сложнее. Если запросы известны заранее, то проще воспользоваться идеями <a href="sqrt">корневой эвристики</a> или dynamic connectivity problem и поддерживать только те точки, которые существуют на всем текущем блоке, и сводить удаление к добавлению.</p>
<p>Если же запросы удаления требуется обрабатывать онлайн (fully dynamic convex hull), то для этого есть <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%B2%D1%8B%D0%BF%D1%83%D0%BA%D0%BB%D0%B0%D1%8F_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D1%87%D0%BA%D0%B0_%28%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D1%87%D0%BD%D0%BE_log%5E2_%D0%BD%D0%B0_%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5/%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20">очень неприятный алгоритм</a> на 250-300 строк кода, заключающийся в поддержании огибающих для всех поддеревьев в этом дереве поиска и быстром объединении огибающих при перестроении дерева. Алгоритм работает за <span class="math inline">\(O(\log^2 n)\)</span> на запрос: при слиянии огибающих при объединении вершин используется бинпоиск с разбором кучи случаев.</p>
<h2 id="алгоритм-чана">Алгоритм Чана</h2>
<p>Как уже упоминалось ранее, иногда существенную роль играет то, что алгоритм Джарвиса работает за <span class="math inline">\(O(nh)\)</span>, а не <span class="math inline">\(O(n^2)\)</span>, то есть когда точек немного, он лучше алгоритмов Грэхэма и Эрдрю.</p>
<p>Алгоритм Чана пытается получить лучшее из двух и объединенить алгоритмы Джарвиса и Грэхэма (или Эндрю), чтобы получить асимптотику <span class="math inline">\(O(n \log h)\)</span>.</p>
<p><strong>Алгоритм.</strong> Разделим все точки на группы по <span class="math inline">\(m\)</span> точек. В каждой группе построим выпуклую оболочку за <span class="math inline">\(O(m \log m)\)</span> алгоритмом Грэхэма. Точки никак не упорядочены, и эти оболочки могут пересекаться — это нормально. Суммарно для всех групп понадобится <span class="math inline">\(O(n \log m)\)</span> операций.</p>
<p>Затем, начиная с самой левой нижей точки, мы будем строить общую выпуклую обочку аналогично алгоритму Джарвиса, но теперь «самую правую точку» можно находить каждый раз не за <span class="math inline">\(O(n)\)</span>, а за <span class="math inline">\(O(\frac{n}{m} \log m)\)</span>, если делать бинарный поиск в каждой из <span class="math inline">\(\frac{n}{m}\)</span> оболочек.</p>
<p>Получается, что такое решение будет работать за <span class="math inline">\(O(h \frac{n}{m} \log m + n \log m)\)</span>. Если заранее приблизительно знать <span class="math inline">\(h\)</span>, то можно положить <span class="math inline">\(m = h\)</span>, и тогда асимптотика составит <span class="math inline">\(O(n \log h)\)</span>.</p>
<p>Понятно, что ни при каких применимых на практике ограничениях, даже если оболочка состоит из трёх точек, этот алгоритм не будет быстрее обычного алгоритма Грэхэма, так что автор не будет приводить его реализацию. Этот способ просто интересен с теоретической точки зрения.</p>
<p><strong>Упражнение.</strong> Придумайте, как при неизвестном <span class="math inline">\(h\)</span> подбирать <span class="math inline">\(m\)</span> так, чтобы асимптотика оставалась <span class="math inline">\(O(n \log h)\)</span>.</p>
<h2 id="пересечение-полуплоскостей">Пересечение полуплоскостей</h2>
<p>Очень похожей задачей является пересечение полуплоскостей (англ. <em>half-plane intersection</em>). Требуется найти множество, удовлетворяющее набору неравенств:</p>
<p><span class="math display">\[
a_i x + b_i y + c \geq 0
\]</span></p>
<p>Например, через сведение к пересечению полуплоскостей можно (не самым оптимальным образом) строить подобные клёвые картинки:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Coloured_Voronoi_2D.svg/220px-Coloured_Voronoi_2D.svg.png" /></p>
<p>Это <em>диаграмма Вороного</em> — для каждой точки выделено множество точек плоскости, которые являются к ней ближайшими. Чтобы построить это множество для данной точки <span class="math inline">\(p_i\)</span>, можно перебрать все осталньные точки <span class="math inline">\(p_j\)</span>, посчитать коэффициенты прямой, которая делит плоскость между ними пополам, и пересечь все ориентированные в нужную сторону полуплоскости, соответствующие этим прямым.</p>
<p>Результатом пересечения множества полуплоскостей тоже будет выпуклая оболочка — полуплоскость это выпуклое множество, а пересечение любых выпуклых множеств тоже выпуклое. Возможно, эта оболочка будет бесконечной по каким-то направлениям. Чтобы не обрабатывать это отдельно, часто добавляют <em>bounding box</em> — «коробку» из четырёх полуплоскостей на большом удалении.</p>
<p>Один из способов построения — построить отдельно верхнюю и нижнюю огибающую и пересечь. Для этого нужно разделить все полуплоскости на «смотрящие вверх» и «смотрящие вниз», для обеих групп отсортировать их по углу вектора нормали и пройтись по ним со стеком, удаляя «ненужные» полуплоскости — те, которые полностью покрываются новой и предпоследней полуплоскостью в стеке.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// </span><span class="al">TODO</span><span class="co">: я не хочу это кодить</span></a></code></pre></div>
<p>Алгоритм почти совпадает с алгоритмом алгоритмом Грэхэма и тоже имеет асимптотику <span class="math inline">\(O(n \log n)\)</span>. На самом деле, разделять полуплоскости на верхние и нижние и потом объединять не требуется — можно пройтись таким же образом по сортированному набору полуплоскостей два раза, и какой-то подотрезок получившегося стека будет нужным ответом. Автор не в состоянии внятно объяснять, почему.</p>
<h3 id="нахождение-касательной">Нахождение касательной</h3>
<p>В некоторых задачах нам на самом деле не нужно явно находить пересечение, а достаточно лишь определить, пустое оно или нет. В <a href="https://petr-mitrichev.blogspot.com/2016/07/a-half-plane-week.html">блоге Петра Митричева</a> описан простой алгоритм, позволяющий это делать за линейное время.</p>
<ul>
<li><p>Если это так, то она останется той же, и ничего дальше считать не надо.</p></li>
<li><p>Если это не так, то новая точка должна лежать на пересечении новой полуплоскости и какой-то из старых. Важный факт здесь в том, что она лежит на границе новой полуплоскости. Чтобы её найти, пересечём все старые полуплоскости с этой границей и решим одномерную задачу пересечения множества интервалов, бесконечных в одну из сторон. Если получившийся интервал пуст, то и пересечение полуплоскостей пустое, а в противном случае один из его концов будет искомой точкой, если его положить обратно на границу новой полуплоскости.</p></li>
</ul>
<p>Теперь интересная часть — асимптотика. Казалось бы, такой алгоритм в худшем случае может работать за квадратичное время — мы могли каждый раз на <span class="math inline">\(k\)</span>-том шаге пересекать все имеющиеся полуплоскости с новой за <span class="math inline">\(O(k)\)</span>.</p>
<p>Выясняется, что за счёт рандомизированности нам нужно выполнять это пересечение не так уж и часто. В случайном множестве из <span class="math inline">\(k\)</span> полуплоскостей только две из них дают в пересечении оптимальную точку. Из этого следует, что вероятность того, что <span class="math inline">\(k\)</span>-тая полуплоскость станет новой граничной (и понадобится всё пересчитывать) равна всего <span class="math inline">\(\frac{2}{k}\)</span>.</p>
<p>Таким образом, <em>в среднем</em> алгоритм совершит линейное количество операций:</p>
<p><span class="math display">\[
\frac{2}{2} \cdot 2 + \frac{2}{3} \cdot 3 + \frac{2}{4} \cdot 4 + \ldots + \frac{2}{n} \cdot n = \sum_k \frac{2}{k} \cdot k = O(n)
\]</span></p>
<p>Подобная техника иногда используется и для других геометрических задач — например, для <a href="https://www.cs.cmu.edu/~ckingsf/class/02713/lectures/lec31-random.pdf">нахождения пары ближайших точек на плоскости</a>.</p>
</body>
</html>
