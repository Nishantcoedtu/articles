<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Задачи на многоугольники</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" href="../favicon.ico" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<div id="header">
<h1 class="title">Задачи на многоугольники</h1>
</div>
<h1 id="задачи-на-многоугольники">Задачи на многоугольники</h1>
<p>Очень часто геометрические задачи на контестах - это задачи на многоугольники. Некоторые из таких задач мы уже обсудили на предыдущих занятиях. Так мы уже обсудили задачу проверки многоугольника на выпуклость и научились находить площадь многоугольника. Напомним, что такое полярный угол.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/1/13/Polar_graph_paper.svg" alt="alt text" />
<p class="caption">alt text</p>
</div>
<h1 id="выпуклые-оболочки">Выпуклые оболочки</h1>
<p><strong>Выпуклое множество</strong> - такое множество точек, что все точки отрезка, образуемого любыми двумя точками данного множества, также принадлежат данному множеству</p>
<p><strong>Выпуклая оболочка фигуры</strong> - такое выпуклое множество точек, что все точки фигуры также лежат в нем.</p>
<p><strong>Минимальная выпуклая оболочка фигуры</strong> - это минимальная по площади выпуклая оболочка.</p>
<div class="figure">
<img src="http://informatics.letovo.ru/geom/Volgin_Asatrian/images/vup.png" alt="alt text" />
<p class="caption">alt text</p>
</div>
<div class="figure">
<img src="http://grafika.me/files/les_screens/convex_1.png" alt="alt text" />
<p class="caption">alt text</p>
</div>
<div class="figure">
<img src="https://2.bp.blogspot.com/-JngZWPM7wig/WlRz58cIMHI/AAAAAAAADGA/Pyhfngs_GKQMkb9B2_kqZJRQ5ZLEzrVMQCK4BGAYYCw/s1600/convexhullex.jpg" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>Дано множество точек, требуется построить его минимальную выпуклую оболочку :</p>
<h2 id="построение-за-onh">Построение за <span class="math inline">\(O(nh)\)</span></h2>
<h3 id="алгоритм-джарвисаметод-заворачивания-подарка">Алгоритм Джарвиса(метод заворачивания подарка)</h3>
<p>Давайте выберем какую-то точку, которая гарантированно попадет в минимальную выпуклую оболочкуо, например обычно берут нижнюю и если таких несколько, то самую левую из них. Теперь давайте по одной набирать точки, как бы заворачивая нашу выпуклую оболочку(отсюда и название). Как же нам найти следующую точку в выпуклую оболочку, давайте пройдемся по точкам, которые мы еще не взяли в МВО и среди них выберем с минимальным полярным углом.</p>
<div class="figure">
<img src="http://neerc.ifmo.ru/wiki/images/b/b3/Graham1.png" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>Корректность алгоритма легко доказывается по индукции, так как на первом шагу мы выбрали точку, точно лежащую в МВО, а на i, взяли такую точку, что все остальные лежат в нужной нам стороне.</p>
<p>Асимптотика : для каждой точки выпуклой оболочки мы из всех оставшихся точек будем искать оптимальную - что будет работать за h(размер выпуклой оболочки) * n</p>
<h3 id="важно-помнить-что-именно-ohn-а-не-on2-так-как-существуют-задачи-на-это">Важно помнить, что именно <span class="math inline">\(O(hn)\)</span>, а не <span class="math inline">\(O(n^2)\)</span>, так как существуют задачи на это</h3>
<pre><code>int base = 0;
for (int i = 1; i &lt; n; i++) {
    if (mas[i].y &lt; mas[base].y) {
        base = i;
    }
    else if (mas[i].y == mas[base].y &amp;&amp; mas[i].x &lt; mas[base].x) {
        base = i;
    }
}
convex_hull.push_back(base);
point first = mas[base];
point cur = first;
point prev = point(first.x - 1, first.y);
do {
    double minCosAngle = 1e9; // чем больше угол, тем меньше его косинус
    double maxLen = 1e9;
    int next = -1;
    for (int i = 0; i &lt; n; i++) {
        double curCosAngle = CosAngle(prev, cur, mas[i]);
        if (Less(curCosAngle,minCosAngle)) {//если меньше сразу меняем
            next = i;
            minCosAngle = curCosAngle;
            maxLen = dist(cur, mas[i]);
        }
        else if (Equal(curCosAngle, minCosAngle)) {// смотрим по длине
            double curLen = dist(cur,mas[i]);
            if (More(curLen,maxLen)) {
                next = i;
                maxLen = curLen;
            }
        }
    }
    prev = cur;
    cur = mas[next];
    convex_hull.push_back(next);
}
while (cur != first);</code></pre>
<h2 id="построение-за-on-log-n">Построение за <span class="math inline">\(O(n \log n)\)</span></h2>
<h3 id="алгоритм-грэхема">Алгоритм Грэхема</h3>
<p>Алгоритм Грэхема базируется на следующей идее: Давайте не искать следующую точку каждый раз, а сделаем так, чтобы у нас всегда была оптимальная точка и мы могли бы просто ее достать и проверить.</p>
<p>В прошлом алгоритме мы искали точку, оптимальную по полярному углу, тогда давайте сейчас сразу отсортируем точки по полярному углу и сразу возьмем две первые точки в МВО.</p>
<p>Теперь будем делать следующий алгоритм, пока все точки не будут просмотрены :</p>
<ol style="list-style-type: decimal">
<li><p>Возьмем первую из отсортированных точек.</p></li>
<li><p>Проверем последние три точки из взятых, если они образуют правый поворот, то удалим предпоследнюю точку</p></li>
</ol>
<p>Сделать это можно, например, стеком. Код есть ниже.</p>
<div class="figure">
<img src="https://cdn.turkaramamotoru.com/ru/algoritm-grehema-4131.jpg" alt="alt text" />
<p class="caption">alt text</p>
</div>
<p>Асимптотика : Мы просмотрим одну точку и либо удалим ее, либо оставим, то есть сам поиск МВО работает за линейное время, но мы еще делаем сортировку, а <span class="math inline">\(\rightarrow\)</span> алгоритм работает за <span class="math inline">\(O(n\log(n))\)</span>, при этом его корректность вытекает из предыдущего алгоритма.</p>
<p>Красивая визуализация - https://visualgo.net/en/convexhull</p>
<p>красивое видео - https://www.youtube.com/watch?v=BTgjXwhoMuI .</p>
<pre><code>struct Point {
    int x, y;
};

Point operator -(Point a, Point b)
{
    return {a.x - b.x, a.y - b.y};
}

int operator * (Point a, Point b)
{
    return a.x * b.x + b.y * a.y;
}

int operator ^(Point a, Point b)
{
    return a.x * b.y - b.x * a.y;
}

bool cw(Point a, Point b, Point c)
{
    return (a - b) * (c - b) &gt; 0;
}

bool ccw(Point a, Point b, Point c)
{
    return (a - b) * (c - b) &lt; 0;
}

int main()
{
    sort(all(p2), comp);
    vector&lt;Point&gt; s;
    s.push_back(p[min_ind]);
    for (int i = 0; i &lt; n - 1; i++) {
        if (p2[i].x == s[s.size() - 1].x &amp;&amp; p2[i].y == s[s.size() - 1].y)
            continue;
        while (s.size() &gt; 1 &amp;&amp; (vect(s[s.size() - 1], s[s.size() - 2]) ^
               vect(s[s.size() - 1], p2[i])) &gt; 0)
            s.pop_back();
        s.push_back(p2[i]);
    }
}</code></pre>
<h3 id="алгоритм-эндрю">Алгоритм Эндрю</h3>
<p>Алгоритм Эндрю опирается на то, что вещественные числа не точны и предлагает поменять компаратор и строить не одну выпуклую оболочку, а две :</p>
<p>Давайте выберем самую нижнюю и самую правую точку, затем отсортируем точки по самому простому из возможных компараторов, теперь будем строить две оболочки от самой правой точки и самой левой, в итоге мы получим верхнюю и нижнюю части выпуклой оболочки</p>
<pre><code>bool comp(Point a, Point b) {
    if(a.x == b.x) {
        return a.y &lt; b.y;
    }
    return a.x &lt; b.x;
}

int main() {
    sort(all(p), comp);
    vector&lt;Point&gt; up, down;
    up.pb(p[0]);
    down.pb(p[0]);
    Point p1 = p[0], p2 = p.back();
    for(int i = 1; i &lt; n; i++) {
        if (i == n - 1 || cw(p1, p[i], p2)) {
            while (up.size() &gt;= 2 &amp;&amp; !cw(up[up.size() - 2], up[up.size() - 1], p[i])) {
                up.pop_back();
            }
            up.pb(p[i]);
        }
        if (i == n - 1 || ccw(p1, p[i], p2)) {
            while (down.size() &gt;= 2 &amp;&amp; !ccw(down[down.size() - 2], down[down.size() - 1], p[i])) {
                down.pop_back();
            }
            down.pb(p[i]);
        }
    }
}</code></pre>
<h3 id="алгоритм-чена">Алгоритм Чена</h3>
<p>Также существует алгоритм, объединяющий Джарвиса и Грэхема(Эндрю) и работающий за <span class="math inline">\(O(n\log(h))\)</span>, но он разбираться не будет</p>
<h1 id="задачи">Задачи</h1>
<ol style="list-style-type: decimal">
<li>Базовые задачи - достаточно простые, например найти длину забора, чтобы ограничить многоугольник и подобные, но есть достаточно интересные задачи, в которых выпуклая оболочка неочевидна, например следующая : Даны <span class="math inline">\(n\)</span> пунктов в городе и <span class="math inline">\(n\)</span> почтальонов, для каждого пункта известно расстояние от почты <span class="math inline">\(c_{i}\)</span>. Требуется каждому пункту доставить почту, <span class="math inline">\(i\)</span>-ый почтальон просит <span class="math inline">\(a_{i}\)</span> монет, чтобы проснуться и <span class="math inline">\(b_{i}\)</span>, чтобы проехать один километр, требуется для каждого пункта сказать, кто доставит почту наиболее выгодно. (Подсказка : <span class="math inline">\(a_{i} + b_{i} * c_{j}\)</span> - это прямая и стоимость доставки от <span class="math inline">\(i\)</span> почтальона к <span class="math inline">\(j\)</span> пункту).</li>
</ol>
</body>
</html>
