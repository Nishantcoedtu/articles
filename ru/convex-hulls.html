<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Выпуклые оболочки</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
  });
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Выпуклые оболочки</h1>
</header>
<h1 id="выпуклые-оболочки">Выпуклые оболочки</h1>
<p><strong>Выпуклое множество</strong> — такое множество точек, что, для любых двух точек множества, все точки на отрезке между ними тоже принадлежат этому множеству.</p>
<p><strong>Выпуклая оболочка</strong> множества точек — такое выпуклое множество точек, что все точки фигуры также лежат в нем.</p>
<p><strong>Минимальная выпуклая оболочка</strong> множества точек — это минимальная по площади выпуклая оболочка.</p>
<p>Для экономии времени дальше минимальные выпуклые оболочки мы будем называть просто выпуклыми оболочками.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/de/ConvexHull.svg/220px-ConvexHull.svg.png" /></p>
<p>Для практических целей выпуклые оболочки полезны тем, что компактно хранят всю необходимую информацию о множестве точек, что позволяет быстро отвечать на разнообразные запросы на этом множестве.</p>
<p>Научимся их строить по какому-то множеству из <span class="math inline">\(n\)</span> точек на плоскости.</p>
<h2 id="алгоритм-джарвиса">Алгоритм Джарвиса</h2>
<p>Выберем какую-нибудь точку <span class="math inline">\(p_0\)</span>, которая гарантированно попадёт в выпуклую оболочку. Например, нижнюю, а если таких несколько, то самую левую из них.</p>
<p>Дальше будем действовать так: найдём самую «правую» точку от последней добавленной (то есть с минимальным полярным углом) и добавим её в оболочку. Будем так итеративно добавлять точки, пока не «замкнёмся», то есть пока самой правой не станет <span class="math inline">\(p_0\)</span>.</p>
<figure>
<img src="http://neerc.ifmo.ru/wiki/images/b/b3/Graham1.png" alt="alt text" /><figcaption>alt text</figcaption>
</figure>
<p>Корректность алгоритма легко доказывается по индукции:</p>
<ul>
<li><p>На первом шаге мы выбрали точку, точно лежащую в МВО.</p></li>
<li><p>На <span class="math inline">\(i\)</span>-м шаге мы взяли такую точку, что все остальные лежат по «правильную» сторону отрезка <span class="math inline">\((p_i, p_{i+1})\)</span>.</p></li>
</ul>
<p>Алгоритм Джарвиса также называют алгоритмом заворачивания подарка.</p>
<p>Для каждой точки выпуклой оболочки (обозначим их количество за <span class="math inline">\(h\)</span>) мы из всех оставшихся <span class="math inline">\(O(n)\)</span> точек будем искать оптимальную, что суммарно будет работать за <span class="math inline">\(O(n h)\)</span>.</p>
<p>В реализации будем пользоваться тем же классом для точки, что и в <a href="https://algorithmica.org/ru/geometry">статье про вычислительную геометрию</a>.</p>
<p>Для краткости, будем считать, что все точки различны, имеют целочисленные координаты, а также что нет трёх точек на одной прямой.</p>
<pre><code>vector&lt;r&gt; convex_hull(vector&lt;r&gt; points) {
    r p0 = points[0];
    for (r p : points)
        if (p.x &lt; p0.x || (p.x == p0.x &amp;&amp; p.y &lt; p0.y))
        p0 = p;
    vector&lt;r&gt; hull = {p0};
    do {
        for (int p = 0; p &lt; n; p++) {
            
        }
        
    } while()
}</code></pre>
<p>Важно помнить, что асимптотика именно <span class="math inline">\(O(nh)\)</span>, а не <span class="math inline">\(O(n^2)\)</span>: существуют задачи, где оболочка маленькая, и это существенно.</p>
<h2 id="алгоритм-грэхема">Алгоритм Грэхема</h2>
<p>Алгоритм Грэхема — это оптимизация алгоритма Джарвиса, основанная на следующей идее: давайте не искать следующую точку каждый раз, а сделаем так, чтобы у нас всегда была оптимальная точка и мы могли бы просто ее достать и проверить.</p>
<p>В прошлом алгоритме мы искали точку, оптимальную по полярному углу, тогда давайте сейчас сразу отсортируем точки по полярному углу и сразу возьмем две первые точки в МВО.</p>
<p>Теперь будем делать следующий алгоритм, пока все точки не будут просмотрены :</p>
<ol type="1">
<li><p>Возьмем первую из отсортированных точек.</p></li>
<li><p>Проверем последние три точки из взятых, если они образуют правый поворот, то удалим предпоследнюю точку</p></li>
</ol>
<p>Сделать это можно, например, стеком. Код есть ниже.</p>
<figure>
<img src="https://cdn.turkaramamotoru.com/ru/algoritm-grehema-4131.jpg" alt="alt text" /><figcaption>alt text</figcaption>
</figure>
<p>Асимптотика : Мы просмотрим одну точку и либо удалим ее, либо оставим, то есть сам поиск МВО работает за линейное время, но мы еще делаем сортировку, а <span class="math inline">\(\rightarrow\)</span> алгоритм работает за <span class="math inline">\(O(n\log(n))\)</span>, при этом его корректность вытекает из предыдущего алгоритма.</p>
<pre><code>int main() {
    sort(all(p2), comp);
    vector&lt;Point&gt; s;
    s.push_back(p[min_ind]);
    for (int i = 0; i &lt; n - 1; i++) {
        if (p2[i].x == s[s.size() - 1].x &amp;&amp; p2[i].y == s[s.size() - 1].y)
            continue;
        while (s.size() &gt; 1 &amp;&amp; (vect(s[s.size() - 1], s[s.size() - 2]) ^
               vect(s[s.size() - 1], p2[i])) &gt; 0)
            s.pop_back();
        s.push_back(p2[i]);
    }
}</code></pre>
<h2 id="верхние-и-нижние-огибающие">Верхние и нижние огибающие</h2>
<p>Для некоторых</p>
<h2 id="алгоритм-эндрю">Алгоритм Эндрю</h2>
<p>Алгоритм Эндрю опирается на то, что вещественные числа не точны и предлагает поменять компаратор и строить не одну выпуклую оболочку, а две :</p>
<p>Давайте выберем самую нижнюю и самую правую точку, затем отсортируем точки по самому простому из возможных компараторов, теперь будем строить две оболочки от самой правой точки и самой левой, в итоге мы получим верхнюю и нижнюю части выпуклой оболочки</p>
<pre><code>bool comp(Point a, Point b) {
    if(a.x == b.x) {
        return a.y &lt; b.y;
    }
    return a.x &lt; b.x;
}

int main() {
    sort(all(p), comp);
    vector&lt;Point&gt; up, down;
    up.pb(p[0]);
    down.pb(p[0]);
    Point p1 = p[0], p2 = p.back();
    for(int i = 1; i &lt; n; i++) {
        if (i == n - 1 || cw(p1, p[i], p2)) {
            while (up.size() &gt;= 2 &amp;&amp; !cw(up[up.size() - 2], up[up.size() - 1], p[i])) {
                up.pop_back();
            }
            up.pb(p[i]);
        }
        if (i == n - 1 || ccw(p1, p[i], p2)) {
            while (down.size() &gt;= 2 &amp;&amp; !ccw(down[down.size() - 2], down[down.size() - 1], p[i])) {
                down.pop_back();
            }
            down.pb(p[i]);
        }
    }
}</code></pre>
<h2 id="пересечение-оболочек">Пересечение оболочек</h2>
<h3 id="пересечение-полуплоскостей">Пересечение полуплоскостей</h3>
<p>Например, так можно строить подобные клёвые картинки:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Coloured_Voronoi_2D.svg/220px-Coloured_Voronoi_2D.svg.png" /></p>
<h2 id="алгоритм-чана">Алгоритм Чана</h2>
<p>Алгоритм Чана — это объединение алгоритмов Джарвиса и Грэхэма (или Эндрю) .</p>
<p>Разделим все точки на группы по <span class="math inline">\(m\)</span> точек в каждой. В каждой группе построим выпуклую оболочку за <span class="math inline">\(O(m \log m)\)</span>. Точки никак не упорядочены, и эти оболочки могут пересекаться, это нормально. Суммарно для всех групп понадобится <span class="math inline">\(O(n \log m)\)</span>.</p>
<p>Затем, так же начиная с самой левой нижей точки, мы будем строить общую выпуклую оболочку алгоритмом Джарвиса, но теперь «самую правую точку» можно находить каждый раз не за <span class="math inline">\(O(n)\)</span>, а за <span class="math inline">\(O(\frac{n}{m} \log m)\)</span>, если делать бинарный поиск в каждой из <span class="math inline">\(\frac{n}{m}\)</span> оболочек.</p>
<p>Такое решение будет работать за <span class="math inline">\(O(h \frac{n}{m} \log m + n \log m)\)</span>. Если заранее примерно знать <span class="math inline">\(h\)</span>, то можно положить <span class="math inline">\(m = h\)</span>, и тогда асимптотипа составит <span class="math inline">\(O(n \log h)\)</span>.</p>
<h2 id="динамические-выпуклые-оболочки">Динамические выпуклые оболочки</h2>
<h2 id="применения-не-в-геометрии">Применения не в геометрии</h2>
</body>
</html>
