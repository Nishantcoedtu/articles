<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Геометрия и ООП</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<div id="header">
<h1 class="title">Геометрия и ООП</h1>
</div>
<h1 id="геометрия-и-ооп">Геометрия и ООП</h1>
<p>Напомним, что отрезок, для которого указано, какой из его концов считается началом, а какой — концом, называется <strong>вектором</strong>. Вектор на плоскости можно задать двумя числами — его координатами по горизонтали и вертикали.</p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/7aa/2e5/f55/7aa2e5f550583a65de28560234e055e8.jpg" alt="vector" />
<p class="caption">vector</p>
</div>
<p>Помимо очевидных сложения, вычетания и умножения на константу (скаляр — одно число), у векторов можно ввести и свои особенные операции, которые нам упростят жизнь.</p>
<p><strong>Скалярное произведение</strong> (англ. dot product) — произведение длин векторов на косинус угла между ними. Для него справедлива формула, которая муторно и чисто технически доказывается:</p>
<p><span class="math display">\[ a \cdot b = x_a x_b + y_a y_b \]</span></p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/747/242/79b/74724279b3aa34f4f7c5f0b024fa23da.jpg" alt="dot" />
<p class="caption">dot</p>
</div>
<p>У него есть полезные свойства:</p>
<ul>
<li>Скалярное произведение симметрично (<span class="math inline">\(a \cdot b = b \cdot a\)</span>).</li>
<li>Геометрически, это проекция вектора b на вектор a, помноженынй на длину а.</li>
<li>Перпендикулярные вектора должны иметь нулевое скалярное произведение.</li>
<li>Если угол острый, то оно положительное</li>
<li>Если угол тупой, то отрицательное</li>
</ul>
<p><strong>Векторное произведение</strong> (англ. cross product) — произведение длин векторов на синус угла между ними, причём знак этого синуса зависит от порядка операндов. Оно тоже удобно выражается в координатах:</p>
<p><span class="math display">\[ a \times b = x_a y_b - y_a x_b \]</span></p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/a28/585/04b/a2858504bc917e2b084bf6f3e5827ca3.jpg" alt="cross" />
<p class="caption">cross</p>
</div>
<p>Его свойства:</p>
<ul>
<li>Скалярное произведение <em>анти</em>симметрично (<span class="math inline">\(a \times b = - (b \times a)\)</span>).</li>
<li>Геометрически, это ориентированный объем параллелограмма, натянутого на эти вектора.</li>
<li>Коллинеарные вектора должны иметь нулевое векторное произведение.</li>
<li>Если b «слева» от a, то оно положительное.</li>
<li>Если b «справа» — то отрицательное.</li>
</ul>
<h2 id="всякие-проверки">Всякие проверки</h2>
<p>Из-за этих классных свойств, почти все проверки можно описать через них, а не уравнениями.</p>
<p><strong>Принадлежность точки треугольнику</strong>. Пусть у нас есть треугольник ABC (заданный против часовой стрелки) и точка P. Тогда она должна лежать слева от всех трёх векторов AB, BC и CA. Это условие задаст пересечение трёх полуплоскостей, которое и будет нужным треугольником.</p>
<p><span class="math display">\[
\text{P лежит внутри ABC} \iff \begin{cases}
(B-A) \times (P-A) \geq 0 \\
(C-B) \times (P-B) \geq 0 \\
(A-C) \times (P-C) \geq 0 \\
\end{cases}
\]</span></p>
<p><strong>Площадь треугольника</strong>. Можно пользоваться готовыми формулами, а можно и свойством векторного произведения.</p>
<p><span class="math display">\[ V = \frac{1}{2} (B-A) \times (C-A) \]</span></p>
<p><strong>Площадь произвольного многоугольника</strong>. Если многоугольник задан последовательностью вершин в каком-то порядке, то можно считать так: для каждого ребра добавим его ориентированную площадь от начала координат. Какие-то слагаемые будут положительными (которые на последнем слое, а какие-то — отрицательными).</p>
<div class="figure">
<img src="https://habrastorage.org/getpro/habr/post_images/1b3/b00/8c0/1b3b008c0c074b0e38111a95ad421605.jpg" alt="any" />
<p class="caption">any</p>
</div>
<p>Забудьте о формуле Герона и всегда считайте площади через векторное произведение.</p>
<p>Кстати, из формулы тря треугольника следует, что площадь любой фигуры будет либо целым числом, либо рациональным с двойкой в знаменателе. Чтобы оставаться в целых числах, иногда имеет смысл умножить все входные данные на 2.</p>
<p><strong>Проверка на выпуклость</strong>. Можно пройтись по сторонам многоугольника и проверять векторным произведением, что мы поворачиваем всегда в одну сторону (то есть если у нас последовательные точки a, b и c, то <span class="math inline">\((b-a)\times(c-a) &gt; 0\)</span>).</p>
<p><strong>Пересекаются ли отрезки</strong>.</p>
<div class="figure">
<img src="https://habrastorage.org/storage2/a03/5b4/ffa/a035b4ffa74057e35428196b55a4154b.png" alt="segments" />
<p class="caption">segments</p>
</div>
<h2 id="уравнение-прямой">Уравнение прямой</h2>
<p>Прямая задается уравнением вида <span class="math inline">\(Ax + By + C = 0\)</span>. Полуплоскость можно задать таким же неравенством.</p>
<p>У прямой есть <em>вектор нормали</em> с координатами <span class="math inline">\((A, B)\)</span>. Он перпендиуклярен прямой, а в случае с полуплоскостью <span class="math inline">\(Ax + By + C \geq 0\)</span> будет указывать в сторону самой полуплоскости.</p>
<p>Чтобы найти расстояние от точки <span class="math inline">\((x_0, y_0)\)</span> до прямой <span class="math inline">\(Ax + By + C = 0\)</span>, можно воспользоваться следующей формулой:</p>
<p><span class="math display">\[ d = \frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}} \]</span></p>
<p><strong>Точка пересечения</strong>. По сути, найти точку пересечения двух прямых — это то же самое, что и найти точку, которая удовлетворяет обоим условиям их уравнений:</p>
<p><span class="math display">\[
\begin{cases}
A_1 x + B_1 y + C_1 = 0 \\
A_2 x + B_2 y + C_2 = 0
\end{cases}
\implies 
\begin{cases}
-x = \frac{B_1 y + C_1}{A_1} \\
-x = \frac{B_2 y + C_2}{A_2}
\end{cases}
\implies 
\frac{B_1 y + C_1}{A_1} = \frac{B_2 y + C_2}{A_2}
\implies 
y = - \frac{A_1 C_2 - A_2 C_1}{A_1 B_2 - A_2 B_1}
\]</span></p>
<p>Аналогично, <span class="math inline">\(x = \frac{B_1 C_2 - B_2 C_1}{A_1 B_2 - A_2 B_1}\)</span> (обратите внимание на знаки).</p>
<p>Заметьте, что знаменатель может оказаться нулем. Это означает, что векторное произведение векторов нормали нулевое, а значит прямые параллельны (в частности, это могут быть совпадающие прямые). Этот случай нужно отдельно обрабатывать.</p>
<h1 id="как-это-кодить-в-c">Как это кодить в C++</h1>
<p>Сначала мы создадим класс, который будет отвечать за все операции с точками. В C++ есть два способа это сделать: через <code>struct</code> и через <code>class</code>. Их основное отличие в том, что по умолчанию в <code>class</code> все поля <em>приватные</em> — к ним нет прямого доступа снаружи. Это нужно для дополнительной защиты, чтобы в крупных промышленных проектах никто случайно ничего не поломал, но на олимпиадах это не очень актуально.</p>
<p><strong>Точка <span class="math inline">\(\simeq\)</span> вектор</strong>. Мы будем считать точка и вектор это один и тот же объект, так как они оба — это просто пара чисел. Будем сопоставлять точке её <em>радиус-вектор</em> — вектор из начала координат, ведущий в эту точку. По <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D0%B8%D1%83%D1%81-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80">принятой</a> в математике и физике нотации, будем обозночать вектора как <code>r</code>. Вы можете обозвать их как <code>point</code>, <code>pt</code>, <code>vec</code> — как угодно.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> r {
    <span class="dt">double</span> x, y;
    r () {}
    r (<span class="dt">int</span> _x, <span class="dt">int</span> _y) { x = _x, y = _y; }
};</code></pre></div>
<p>Функция <code>r</code> внутри класса вызывается при инциализации объекта. Она называется конструктор, и её можно указывать разную для разных параметров. Таким образом, <code>r()</code> вернёт точку с неопределенными (какие оказались в памяти в тот момент) координатами, а r(x, y) вернет точку с координатами <span class="math inline">\((x, y)\)</span>.</p>
<h2 id="операции-над-векторами">Операции над векторами</h2>
<p>Давайте напишем функцию, которая принимает вектора и что-то с ними делает. Например, считает длину:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> len (r a) { <span class="kw">return</span> sqrt(a.x*a.x + a.y*a.y); }</code></pre></div>
<h2 id="операторы">Операторы</h2>
<p>В C++ можно <em>перегружать</em> почти все стандартные операторы, например, <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> и т. д.</p>
<p>Давайте для будущих нужд определим <code>+</code> и <code>-</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">r <span class="kw">operator</span>+(r a, r b){ <span class="kw">return</span> r(a.x+b.x, a.y+b.y); }
r <span class="kw">operator</span>-(r a, r b){ <span class="kw">return</span> r(a.x-b.x, a.y-b.y); }</code></pre></div>
<h2 id="скалярное-произведение">Скалярное произведение</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">operator</span>*(r a, r b){ <span class="kw">return</span> a.x*b.x + a.y*b.y; }</code></pre></div>
<h2 id="векторное-произведение">Векторное произведение</h2>
<p>Формально оно определяется не так. Оно определяется как вектор той же длины, но перпендикулярный обоим исходным векторам. Это имеет применение в 3d геометрии (ещё не разу не встречавшейся на школьных олимпиадах) и физике.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">operator</span>^(r a, r b){ <span class="kw">return</span> a.x*b.y - b.x*a.y; }</code></pre></div>
<h3 id="ввод-вывод">Ввод-вывод</h3>
<p>Как вы думаете, как на самом деле работает <code>cin &gt;&gt; x;</code>? Это тоже перегрузка оператора <code>&gt;&gt;</code>. Делать это нужно так:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">istream&amp; <span class="kw">operator</span>&gt;&gt;(istream &amp;in, r &amp;p){ 
    in &gt;&gt; p.x &gt;&gt; p.y;
    <span class="kw">return</span> in;
}

ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream &amp;out, r &amp;p){ 
    out &lt;&lt; p.x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; p.y &lt;&lt; endl;
    <span class="kw">return</span> out;            
}</code></pre></div>
<h2 id="алгебра-vs-алгоритмы-или-зачем-мы-всё-это-делали">Алгебра VS Алгоритмы или зачем мы всё это делали</h2>
<p>Мы могли не создавать никаких структур и работать с уравнениями, описывающими математические объекты. Такой подход будет популярен на олимпиадах по математике, а не по программированию. Когда математик говорит «пересечем две прямые», он представляет громоздкое уравнение, с которым он потом будет работать. Программист же хочет абстрагироваться и просто написать <code>intersect(a, b)</code>, в корректности которого он точно уверен.</p>
<h3 id="векторное-представление-прямой-ax-by-c-0-rightarrow-r-at-b">Векторное представление прямой (<span class="math inline">\(Ax + By + C = 0 \rightarrow r = at + b\)</span>)</h3>
<p>Тут нужно просто выбрать две любые точки на прямой.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// даны A, B, C (A^2 + B^2 != 0)</span>
r a, b;
<span class="kw">if</span> (eq(A, <span class="dv">0</span>)) <span class="co">// значит, это горизонтальная прямая</span>
    a = r(<span class="dv">0</span>, -C/B), b = r(<span class="dv">1</span>, -C/B);
<span class="kw">else</span>
    a = r(-C/A, <span class="dv">0</span>), b = (<span class="dv">1</span>, -(C+B)/A, <span class="dv">1</span>)</code></pre></div>
<h3 id="пример-отражение-от-прямой">Пример: отражение от прямой</h3>
<p>Пусть нам надо отразить точку <span class="math inline">\((x_0, y_0)\)</span> симметрично относительно заданной прямой <span class="math inline">\(ax+by+c=0\)</span>. Чисто в педагогических целях, решим эту задачу как математики, чтобы никогда потом так не делать.</p>
<p>$_a b =   =   = |b|  $</p>
<p>Формула имеет смысл: длина на единичный вектор направления.</p>
<p>Мы <strong>не</strong> хотим раскрывать эти формулы покоординатно и предъявлять готовый ответ. Мы знаем, что он получится громоздким. Нам не жално посчитать всё по частям — здесь нет смысла заниматься оптимизациями. Также мы хотим делать всё по частям, потому что так более наглядна логика алгоритма, и как следствие его проще дебажить.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// прямая r = at + b, точка c</span>
r pr (r a, r b, r c) {
    c -= b; <span class="co">// пусть c и a выходят из одной точки</span>
    <span class="kw">return</span> b + (a*b / len(a) / len(a)) * a;
}

r reflect (r a, r b, r c) {
    <span class="kw">return</span> c + <span class="dv">2</span>*(pr(a, b, c)-c);
}</code></pre></div>
<h2 id="типичные-баги">Типичные баги</h2>
<h3 id="точность">Точность</h3>
<blockquote>
<p>Первое правило действительных чисел — не использовать действительные числа</p>
</blockquote>
<p>Все переменные типа <code>double</code> хранятся в компьютере неточно (ну а как вы представите ⅓ в двоичной системе счисления?). Поэтому при работе с даблами нужно <strong>всегда</strong> учитывать эту погрешность. Например, чтобы сравнить два дабла, надо проверить, что они отличаются по модулю меньше, чем на очень маленькое число <code>eps</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">double</span> eps = <span class="fl">1e-8</span>;

<span class="dt">bool</span> eq (<span class="dt">double</span> a, <span class="dt">double</span> b) { <span class="kw">return</span> abs(a-b) &lt; eps }</code></pre></div>
<p>Чтобы так не делать, старайтесь по возможности использовать только инты и абсолютную точность. Иногда есть трюки, позволяющие так делать: например, если в задаче все входные точки целочисленные и нас просят посчитать какую-то площадь, то можно все координаты домножить на два, и тогда ответ тоже будет целым (см. векторное произведение), который только при выводе нужно будет поделить на четыре.</p>
<h3 id="neq--0"><span class="math inline">\(0 \neq -0\)</span></h3>
<p>Действительные числа так хрянятся, что 0 и -0 могут быть разными числами. Имейте это ввиду.</p>
<h3 id="область-определения-обратных-функций">Область определения обратных функций</h3>
<p><code>acos</code>, <code>asin</code> и прочие обратные тригонометрические функций требуют, чтобы им на вход подавалось число от -1 до 1. Для безопасности, масштабируйте числа, перед тем как брать от них эти функции.</p>
</body>
</html>
