<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
# Геометрия и ООП Напомним, что отрезок, для которого указано, какой из его концов считается началом, а какой — концом, называется **вектором**. Вектор на плоскости можно задать двумя числами — его координатами по горизонтали и вертикали. ![vector](https://habrastorage.org/getpro/habr/post_images/7aa/2e5/f55/7aa2e5f550583a65de28560234e055e8.jpg) Помимо очевидных сложения, вычетания и умножения на константу (скаляр — одно число), у векторов можно ввести и свои особенные операции, которые нам упростят жизнь. **Скалярное произведение** (англ. dot product) — произведение длин векторов на косинус угла между ними. Для него справедлива формула, которая муторно и чисто технически доказывается: $$ a \cdot b = x_a x_b + y_a y_b $$ ![dot](https://habrastorage.org/getpro/habr/post_images/747/242/79b/74724279b3aa34f4f7c5f0b024fa23da.jpg) У него есть полезные свойства: * Скалярное произведение симметрично ($a \cdot b = b \cdot a$). * Геометрически, это проекция вектора b на вектор a, помноженынй на длину а. * Перпендикулярные вектора должны иметь нулевое скалярное произведение. * Если угол острый, то оно положительное * Если угол тупой, то отрицательное **Векторное произведение** (англ. cross product) — произведение длин векторов на синус угла между ними, причём знак этого синуса зависит от порядка операндов. Оно тоже удобно выражается в координатах: $$ a \times b = x_a y_b - y_a x_b $$ ![cross](https://habrastorage.org/getpro/habr/post_images/a28/585/04b/a2858504bc917e2b084bf6f3e5827ca3.jpg) Его свойства: * Скалярное произведение *анти*симметрично ($a \times b = - (b \times a)$). * Геометрически, это ориентированный объем параллелограмма, натянутого на эти вектора. * Коллинеарные вектора должны иметь нулевое векторное произведение. * Если b «слева» от a, то оно положительное. * Если b «справа» — то отрицательное. ## Всякие проверки Из-за этих классных свойств, почти все проверки можно описать через них, а не уравнениями. **Принадлежность точки треугольнику**. Пусть у нас есть треугольник ABC (заданный против часовой стрелки) и точка P. Тогда она должна лежать слева от всех трёх векторов AB, BC и CA. Это условие задаст пересечение трёх полуплоскостей, которое и будет нужным треугольником. $$ \text{P лежит внутри ABC} \iff \begin{cases} (B-A) \times (P-A) \geq 0 \\ (C-B) \times (P-B) \geq 0 \\ (A-C) \times (P-C) \geq 0 \\ \end{cases} $$ **Площадь треугольника**. Можно пользоваться готовыми формулами, а можно и свойством векторного произведения. $$ V = \frac{1}{2} (B-A) \times (C-A) $$ **Площадь произвольного многоугольника**. Если многоугольник задан последовательностью вершин в каком-то порядке, то можно считать так: для каждого ребра добавим его ориентированную площадь от начала координат. Какие-то слагаемые будут положительными (которые на последнем слое, а какие-то — отрицательными). ![any](https://habrastorage.org/getpro/habr/post_images/1b3/b00/8c0/1b3b008c0c074b0e38111a95ad421605.jpg) Забудьте о формуле Герона и всегда считайте площади через векторное произведение. Кстати, из формулы тря треугольника следует, что площадь любой фигуры будет либо целым числом, либо рациональным с двойкой в знаменателе. Чтобы оставаться в целых числах, иногда имеет смысл умножить все входные данные на 2. **Проверка на выпуклость**. Можно пройтись по сторонам многоугольника и проверять векторным произведением, что мы поворачиваем всегда в одну сторону (то есть если у нас последовательные точки a, b и c, то $(b-a)\times(c-a) &gt; 0$). **Пересекаются ли отрезки**. ![segments](https://habrastorage.org/storage2/a03/5b4/ffa/a035b4ffa74057e35428196b55a4154b.png) ## Уравнение прямой Прямая задается уравнением вида $Ax + By + C = 0$. Полуплоскость можно задать таким же неравенством. У прямой есть *вектор нормали* с координатами $(A, B)$. Он перпендиуклярен прямой, а в случае с полуплоскостью $Ax + By + C \geq 0$ будет указывать в сторону самой полуплоскости. Чтобы найти расстояние от точки $(x_0, y_0)$ до прямой $Ax + By + C = 0$, можно воспользоваться следующей формулой: $$ d = \frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}} $$ **Точка пересечения**. По сути, найти точку пересечения двух прямых — это то же самое, что и найти точку, которая удовлетворяет обоим условиям их уравнений: $$ \begin{cases} A_1 x + B_1 y + C_1 = 0 \\ A_2 x + B_2 y + C_2 = 0 \end{cases} \implies \begin{cases} -x = \frac{B_1 y + C_1}{A_1} \\ -x = \frac{B_2 y + C_2}{A_2} \end{cases} \implies \frac{B_1 y + C_1}{A_1} = \frac{B_2 y + C_2}{A_2} \implies y = - \frac{A_1 C_2 - A_2 C_1}{A_1 B_2 - A_2 B_1} $$ Аналогично, $x = \frac{B_1 C_2 - B_2 C_1}{A_1 B_2 - A_2 B_1}$ (обратите внимание на знаки). Заметьте, что знаменатель может оказаться нулем. Это означает, что векторное произведение векторов нормали нулевое, а значит прямые параллельны (в частности, это могут быть совпадающие прямые). Этот случай нужно отдельно обрабатывать. # Как это кодить в C++ Сначала мы создадим класс, который будет отвечать за все операции с точками. В C++ есть два способа это сделать: через `struct` и через `class`. Их основное отличие в том, что по умолчанию в `class` все поля *приватные* — к ним нет прямого доступа снаружи. Это нужно для дополнительной защиты, чтобы в крупных промышленных проектах никто случайно ничего не поломал, но на олимпиадах это не очень актуально. **Точка $\simeq$ вектор**. Мы будем считать точка и вектор это один и тот же объект, так как они оба — это просто пара чисел. Будем сопоставлять точке её *радиус-вектор* — вектор из начала координат, ведущий в эту точку. По [принятой](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D0%B8%D1%83%D1%81-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80) в математике и физике нотации, будем обозночать вектора как `r`. Вы можете обозвать их как `point`, `pt`, `vec` — как угодно. ```c++ struct r { double x, y; r () {} r (int _x, int _y) { x = _x, y = _y; } }; ``` Функция `r` внутри класса вызывается при инциализации объекта. Она называется конструктор, и её можно указывать разную для разных параметров. Таким образом, `r()` вернёт точку с неопределенными (какие оказались в памяти в тот момент) координатами, а r(x, y) вернет точку с координатами $(x, y)$. ## Операции над векторами Давайте напишем функцию, которая принимает вектора и что-то с ними делает. Например, считает длину: ```c++ double len (r a) { return sqrt(a.x*a.x + a.y*a.y); } ``` ## Операторы В C++ можно *перегружать* почти все стандартные операторы, например, `+`, `-`, `&lt;&lt;` и т. д. Давайте для будущих нужд определим `+` и `-`: ```c++ r operator+(r a, r b){ return r(a.x+b.x, a.y+b.y); } r operator-(r a, r b){ return r(a.x-b.x, a.y-b.y); } ``` ## Скалярное произведение ```c++ int operator*(r a, r b){ return a.x*b.x + a.y*b.y; } ``` ## Векторное произведение Формально оно определяется не так. Оно определяется как вектор той же длины, но перпендикулярный обоим исходным векторам. Это имеет применение в 3d геометрии (ещё не разу не встречавшейся на школьных олимпиадах) и физике. ```c++ int operator^(r a, r b){ return a.x*b.y - b.x*a.y; } ``` ### Ввод-вывод Как вы думаете, как на самом деле работает `cin &gt;&gt; x;`? Это тоже перегрузка оператора `&gt;&gt;`. Делать это нужно так: ```c++ istream&amp; operator&gt;&gt;(istream &amp;in, r &amp;p){ in &gt;&gt; p.x &gt;&gt; p.y; return in; } ostream&amp; operator&lt;&lt;(ostream &amp;out, r &amp;p){ out &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; return out; } ``` ## Алгебра VS Алгоритмы или зачем мы всё это делали Мы могли не создавать никаких структур и работать с уравнениями, описывающими математические объекты. Такой подход будет популярен на олимпиадах по математике, а не по программированию. Когда математик говорит «пересечем две прямые», он представляет громоздкое уравнение, с которым он потом будет работать. Программист же хочет абстрагироваться и просто написать `intersect(a, b)`, в корректности которого он точно уверен. ### Векторное представление прямой ($Ax + By + C = 0 \rightarrow r = at + b$) Тут нужно просто выбрать две любые точки на прямой. ```c++ // даны A, B, C (A^2 + B^2 != 0) r a, b; if (eq(A, 0)) // значит, это горизонтальная прямая a = r(0, -C/B), b = r(1, -C/B); else a = r(-C/A, 0), b = (1, -(C+B)/A, 1) ``` ### Пример: отражение от прямой Пусть нам надо отразить точку $(x_0, y_0)$ симметрично относительно заданной прямой $ax+by+c=0$. Чисто в педагогических целях, решим эту задачу как математики, чтобы никогда потом так не делать. $\Pr_a b = \frac{a \cdot b}{|a|} \frac{a}{|a|} = \frac{|a| |b| \cos \alpha}{|a|} \frac{a}{|a|} = |b| \cos \alpha \frac{a}{|a|} $ Формула имеет смысл: длина на единичный вектор направления. Мы **не** хотим раскрывать эти формулы покоординатно и предъявлять готовый ответ. Мы знаем, что он получится громоздким. Нам не жално посчитать всё по частям — здесь нет смысла заниматься оптимизациями. Также мы хотим делать всё по частям, потому что так более наглядна логика алгоритма, и как следствие его проще дебажить. ```c++ // прямая r = at + b, точка c r pr (r a, r b, r c) { c -= b; // пусть c и a выходят из одной точки return b + (a*b / len(a) / len(a)) * a; } r reflect (r a, r b, r c) { return c + 2*(pr(a, b, c)-c); } ``` ## Типичные баги ### Точность &gt; Первое правило действительных чисел — не использовать действительные числа Все переменные типа `double` хранятся в компьютере неточно (ну а как вы представите ⅓ в двоичной системе счисления?). Поэтому при работе с даблами нужно **всегда** учитывать эту погрешность. Например, чтобы сравнить два дабла, надо проверить, что они отличаются по модулю меньше, чем на очень маленькое число `eps`: ```c++ const double eps = 1e-8; bool eq (double a, double b) { return abs(a-b) &lt; eps } ``` Чтобы так не делать, старайтесь по возможности использовать только инты и абсолютную точность. Иногда есть трюки, позволяющие так делать: например, если в задаче все входные точки целочисленные и нас просят посчитать какую-то площадь, то можно все координаты домножить на два, и тогда ответ тоже будет целым (см. векторное произведение), который только при выводе нужно будет поделить на четыре. ### $0 \neq -0$ Действительные числа так хрянятся, что 0 и -0 могут быть разными числами. Имейте это ввиду. ### Область определения обратных функций `acos`, `asin` и прочие обратные тригонометрические функций требуют, чтобы им на вход подавалось число от -1 до 1. Для безопасности, масштабируйте числа, перед тем как брать от них эти функции.
<div>
<img src="https://mc.yandex.ru/watch/53961409" />
</div>
</body>
</html>
