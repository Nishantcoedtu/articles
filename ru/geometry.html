<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Вычислительная геометрия - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <!--<a href='https://algorithmica.org/ru/'>На главную</a>-->
        <a href='https://github.com/algorithmica-org/articles/edit/master/src/ru/geometry.md'>Редактировать</a>
        <!--<a href='https://github.com/algorithmica-org/articles/commits/master/src/ru/geometry.md'>История изменений</a>-->
    </div>
</div>
<h1 id="вычислительная-геометрия">Вычислительная геометрия</h1>
<p>Напомним, что отрезок, для которого указано, какой из его концов считается началом, а какой — концом, называется <strong>вектором</strong>. Вектор на плоскости можно задать двумя числами — его координатами по горизонтали и вертикали.</p>
<figure>
<img src="https://habrastorage.org/getpro/habr/post_images/7aa/2e5/f55/7aa2e5f550583a65de28560234e055e8.jpg" alt="vector" /><figcaption>vector</figcaption>
</figure>
<p>Помимо очевидных сложения, вычитания и умножения на константу (скаляр — одно число), у векторов можно ввести и свои особенные операции, которые нам упростят жизнь.</p>
<p><strong>Скалярное произведение</strong> (англ. <em>dot product</em>) — произведение длин векторов на косинус угла между ними. Для него справедлива следующая формула:</p>
<p><span class="math display">\[
a \cdot b = x_a x_b + y_a y_b
\]</span></p>
<p>Она доказывается муторно и чисто технически, так что мы это делать не будем.</p>
<p>Геометрически, она равна проекции вектора <span class="math inline">\(b\)</span> на вектор <span class="math inline">\(a\)</span>, помноженный на длину <span class="math inline">\(а\)</span>:</p>
<figure>
<img src="https://habrastorage.org/getpro/habr/post_images/747/242/79b/74724279b3aa34f4f7c5f0b024fa23da.jpg" alt="dot" /><figcaption>dot</figcaption>
</figure>
<p>У него есть полезные свойства:</p>
<ul>
<li>Скалярное произведение симметрично (<span class="math inline">\(a \cdot b = b \cdot a\)</span>).</li>
<li>Перпендикулярные вектора должны иметь нулевое скалярное произведение.</li>
<li>Если угол острый, то скалярное произведение положительное.</li>
<li>Если угол тупой, то скалярное произведение отрицательное.</li>
</ul>
<p><strong>Векторное произведение</strong> (англ. <em>cross product</em>) — произведение длин векторов на синус угла между ними, причём знак этого синуса зависит от порядка операндов. Оно тоже удобно выражается в координатах:</p>
<p><span class="math display">\[
a \times b = x_a y_b - y_a x_b
\]</span></p>
<p>Геометрически, это ориентированный объем параллелограмма, натянутого на вектора <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span>:</p>
<figure>
<img src="https://habrastorage.org/getpro/habr/post_images/a28/585/04b/a2858504bc917e2b084bf6f3e5827ca3.jpg" alt="cross" /><figcaption>cross</figcaption>
</figure>
<p>Его свойства:</p>
<ul>
<li>Векторное произведение <strong>анти</strong>симметрично: <span class="math inline">\(a \times b = - (b \times a)\)</span>.</li>
<li>Коллинеарные вектора должны иметь нулевое векторное произведение.</li>
<li>Если <span class="math inline">\(b\)</span> «слева» от <span class="math inline">\(a\)</span>, то векторное произведение положительное.</li>
<li>Если <span class="math inline">\(b\)</span> «справа» от <span class="math inline">\(a\)</span>, то векторное произведение отрицательное.</li>
</ul>
<p>Вообще говоря, векторное произведение определяется не так. Оно определено как вектор такой же длины, но перпендикулярный обоим исходным векторам. Это имеет применение в трёхмерной геометрии и физике, но нам об этом думать не надо.</p>
<h2 id="всякие-проверки">Всякие проверки</h2>
<p>Благодаря этим свойствам, почти все проверки в геометрии можно описать через них, а не уравнениями.</p>
<p><strong>Принадлежность точки треугольнику</strong>. Пусть у нас есть треугольник <span class="math inline">\(ABC\)</span> (заданный против часовой стрелки) и точка <span class="math inline">\(P\)</span>. Тогда она должна лежать слева от всех трёх векторов <span class="math inline">\(AB\)</span>, <span class="math inline">\(BC\)</span> и <span class="math inline">\(CA\)</span>. Это условие задаст пересечение трёх полуплоскостей, которое и будет нужным треугольником.</p>
<p><span class="math display">\[
\text{P лежит внутри ABC} \iff \begin{cases}
(B-A) \times (P-A) \geq 0 \\
(C-B) \times (P-B) \geq 0 \\
(A-C) \times (P-C) \geq 0 \\
\end{cases}
\]</span></p>
<p><strong>Площадь треугольника</strong>. Можно пользоваться готовыми формулами, а можно и свойством векторного произведения.</p>
<p><span class="math display">\[
V = \frac{1}{2} (B-A) \times (C-A)
\]</span></p>
<p><strong>Площадь произвольного многоугольника</strong>. Если многоугольник задан последовательностью вершин в каком-то порядке, то можно считать так: для каждого ребра добавим его ориентированную площадь от начала координат. Какие-то слагаемые будут положительными (которые на последнем слое, а какие-то — отрицательными).</p>
<figure>
<img src="https://habrastorage.org/getpro/habr/post_images/1b3/b00/8c0/1b3b008c0c074b0e38111a95ad421605.jpg" alt="any" /><figcaption>any</figcaption>
</figure>
<p>Забудьте о формуле Герона и всегда считайте площади через векторное произведение.</p>
<p>Кстати, из формулы для площади треугольника следует, что площадь любой фигуры будет либо целым числом, либо рациональным с двойкой в знаменателе. Часто в в задачах входные данные целочисленные, и, чтобы оставаться в целых числах, когда мы считаем какую-нибудь площадь, иногда имеет смысл умножить все входные числа на <span class="math inline">\(2\)</span> (см. «точность»).</p>
<p><strong>Проверка на выпуклость</strong>. Можно пройтись по сторонам многоугольника и проверять векторным произведением, что мы поворачиваем всегда в одну сторону, то есть для всех последовательных точек <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> проверить, что <span class="math inline">\((b-a)\times(c-a) &gt; 0\)</span>.</p>
<p><strong>Пересекаются ли отрезки</strong>.</p>
<figure>
<img src="https://habrastorage.org/storage2/a03/5b4/ffa/a035b4ffa74057e35428196b55a4154b.png" alt="segments" /><figcaption>segments</figcaption>
</figure>
<h2 id="уравнение-прямой">Уравнение прямой</h2>
<p>Прямую можно задать уравнением вида <span class="math inline">\(Ax + By + C = 0\)</span>. Полуплоскость можно задать таким же неравенством.</p>
<p>У прямой есть <em>вектор нормали</em> с координатами <span class="math inline">\((A, B)\)</span>. Он перпендиуклярен прямой, а в случае с полуплоскостью <span class="math inline">\(Ax + By + C \geq 0\)</span> будет указывать в сторону самой полуплоскости.</p>
<p>Чтобы найти расстояние от точки <span class="math inline">\((x_0, y_0)\)</span> до прямой <span class="math inline">\(Ax + By + C = 0\)</span>, можно воспользоваться следующей формулой:</p>
<p><span class="math display">\[
d = \frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2}}
\]</span></p>
<p><strong>Точка пересечения</strong>. По сути, найти точку пересечения двух прямых — это то же самое, что и найти точку, которая удовлетворяет обоим условиям их уравнений:</p>
<p><span class="math display">\[
\begin{cases}
A_1 x + B_1 y + C_1 = 0 \\
A_2 x + B_2 y + C_2 = 0
\end{cases}
\implies 
\begin{cases}
-x = \frac{B_1 y + C_1}{A_1} \\
-x = \frac{B_2 y + C_2}{A_2}
\end{cases}
\implies 
\frac{B_1 y + C_1}{A_1} = \frac{B_2 y + C_2}{A_2}
\implies 
y = - \frac{A_1 C_2 - A_2 C_1}{A_1 B_2 - A_2 B_1}
\]</span></p>
<p>Аналогично, <span class="math inline">\(x = \frac{B_1 C_2 - B_2 C_1}{A_1 B_2 - A_2 B_1}\)</span> (обратите внимание на знаки).</p>
<p>Заметим, что знаменатель может оказаться нулем. Это означает, что векторное произведение векторов нормали нулевое, а значит прямые параллельны (в частности, это могут быть совпадающие прямые). Этот случай нужно обрабатывать отдельно.</p>
<h2 id="как-это-кодить-в-c">Как это кодить в C++</h2>
<p>Небольшой ликбез по объектно-ориентированному программированию в C++. Создадим класс, который будет отвечать за все операции с точками. В C++ есть два способа это сделать: через <code>struct</code> и через <code>class</code>. Их основное отличие в том, что по умолчанию в <code>class</code> все поля <em>приватные</em> — к ним нет прямого доступа снаружи. Это нужно для дополнительной защиты, чтобы в крупных промышленных проектах никто случайно ничего не поломал, но на олимпиадах это не очень актуально.</p>
<p><strong>Точка <span class="math inline">\(\simeq\)</span> вектор</strong>. Будем считать точка и вектор это один и тот же объект, так как они оба — это просто пара чисел. Будем сопоставлять точке её <em>радиус-вектор</em> — вектор из начала координат, ведущий в эту точку. По <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D0%B8%D1%83%D1%81-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80">принятой</a> в математике и физике нотации, будем обозночать вектора как <code>r</code>. Вы можете обозвать их как <code>point</code>, <code>pt</code>, <code>vec</code> — как угодно.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> r {</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="dt">double</span> x, y;</a>
<a class="sourceLine" id="cb1-3" title="3">    r() {}</a>
<a class="sourceLine" id="cb1-4" title="4">    r(<span class="dt">int</span> _x, <span class="dt">int</span> _y) { x = _x, y = _y; }</a>
<a class="sourceLine" id="cb1-5" title="5">};</a></code></pre></div>
<p>Функция <code>r</code> внутри класса вызывается при инциализации объекта. Её называют конструктором, и её можно указывать разную для разных параметров. Здесь <code>r()</code>вернёт точку с неопределенными (какие оказались в памяти в тот момент) координатами, а <code>r(x, y)</code> вернет точку с координатами <span class="math inline">\((x, y)\)</span>.</p>
<h3 id="операции-над-векторами">Операции над векторами</h3>
<p>Давайте напишем функцию, которая принимает вектора и что-то с ними делает. Например, считает длину:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">double</span> len(r a) { <span class="cf">return</span> sqrt(a.x*a.x + a.y*a.y); }</a></code></pre></div>
<h3 id="операторы">Операторы</h3>
<p>В C++ можно <em>перегружать</em> почти все стандартные операторы, например, <code>+</code>, <code>-</code>, <code>&lt;&lt;</code> и т. д.</p>
<p>Переопределим для будущих нужд <code>+</code> и <code>-</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">r <span class="kw">operator</span>+(r a, r b) { <span class="cf">return</span> r(a.x+b.x, a.y+b.y); }</a>
<a class="sourceLine" id="cb3-2" title="2">r <span class="kw">operator</span>-(r a, r b) { <span class="cf">return</span> r(a.x-b.x, a.y-b.y); }</a></code></pre></div>
<p>Скалярное произведение:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">int</span> <span class="kw">operator</span>*(r a, r b) { <span class="cf">return</span> a.x*b.x + a.y*b.y; }</a></code></pre></div>
<p>Векторное произведение:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> <span class="kw">operator</span>^(r a, r b) { <span class="cf">return</span> a.x*b.y - b.x*a.y; }</a></code></pre></div>
<h3 id="ввод-вывод">Ввод-вывод</h3>
<p>Как вы думаете, как на самом деле работает <code>cin &gt;&gt; x</code>? Это тоже перегрузка оператора — <code>&gt;&gt;</code>. Делается это так:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">istream&amp; <span class="kw">operator</span>&gt;&gt;(istream &amp;in, r &amp;p) { </a>
<a class="sourceLine" id="cb6-2" title="2">    in &gt;&gt; p.x &gt;&gt; p.y;</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="cf">return</span> in;</a>
<a class="sourceLine" id="cb6-4" title="4">}</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">ostream&amp; <span class="kw">operator</span>&lt;&lt;(ostream &amp;out, r &amp;p) { </a>
<a class="sourceLine" id="cb6-7" title="7">    out &lt;&lt; p.x &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; p.y &lt;&lt; endl;</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="cf">return</span> out;            </a>
<a class="sourceLine" id="cb6-9" title="9">}</a></code></pre></div>
<h2 id="почему-алгебра-это-плохо">Почему алгебра это плохо</h2>
<p>Мы могли не создавать никаких структур и работать с уравнениями, описывающими геометрические объекты. Такой подход будет популярен на олимпиадах по математике, а не по программированию. Когда математик говорит «пересечем две прямые», он представляет громоздкое уравнение, с которым он потом будет работать.</p>
<p>Программист же хочет абстрагироваться и просто написать <code>intersect(a, b)</code>, в корректности которого он точно уверен. Программист хочет разбить задачу на много маленьких кусочков и делать по отдельности, а не возиться с формулами.</p>
<p>Приведем несколько примеров конструктивного подхода.</p>
<h3 id="векторное-представление-прямой">Векторное представление прямой</h3>
<p>Прямую можно задать не через уравнение, а через два вектора <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span>:</p>
<p><span class="math display">\[
Ax + By + C = 0 \rightarrow r = at + b
\]</span></p>
<p>Чтобы это сделать, достаточно выбрать две любые точки на прямой:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// даны A, B, C (A^2 + B^2 != 0)</span></a>
<a class="sourceLine" id="cb7-2" title="2">r a, b;</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="cf">if</span> (eq(A, <span class="dv">0</span>)) <span class="co">// значит, это горизонтальная прямая</span></a>
<a class="sourceLine" id="cb7-4" title="4">    a = r(<span class="dv">0</span>, -C/B), b = r(<span class="dv">1</span>, -C/B);</a>
<a class="sourceLine" id="cb7-5" title="5"><span class="cf">else</span></a>
<a class="sourceLine" id="cb7-6" title="6">    a = r(-C/A, <span class="dv">0</span>), b = (<span class="dv">1</span>, -(C+B)/A, <span class="dv">1</span>)</a></code></pre></div>
<h3 id="отражение-от-прямой">Отражение от прямой</h3>
<p>Пусть нам надо отразить точку <span class="math inline">\((x_0, y_0)\)</span> симметрично относительно заданной прямой <span class="math inline">\(ax+by+c=0\)</span>. Чисто в педагогических целях, начнём решать эту задачу как математики, чтобы никогда потом так не делать.</p>
<p><span class="math display">\[
\Pr_a b = \frac{a \cdot b}{|a|} \frac{a}{|a|} = \frac{|a| |b| \cos \alpha}{|a|} \frac{a}{|a|} = |b| \cos \alpha \frac{a}{|a|}
\]</span></p>
<p>Геометрический смысл: длина на единичный вектор направления.</p>
<p>Мы <strong>не</strong> хотим раскрывать эти формулы покоординатно и предъявлять готовый ответ. Мы знаем, что он получится громоздким. Нам не жалко посчитать всё по частям — здесь нет смысла заниматься оптимизациями. Также мы хотим делать всё по частям, потому что так становится более наглядной логика алгоритма, и, как следствие, его проще дебажить.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// прямая r = at + b, точка c</span></a>
<a class="sourceLine" id="cb8-2" title="2">r pr (r a, r b, r c) {</a>
<a class="sourceLine" id="cb8-3" title="3">    c -= b; <span class="co">// пусть c и a выходят из одной точки</span></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="cf">return</span> b + (a*b / len(a) / len(a)) * a;</a>
<a class="sourceLine" id="cb8-5" title="5">}</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7">r reflect (r a, r b, r c) {</a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="cf">return</span> c + <span class="dv">2</span>*(pr(a, b, c)-c);</a>
<a class="sourceLine" id="cb8-9" title="9">}</a></code></pre></div>
<h2 id="типичные-баги">Типичные баги</h2>
<h3 id="точность">Точность</h3>
<blockquote>
<p>Первое правило действительных чисел — не использовать действительные числа</p>
</blockquote>
<p>Все переменные типа <code>double</code> хранятся в компьютере неточно (ну а как вы представите ⅓ в двоичной системе счисления?). Поэтому при работе с даблами нужно <strong>всегда</strong> учитывать эту погрешность. Например, чтобы сравнить два дабла, надо проверить, что они отличаются по модулю меньше, чем на очень маленькое число <code>eps</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="at">const</span> <span class="dt">double</span> eps = <span class="fl">1e-8</span>;</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="dt">bool</span> eq (<span class="dt">double</span> a, <span class="dt">double</span> b) { <span class="cf">return</span> abs(a-b) &lt; eps }</a></code></pre></div>
<p>Чтобы так не делать, старайтесь по возможности использовать только инты и абсолютную точность. Иногда есть трюки, позволяющие так делать: например, если в задаче все входные точки целочисленные и нас просят посчитать какую-то площадь, то можно все координаты домножить на два, и тогда ответ тоже будет целым (см. векторное произведение), который только при выводе нужно будет поделить на четыре.</p>
<h3 id="neq--0"><span class="math inline">\(0 \neq -0\)</span></h3>
<p>Действительные числа так хранятся, что <span class="math inline">\(0\)</span> и <span class="math inline">\(-0\)</span> могут быть разными числами. Имейте это ввиду.</p>
<h3 id="область-определения-обратных-функций">Область определения обратных функций</h3>
<p><code>acos</code>, <code>asin</code> и прочие обратные тригонометрические функций требуют, чтобы им на вход подавалось число от -1 до 1. Для безопасности, отмасштабируйте числа, перед тем как брать от них эти функции.</p>
</body>
</html>
