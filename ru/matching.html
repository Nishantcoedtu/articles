<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Паросочетания</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
  });
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Паросочетания</h1>
</header>
<h1 id="паросочетания">Паросочетания</h1>
<p><strong>Задача.</strong> Пусть есть <span class="math inline">\(n\)</span> мальчиков и <span class="math inline">\(m\)</span> девочек. Про каждого мальчика и про каждую девочку известно, с кем они не против танцевать. Нужно составить как можно больше пар, в которых партнёры хотят танцевать друг с другом.</p>
<p><img src="http://www.science4all.org/wp-content/uploads/2012/06/maximum_matching.png"  width="400px"></p>
<p>Формализуем эту задачу, представив мальчиков и девочек как вершины в двудольном графе, рёбрами которого будет отношение «могут танцевать вместе».</p>
<p><strong>Паросочетанием</strong> <span class="math inline">\(M\)</span> называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из <span class="math inline">\(M\)</span>).</p>
<p>Все вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном <span class="math inline">\(M\)</span>), назовём <em>насыщенными</em> этим паросочетанием.</p>
<p><em>Мощностью</em> паросочетания назовём количество рёбер в нём. <em>Наибольшим</em> (<em>максимальным</em>) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе, а <em>совершенным</em> — где все вершины левой доли им насыщенны.</p>
<p>Паросочетания <a href="http://e-maxx.ru/algo/matching_edmonds">можно искать</a> в любых графах, однако этот алгоритм неприятно кодить, и он работает за <span class="math inline">\(O(n^3)\)</span>, так что сегодня мы сфокусируемся только на двудольных графах. Будем в дальнейшем обозначать левую долю графа как <span class="math inline">\(L\)</span>, а правую долю как <span class="math inline">\(R\)</span>.</p>
<p><strong>Цепью</strong> длины <span class="math inline">\(k\)</span> назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий ровно <span class="math inline">\(k\)</span> рёбер.</p>
<p><strong>Чередующейся цепью</strong> относительно некоторого паросочетания назовём простой путь длины <span class="math inline">\(k\)</span> в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.</p>
<p><strong>Увеличивающей цепью</strong> относительно некоторого паросочетания назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/4/4a/Alternating_path.jpg" /></p>
<p><em>Здесь красными помечены вершины паросочетания, а в графе есть увеличивающая цепь: <span class="math inline">\(1 \to 8 \to 4 \to 6 \to 3 \to 7\)</span>.</em></p>
<p>Зачем нужны увеличивающие цепи? Оказывается, можно с их помощью увеличивать паросочетание на единицу (отсюда и название). Можно взять такой путь и провести <strong>чередование</strong> — убрать из паросочетания все рёбра, принадлежащие цепи, и, наоборот, добавить все остальные. Всего в увеличивающей цепи нечетное число рёбер, а первое и последнее были не в паросочетании. Значит, мощность паросочетания увеличилась ровно на единицу.</p>
<p>В примере добавятся синие рёбра <span class="math inline">\((1, 8)\)</span>, <span class="math inline">\((3, 7)\)</span> и <span class="math inline">\((4, 6)\)</span>, а удалятся красные <span class="math inline">\((3, 6)\)</span> и <span class="math inline">\((4, 8)\)</span>. С ребром <span class="math inline">\((2, 5)\)</span> ничего не случится — оно не в увеличивающей цепи. Таким образом, размер паросочетания увеличится на единицу.</p>
<p><strong>Алгоритм Куна</strong> в этом и заключается — будем искать увеличивающую цепь, пока ищется, и проводить чередование в ней. Увеличивающие цепи удобны тем, что их легко искать: можно просто запустить поиск пути из произвольной свободной вершины из левой доли в какую-нибудь свободную вершину правой доли в том же графе, но в котором из правой доли можно идти только по рёбрам паросочетания (то есть у вершин правой доли будет либо одно ребро, либо ноль). Это можно делать как угодно (для упражнения автор рекомендует явно строить такой граф, искать путь и явно проводить чередования), однако устоялась эффективная реализация в виде dfs на 20 строчек кода, приведённая ниже.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="at">const</span> <span class="dt">int</span> maxn;</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">vector&lt;<span class="dt">int</span>&gt; g[maxn]; <span class="co">// будем хранить только рёбра из левой доли в правую</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">int</span> mt[maxn]; <span class="co">// с какой вершиной сматчена вершина правой доли (-1, если ни с какой)</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">bool</span> used[maxn]; <span class="co">// вспомогательный массив для поиска пути dfs-ом</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// dfs возвращает, можно ли найти путь из вершины v</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">// в какую-нибудь вершину правой доли</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">// если можно, то ещё и проводит чередование</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="dt">bool</span> dfs(<span class="dt">int</span> v) {</a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="cf">if</span> (used[v])</a>
<a class="sourceLine" id="cb1-12" title="12">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb1-13" title="13">    used[v] = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="cf">for</span> (<span class="dt">int</span> u : g[v]) {</a>
<a class="sourceLine" id="cb1-15" title="15">        <span class="co">// если вершина свободна, то можно сразу с ней соединиться</span></a>
<a class="sourceLine" id="cb1-16" title="16">        <span class="co">// если она занята, то с ней можно соединиться только тогда,</span></a>
<a class="sourceLine" id="cb1-17" title="17">        <span class="co">// когда из её текущей пары можно найти какую-нибудь другую вершину</span></a>
<a class="sourceLine" id="cb1-18" title="18">        <span class="cf">if</span> (mt[u] == -<span class="dv">1</span> || dfs(mt[u])) {</a>
<a class="sourceLine" id="cb1-19" title="19">            mt[u] = v;</a>
<a class="sourceLine" id="cb1-20" title="20">            <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb1-21" title="21">        }</a>
<a class="sourceLine" id="cb1-22" title="22">    }</a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb1-24" title="24">}</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">// где-то в main:</span></a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29">memset(mt, -<span class="dv">1</span>, <span class="kw">sizeof</span> mt);</a>
<a class="sourceLine" id="cb1-30" title="30"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb1-31" title="31">    memset(used, <span class="dv">0</span>, <span class="kw">sizeof</span> mt);</a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="cf">if</span> (dfs(i))</a>
<a class="sourceLine" id="cb1-33" title="33">        cnt++;</a>
<a class="sourceLine" id="cb1-34" title="34">}</a></code></pre></div>
<h2 id="корректность">Корректность</h2>
<p>Для доказательства алгоритма нам будет достаточно ещё доказать, что если увеличивающие цепи уже не ищутся, то паросочетание в принципе нельзя увеличить.</p>
<p><strong>Теорема (Бержа)</strong>. Паросочетание без увеличивающих цепей является максимальным.</p>
<p><strong>Доказательство</strong> проведём от противного: пусть есть два паросочетания вершин <span class="math inline">\(|A| \leq |B|\)</span>, и для <span class="math inline">\(A\)</span> нет увеличивающих путей, и покажем, как найти этот путь и увеличить <span class="math inline">\(A\)</span> на единицу.</p>
<p>Раскрасим ребра из паросочетания, соответствующего <span class="math inline">\(A\)</span> в красный цвет, <span class="math inline">\(B\)</span> — в синий, а ребра из обоих паросочетаний — в пурпурный. Рассмотрим граф из только красных и синих ребер. Любая компонента связности в нём представляет собой либо путь, либо цикл, состоящий из чередующихся красных и синих ребер. В любом цикле будет равное число красных и синих рёбер, а так как всего синих рёбер больше, то должен существовать путь, начинающийся и оканчивающийся синим ребром — он и будет увеличивающей цепью для <span class="math inline">\(A\)</span>, а значит <span class="math inline">\(A\)</span> не оптимальное, и мы получили противоречие.</p>
<h2 id="скорость-работы">Скорость работы</h2>
<p>Такой алгоритм ровно <span class="math inline">\(n\)</span> раз ищет увеличивающий путь, каждый раз просматривая не более <span class="math inline">\(m\)</span> рёбер, а значит работает за <span class="math inline">\(O(nm)\)</span>.</p>
<p>Что примечательно, его можно не бояться запускать на ограничениях и побольше (<span class="math inline">\(n, m \approx 10^4\)</span>), потому что для него есть мощные неасимптотические оптимизации:</p>
<ul>
<li><p>Eго можно жадно инициализировать (просто заранее пройтись по вершинам левой доли и сматчить их со свободной вершиной правой, если она есть).</p></li>
<li><p>Можно не заполнять нулями на каждой итерации массив <code>used</code>, а использовать следующий трюк: хранить в нём вместо булева флага версию последнего изменения, а конкретно – номер итерации, на которой это значение стало <code>true</code>. Если этот номер меньше текущего номера итерации, то мы можем воспринимать это значение как <code>false</code>. В каком-то смысле это позволяет эмулировать очищение массива за константу.</p></li>
<li><p>Очень часто граф приходит из какой-то другой задачи, природа которой накладывает ограничения на его вид. Например, в задачах на решетках (когда есть двумерный массив, и соседние клетки связаны друг с другом) граф двудольный, но степень каждой вершины маленькая, и граф имеет очень специфичную структуру, и на нём алгоритм Куна работает быстрее, чем ожидается из формулы <span class="math inline">\(n \times m\)</span>. Контрпримеры в таких задачах на самом деле почти всегда можно сгенерировать, но авторы редко так заморачиваются.</p></li>
</ul>
<p>Вообще говоря, увлекаться ускорением алгоритма Куна не стоит — существует более асимптотически быстрый алгоритм. Задача нахождения максимального паросочетания — частный случай задачи о максимальном потоке, и если применить <a href="http://e-maxx.ru/algo/dinic">алгоритм Диница</a> к двудольным графам с единичной пропускной способностью, то выясняется, что работать он будет за <span class="math inline">\(O(n \sqrt m)\)</span>.</p>
<h2 id="покрытие-путями-dag-а">Покрытие путями DAG-а</h2>
<p>Сводить задачи к поиску максимального паросочетания обычно не очень трудно, но в некоторых случаях самому додуматься сложно. Разберём одну такую известную задачу. Дан ориентированный ациклический граф <span class="math inline">\(G\)</span> (англ. <em>directed acyclic graph</em>). Требуется покрыть его наименьшим числом путей, то есть найти наименьшее множество простых путей, где каждая вершина принадлежит ровно одному пути.</p>
<p>Построим соответствующие изначальному графу <span class="math inline">\(G\)</span> два двудольных графа <span class="math inline">\(H\)</span> и <span class="math inline">\(\overline{H}\)</span> следующим образом:</p>
<ul>
<li>В каждой доле графа <span class="math inline">\(H\)</span> будет по <span class="math inline">\(n\)</span> вершин. Обозначим их через <span class="math inline">\(a_i\)</span> и <span class="math inline">\(b_i\)</span> соответственно.</li>
<li>Для каждого ребра <span class="math inline">\((i, j)\)</span> исходного графа <span class="math inline">\(G\)</span> проведём соответствующее ребро <span class="math inline">\((a_i, b_j)\)</span> в графе <span class="math inline">\(H\)</span>.</li>
<li>Теперь из графа <span class="math inline">\(H\)</span> сделаем граф <span class="math inline">\(\overline{H}\)</span>, добавив обратное ребро <span class="math inline">\((b_i, a_i)\)</span> для каждого <span class="math inline">\(i\)</span>.</li>
</ul>
<p>Если мы рассмотрим любой путь <span class="math inline">\(v_1, v_2, \ldots, v_k\)</span> в исходном графе <span class="math inline">\(G\)</span>, то в графе <span class="math inline">\(\overline{H}\)</span> ему будет соответствовать путь <span class="math inline">\(a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, \ldots, a_{v_{k-1}}, b_{v_k}\)</span>. Обратное тоже верно: любой путь, начинающийся в левой доле <span class="math inline">\(\overline{H}\)</span> и заканчивающийся в правой будет соответствовать какому-то пути в <span class="math inline">\(G\)</span>.</p>
<p>Итак, есть взаимно однозначное соответствие между путями в <span class="math inline">\(G\)</span> и путями <span class="math inline">\(\overline{H}\)</span>, идущими из левой доли в правую. Заметим, что любой такой путь в <span class="math inline">\(\overline{H}\)</span> — это паросочетание в <span class="math inline">\(H\)</span> (напомним, это <span class="math inline">\(\overline{H}\)</span> без обратных рёбер). Получается, любому пути из <span class="math inline">\(G\)</span> можно поставить в соответствие паросочетание в <span class="math inline">\(H\)</span>, и наоборот. Более того, непересекающимся путям в <span class="math inline">\(G\)</span> соответствуют непересекающиеся паросочетания в <span class="math inline">\(H\)</span>.</p>
<p>Заметим, что если есть <span class="math inline">\(p\)</span> непересекающихся путей, покрывающих все <span class="math inline">\(n\)</span> вершин графа, то они вместе содержат <span class="math inline">\(r = n - p\)</span> рёбер. Отсюда получаем, что чтобы минимизировать число путей <span class="math inline">\(p\)</span>, мы должны максимизировать число рёбер <span class="math inline">\(r\)</span> в них.</p>
<p>Мы теперь можем свести задачу к нахождению максимального паросочетания в двудольном графе <span class="math inline">\(H\)</span>. После нахождения этого паросочетания мы должны преобразовать его в набор путей в <span class="math inline">\(G\)</span>. Это делается тривиальным алгоритмом: возьмем <span class="math inline">\(a_1\)</span>, посмотрим, с какой <span class="math inline">\(b_k\)</span> она соединена, посмотрим на <span class="math inline">\(a_k\)</span> и так далее. Некоторые вершины могут остаться ненасыщенными — в таком случае в ответ надо добавить пути нулевой длины из каждой из этих вершин.</p>
<h2 id="лемма-холла">Лемма Холла</h2>
<p><em>Лемма Холла</em> (или: <em>теорема о свадьбах</em>) — очень удобный критерий в задачах, где нужно проверить, что паросочетание существует, но при этом не требуется строить его явно.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/2/2f/Aba.gif" /></p>
<p><strong>Лемма Холла</strong>. Полное паросочетание существует тогда и только тогда, когда любая группа вершин левой доли соединена с не меньшим количеством вершин правой доли.</p>
<p><strong>Доказательство</strong>. В одну сторону понятно — если совершенное паросочетание есть, то для любого подмножества вершин левой доли можно взять вершины правой, соединенные с ним паросочетанием.</p>
<p>В другую сложнее — нужно воспользоваться индукцией. Будем доказывать, что если паросочетание не полное, то можно в таком графе найти увеличивающую цепь, и с её помощью увеличить паросочетание на единицу.</p>
<p><strong>База индукции</strong>: одна вершина из <span class="math inline">\(L\)</span>, которая по условию соединена с хотя бы одной вершиной из <span class="math inline">\(R\)</span>.</p>
<p><strong>Индукционный переход</strong>: пусть после <span class="math inline">\(k &lt; n\)</span> шагов построено паросочетание <span class="math inline">\(M\)</span>. Докажем, что в <span class="math inline">\(M\)</span> можно добавить вершину <span class="math inline">\(v\)</span> из <span class="math inline">\(L\)</span>, не насыщенную паросочетанием.</p>
<p>Рассмотрим множество вершин <span class="math inline">\(H\)</span> — все вершины, достижимые из <span class="math inline">\(x\)</span>, если можно ходить из правой доли в левую только по рёбрам паросочетания, а из левой в правую — по любым (мы такой граф по сути строим, когда ищем увеличивающую цепь в алгоритме Куна)</p>
<p>Тогда в <span class="math inline">\(H\)</span> найдется вершина <span class="math inline">\(y\)</span> из <span class="math inline">\(R\)</span>, не насыщенная паросочетанием. Иначе, если такой вершины нет, то получается, что если рассмотреть вершины <span class="math inline">\(H_L\)</span> (вершины левой доли, насыщенные паросочетанием), то для них не будет выполнено условие, что <span class="math inline">\(|H_L| \leq |N(H_L)|\)</span> (здесь <span class="math inline">\(N(X)\)</span> — множество вершин, соединенным паросочетанием с <span class="math inline">\(X\)</span>).</p>
<p>Тогда должен существовать путь из <span class="math inline">\(x\)</span> в <span class="math inline">\(y\)</span>, и он будет увеличивающим для паросочетания <span class="math inline">\(M\)</span>, потому что из <span class="math inline">\(R\)</span> в <span class="math inline">\(L\)</span> мы всегда шли только по ребрам паросочетания. Проведя чередование вдоль этого пути, получим большее паросочетание, следовательно предположение индукции верно.</p>
<h2 id="минимальное-вершинное-покрытие">Минимальное вершинное покрытие</h2>
<p><strong>Задача</strong>. Дан граф. Назовем <em>вершинным покрытием</em> такое множество вершин, что каждое ребро графа инцидентно хотя бы одной вершине из множества. Необходимо найти вершинное покрытие наименьшего размера.</p>
<p>Следует заметить, что в общем случае это очень сложная задача, но для двудольных графов она имеет достаточно простое решение.</p>
<p><strong>Теорема</strong>. <span class="math inline">\(\mid V_{min} \mid \le \mid M \mid\)</span>, где <span class="math inline">\(V_{min}\)</span> — минимальное вершинное покрытие, а <span class="math inline">\(M\)</span> — максимальное паросочетание.</p>
<p><strong>Доказательство</strong>. <span class="math inline">\(\mid V_{min} \mid \ge \mid M \mid\)</span>, поскольку <span class="math inline">\(M\)</span> — множество независимых ребер. Теперь приведем алгоритм, который строит вершинное покрытие размера <span class="math inline">\(\mid M \mid\)</span>. Очевидно, оно будет минимальным.</p>
<p><strong>Алгоритм</strong>. Мысленно ориентируем ребра графа — ребра из <span class="math inline">\(M\)</span> проведем из правой доли в левую, остальные ­— из левой в правую, после чего запустим обход в глубину из всех вершин левой доли, не включенных в <span class="math inline">\(M\)</span>.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/4/4c/Bipartdfs_right.jpg" /></p>
<p>Заметим, что граф разбился на несколько множеств: <span class="math inline">\(L^+, L^-, R^+, R^-\)</span>, где “плюсовые” множества — это множества посещенных в процессе обхода вершин. В графе такого вида не бывает ребер <span class="math inline">\(L^+ \rightarrow R^-\)</span>, <span class="math inline">\(L^- \leftarrow R^+\)</span> по очевидным соображениям. Ребер <span class="math inline">\(L^+ \leftarrow R^-\)</span> не бывает, потому что в противном случае паросочетание <span class="math inline">\(M\)</span> не максимальное — его можно дополнить ребрами такого типа.</p>
<p><span class="math display">\[
L^- \cup R^+ = V_{min}
\]</span></p>
<p>Понятно, что данное множество покроет все ребра. Осталось выяснить, почему <span class="math inline">\(L^- \cup R^+\)</span>. Это верно потому, что <span class="math inline">\(L^- \cup R^+\)</span> покрывает все ребра <span class="math inline">\(M\)</span> ровно один раз (ведь ребра <span class="math inline">\(L^- \rightarrow R^+\)</span> не принадлежат <span class="math inline">\(M\)</span>), а также потому, что в нем нет вершин, не принадлежащих <span class="math inline">\(M\)</span> (для <span class="math inline">\(L^-\)</span> это справедливо по определению, для <span class="math inline">\(R^+\)</span> можно провести доказательство от противного с использованием чередующихся цепей).</p>
<p><em>Упражнение</em>. Подумайте, как это можно применить к решению задачи о <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%B2%D1%8F%D0%B7%D1%8C_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D1%8F_%D0%B8_%D0%BD%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D0%B3%D0%BE_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0">максимальном независимом множестве</a>.</p>
<h2 id="для-ноулайферов-матроиды">Для ноулайферов: матроиды</h2>
<p>С весьма большой вероятностью матроиды вам никогда не пригодятся в школьных олимпиадах, однако, если вам совсем нечего делать, <a href="https://algorithmica.org/ru/matroid">можете про них почитать</a>.</p>
<p>Математика вообще занимается тем, что обобщает всякие объекты и старается формулировать все теоремы максимально абстрактно. Так, концепцию <em>хороших подмножеств</em> (паросочетаний) обобщает понятие <strong>матроида</strong>. Практическое применение — жадный алгоритм Радо-Эдмондса, который нужен для обоснования большого числа жадников, где нужно набрать какое-то подмножество минимального / максимального веса. Сам алгоритм максимально простой: давайте отсортируем эти объекты по весу и будем добавлять их в таком порядке в наше <em>хорошее</em> множество, если оно после добавления остается <em>хорошим</em>.</p>
<p><strong>Применимо к паросочетаниям</strong>: пусть у вершин левой доли есть вес, и нам нужно набрать максимальное паросочетание минимального веса. Тогда выясняется, что можно просто отсортировать вершины левой доли по весу и пытаться в таком порядке добавлять их в паросочетание стандартным алгоритмом Куна.</p>
</body>
</html>
