<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Паросочетания</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" type="image/x-icon" href="../favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<div id="header">
<h1 class="title">Паросочетания</h1>
</div>
<h1 id="паросочетания">Паросочетания</h1>
<p>Пусть есть <span class="math inline">\(n\)</span> мальчиков и <span class="math inline">\(m\)</span> девочек. Про каждого мальчика и про каждую девочку известно, с кем они не против танцевать. Нужно составить как можно больше пар, в которых партнёры хотят танцевать друг с другом.</p>
<p><img src="http://www.science4all.org/wp-content/uploads/2012/06/maximum_matching.png"  width="400px"></p>
<p><strong>Паросочетанием</strong> <span class="math inline">\(M\)</span> называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из <span class="math inline">\(M\)</span>).</p>
<p>Все вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном <span class="math inline">\(M\)</span>), назовём <em>насыщенными</em> этим паросочетанием.</p>
<p><em>Мощностью</em> паросочетания назовём количество рёбер в нём. <em>Наибольшим</em> (<em>максимальным</em>) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе, а <em>совершенным</em> — где все вершины левой доли им насыщенны.</p>
<p>Паросочетания <a href="http://e-maxx.ru/algo/matching_edmonds">можно искать</a> в любых графах, однако этот алгоритм неприятно кодить, и он работает за <span class="math inline">\(O(n^3)\)</span>, так что сегодня мы сфокусируемся только на двудольных графах. Будем в дальнейшем обозначать левую долю графа как <span class="math inline">\(L\)</span>, а правую долю как <span class="math inline">\(R\)</span>.</p>
<p><strong>Цепью</strong> длины <span class="math inline">\(k\)</span> назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий ровно <span class="math inline">\(k\)</span> рёбер.</p>
<p><strong>Чередующейся цепью</strong> относительно некоторого паросочетания назовём простой путь длины <span class="math inline">\(k\)</span> в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.</p>
<p><strong>Увеличивающей цепью</strong> относительно некоторого паросочетания назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.</p>
<div class="figure">
<img src="https://neerc.ifmo.ru/wiki/images/4/4a/Alternating_path.jpg" />

</div>
<p><em>Здесь красными помечены вершины паросочетания, а в графе есть увеличивающая цепь: <span class="math inline">\(1 \to 8 \to 4 \to 6 \to 3 \to 7\)</span>.</em></p>
<p>Зачем нужны увеличивающие цепи? Оказывается, можно с их помощью увеличивать паросочетание на единицу (отсюда и название). Можно взять такой путь и провести <strong>чередование</strong> — убрать из паросочетания все рёбра, принадлежащие цепи, и, наоборот, добавить все остальные. Всего в увеличивающей цепи нечетное число рёбер, а первое и последнее были не в паросочетании. Значит, мощность паросочетания увеличилась ровно на единицу.</p>
<p>В примере добавятся синие рёбра <span class="math inline">\((1, 8)\)</span>, <span class="math inline">\((3, 7)\)</span> и <span class="math inline">\((4, 6)\)</span>, а удалятся красные <span class="math inline">\((3, 6)\)</span> и <span class="math inline">\((4, 8)\)</span>. С ребром <span class="math inline">\((2, 5)\)</span> ничего не случится — оно не в увеличивающей цепи. Таким образом, размер паросочетания увеличится на единицу.</p>
<p><strong>Алгоритм Куна</strong> в этом и заключается — будем искать увеличивающую цепь, пока ищется, и проводить чередование в ней. Увеличивающие цепи удобны тем, что их легко искать: можно просто запустить поиск пути из произвольной свободной вершины из левой доли в какую-нибудь свободную вершину правой доли в том же графе, но в котором из правой доли можно идти только по рёбрам паросочетания (то есть у вершин правой доли будет либо одно ребро, либо ноль). Это можно делать как угодно (для упражнения автор рекомендует явно строить такой граф, искать путь и явно проводить чередования), однако устоялась эффективная реализация в виде dfs на 20 строчек кода, приведённая ниже.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> maxn;

vector&lt;<span class="dt">int</span>&gt; g[maxn]; <span class="co">// будем хранить только рёбра из левой доли в правую</span>
<span class="dt">int</span> mt[maxn]; <span class="co">// с какой вершиной сматчена вершина правой доли (-1, если ни с какой)</span>
<span class="dt">bool</span> used[maxn]; <span class="co">// вспомогательный массив для поиска пути dfs-ом</span>

<span class="co">// dfs возвращает, можно ли найти путь из вершины v</span>
<span class="co">// в какую-нибудь вершину правой доли</span>
<span class="co">// если можно, то ещё и проводит чередование</span>
<span class="dt">bool</span> dfs (<span class="dt">int</span> v) {
    <span class="kw">if</span> (used[v])
        <span class="kw">return</span> <span class="kw">false</span>;
    used[v] = <span class="kw">true</span>;
    <span class="kw">for</span> (<span class="dt">int</span> u : g[v]) {
        <span class="co">// если вершина свободна, то можно сразу с ней соединиться</span>
        <span class="co">// если она занята, то с нейможно соединиться только тогда,</span>
        <span class="co">// когда из её текущей пары можно найти какую-нибудь другую вершину</span>
        <span class="kw">if</span> (mt[u] == <span class="dv">-1</span> || dfs(mt[u])) {
            mt[u] = v;
            <span class="kw">return</span> <span class="kw">true</span>;
        }
    }
    <span class="kw">return</span> <span class="kw">false</span>;
}


<span class="co">// где-то в main:</span>

memset(mt, <span class="dv">-1</span>, <span class="kw">sizeof</span>(mt));
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    memset(used, <span class="dv">0</span>, <span class="kw">sizeof</span>(mt));
    <span class="kw">if</span> (dfs(i))
        cnt++;
}</code></pre></div>
<h2 id="корректность">Корректность</h2>
<p>Для доказательства алгоритма нам будет достаточно ещё доказать, что если увеличивающие цепи уже не ищутся, то паросочетание в принципе нельзя увеличить.</p>
<p><strong>Теорема (Бержа)</strong>. Паросочетание без увеличивающих цепей является максимальным.</p>
<p><strong>Доказательство</strong> проведём от противного: пусть есть два паросочетания вершин <span class="math inline">\(|A| \leq |B|\)</span>, и для <span class="math inline">\(A\)</span> нет увеличивающих путей, и покажем, как найти этот путь и увеличить <span class="math inline">\(A\)</span> на единицу.</p>
<p>Раскрасим ребра из паросочетания, соответствующего <span class="math inline">\(A\)</span> в красный цвет, <span class="math inline">\(B\)</span> — в синий, а ребра из обоих паросочетаний — в пурпурный. Рассмотрим граф из только красных и синих ребер. Любая компонента связности в нём представляет собой либо путь, либо цикл, состоящий из чередующихся красных и синих ребер. В любом цикле будет равное число красных и синих рёбер, а так как всего синих рёбер больше, то должен существовать путь, начинающийся и оканчивающийся синим ребром — он и будет увеличивающей цепью для <span class="math inline">\(A\)</span>, а значит <span class="math inline">\(A\)</span> не оптимальное, и мы получили противоречие.</p>
<h2 id="скорость-работы">Скорость работы</h2>
<p>Такой алгоритм ровно <span class="math inline">\(n\)</span> раз ищет увеличивающий путь, каждый раз просматривая не более <span class="math inline">\(m\)</span> рёбер, а значит работает за <span class="math inline">\(O(nm)\)</span>.</p>
<p>Что примечательно, его можно не бояться запускать на ограничениях и побольше (<span class="math inline">\(n, m \approx 10^4\)</span>), потому что для него есть мощные неасимптотические оптимизации:</p>
<ul>
<li><p>Eго можно жадно инициализировать (просто заранее пройтись по вершинам левой доли и сматчить их со свободной вершиной правой, если она есть).</p></li>
<li><p>Можно не заполнять нулями на каждой итерации массив <code>used</code>, а использовать следующий трюк: хранить в нём вместо булева флага версию последнего изменения, а конкретно -- номер итерации, на которой это значение стало <code>true</code>. Если этот номер меньше текущего номера итерации, то мы можем воспринимать это значение как <code>false</code>. В каком-то смысле это позволяет эмулировать очищение массива за константу.</p></li>
<li><p>Очень часто граф приходит из какой-то другой задачи, природа которой накладывает ограничения на его вид. Например, в задачах на решетках (когда есть двумерный массив, и соседние клетки связаны друг с другом) граф двудольный, но степень каждой вершины маленькая, и граф имеет очень специфичную структуру, и на нём алгоритм Куна работает быстрее, чем ожидается из формулы <span class="math inline">\(n \times m\)</span>. Контрпримеры в таких задачах на самом деле почти всегда можно сгенерировать, но авторы редко так заморачиваются.</p></li>
</ul>
<p>Вообще говоря, увлекаться ускорением алгоритма Куна не стоит — существует более асимптотически быстрый алгоритм. Задача нахождения максимального паросочетания — частный случай задачи о максимальном потоке, и если применить <a href="http://e-maxx.ru/algo/dinic">алгоритм Диница</a> к двудольным графам с единичной пропускной способностью, то выясняется, что работать он будет за <span class="math inline">\(O(n \sqrt m)\)</span>.</p>
<h2 id="покрытие-путями-dag-а">Покрытие путями DAG-а</h2>
<p>Сводить задачи к поиску максимального паросочетания обычно не очень трудно, но в некоторых случаях самому додуматься сложно. Разберём одну такую известную задачу. Дан ориентированный ациклический граф <span class="math inline">\(G\)</span> (англ. <em>directed acyclic graph</em>). Требуется покрыть его наименьшим числом путей, то есть найти наименьшее множество простых путей, где каждая вершина принадлежит ровно одному пути.</p>
<p>Построим соответствующие изначальному графу <span class="math inline">\(G\)</span> два двудольных графа <span class="math inline">\(H\)</span> и <span class="math inline">\(\overline{H}\)</span> следующим образом: * В каждой доле графа <span class="math inline">\(H\)</span> будет по <span class="math inline">\(n\)</span> вершин. Обозначим их через <span class="math inline">\(a_i\)</span> и <span class="math inline">\(b_i\)</span> соответственно. * Для каждого ребра <span class="math inline">\((i, j)\)</span> исходного графа <span class="math inline">\(G\)</span> проведём соответствующее ребро <span class="math inline">\((a_i, b_j)\)</span> в графе <span class="math inline">\(H\)</span>. * Теперь из графа <span class="math inline">\(H\)</span> сделаем граф <span class="math inline">\(\overline{H}\)</span>, добавив обратное ребро <span class="math inline">\((b_i, a_i)\)</span> для каждого <span class="math inline">\(i\)</span>.</p>
<p>Если мы рассмотрим любой путь <span class="math inline">\(v_1, v_2, \ldots, v_k\)</span> в исходном графе <span class="math inline">\(G\)</span>, то в графе <span class="math inline">\(\overline{H}\)</span> ему будет соответствовать путь <span class="math inline">\(a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, \ldots, a_{v_{k-1}}, b_{v_k}\)</span>. Обратное тоже верно: любой путь, начинающийся в левой доле <span class="math inline">\(\overline{H}\)</span> и заканчивающийся в правой будет соответствовать какому-то пути в <span class="math inline">\(G\)</span>.</p>
<p>Итак, есть взаимно однозначное соответствие между путями в <span class="math inline">\(G\)</span> и путями <span class="math inline">\(\overline{H}\)</span>, идущими из левой доли в правую. Заметим, что любой такой путь в <span class="math inline">\(\overline{H}\)</span> — это паросочетание в <span class="math inline">\(H\)</span> (напомним, это <span class="math inline">\(\overline{H}\)</span> без обратных рёбер). Получается, любому пути из <span class="math inline">\(G\)</span> можно поставить в соответствие паросочетание в <span class="math inline">\(H\)</span>, и наоборот. Более того, непересекающимся путям в <span class="math inline">\(G\)</span> соответствуют непересекающиеся паросочетания в <span class="math inline">\(H\)</span>.</p>
<p>Заметим, что если есть <span class="math inline">\(p\)</span> непересекающихся путей, покрывающих все <span class="math inline">\(n\)</span> вершин графа, то они вместе содержат <span class="math inline">\(r = n - p\)</span> рёбер. Отсюда получаем, что чтобы минимизировать число путей <span class="math inline">\(p\)</span>, мы должны максимизировать число рёбер <span class="math inline">\(r\)</span> в них.</p>
<p>Мы теперь можем свести задачу к нахождению максимального паросочетания в двудольном графе <span class="math inline">\(H\)</span>. После нахождения этого паросочетания мы должны преобразовать его в набор путей в <span class="math inline">\(G\)</span>. Это делается тривиальным алгоритмом: возьмем <span class="math inline">\(a_1\)</span>, посмотрим, с какой <span class="math inline">\(b_k\)</span> она соединена, посмотрим на <span class="math inline">\(a_k\)</span> и так далее. Некоторые вершины могут остаться ненасыщенными — в таком случае в ответ надо добавить пути нулевой длины из каждой из этих вершин.</p>
<h2 id="лемма-холла">Лемма Холла</h2>
<p><em>Лемма Холла</em> (или: <em>теорема о свадьбах</em>) — очень удобный критерий в задачах, где нужно проверить, что паросочетание существует, но при этом не требуется строить его явно.</p>
<div class="figure">
<img src="https://neerc.ifmo.ru/wiki/images/2/2f/Aba.gif" />

</div>
<p><strong>Лемма Холла</strong>. Полное паросочетание существует тогда и только тогда, когда любая группа вершин левой доли соединена с не меньшим количеством вершин правой доли.</p>
<p><strong>Доказательство</strong>. В одну сторону понятно — если совершенное паросочетание есть, то для любого подмножества вершин левой доли можно взять вершины правой, соединенные с ним паросочетанием.</p>
<p>В другую сложнее — нужно воспользоваться индукцией. Будем доказывать, что если паросочетание не полное, то можно в таком графе найти увеличивающую цепь, и с её помощью увеличить паросочетание на единицу.</p>
<p><strong>База индукции</strong>: одна вершина из <span class="math inline">\(L\)</span>, которая по условию соединена с хотя бы одной вершиной из <span class="math inline">\(R\)</span>.</p>
<p><strong>Индукционный переход</strong>: пусть после <span class="math inline">\(k &lt; n\)</span> шагов построено паросочетание <span class="math inline">\(M\)</span>. Докажем, что в <span class="math inline">\(M\)</span> можно добавить вершину <span class="math inline">\(v\)</span> из <span class="math inline">\(L\)</span>, не насыщенную паросочетанием.</p>
<p>Рассмотрим множество вершин <span class="math inline">\(H\)</span> — все вершины, достижимые из <span class="math inline">\(x\)</span>, если можно ходить из правой доли в левую только по рёбрам паросочетания, а из левой в правую — по любым (мы такой граф по сути строим, когда ищем увеличивающую цепь в алгоритме Куна)</p>
<p>Тогда в <span class="math inline">\(H\)</span> найдется вершина <span class="math inline">\(y\)</span> из <span class="math inline">\(R\)</span>, не насыщенная паросочетанием. Иначе, если такой вершины нет, то получается, что если рассмотреть вершины <span class="math inline">\(H_L\)</span> (вершины левой доли, насыщенные паросочетанием), то для них не будет выполнено условие, что <span class="math inline">\(|H_L| \leq |N(H_L)|\)</span> (здесь <span class="math inline">\(N(X)\)</span> — множество вершин, соединенным паросочетанием с <span class="math inline">\(X\)</span>).</p>
<p>Тогда должен существовать путь из <span class="math inline">\(x\)</span> в <span class="math inline">\(y\)</span>, и он будет увеличивающим для паросочетания <span class="math inline">\(M\)</span>, потому что из <span class="math inline">\(R\)</span> в <span class="math inline">\(L\)</span> мы всегда шли только по ребрам паросочетания. Проведя чередование вдоль этого пути, получим большее паросочетание, следовательно предположение индукции верно.</p>
<h2 id="для-ноулайферов-матроиды">Для ноулайферов: матроиды</h2>
<p>С весьма большой вероятностью матроиды вам никогда не пригодится в школьных олимпиадах, однако, если вам совсем нечего делать, <a href="http://sereja.me/a/matroid">можете про них почитать</a>.</p>
<p>Математика вообще занимается тем, что обобщает всякие объекты и старается формулировать все теоремы максимально абстрактно. Так, концепцию <em>хороших подмножеств</em> (паросочетаний) обобщает понятие <strong>матроида</strong>. Практическое применение — жадный алгоритм Радо-Эдмондса, который нужен для обоснования большого числа жадников, где нужно набрать какое-то подмножество минимального / максимального веса. Сам алгоритм максимально простой: давайте отсортируем эти объекты по весу и будем добавлять их в таком порядке в наше <em>хорошее</em> множество, если оно после добавления остается <em>хорошим</em>.</p>
<p><strong>Применимо к паросочетаниям</strong>: пусть у вершин левой доли есть вес, и нам нужно набрать максимальное паросочетание минимального веса. Тогда выясняется, что можно просто отсортировать вершины левой доли по весу и пытаться в таком порядке добавлять их в паросочетание стандартным алгоритмом Куна.</p>
</body>
</html>
