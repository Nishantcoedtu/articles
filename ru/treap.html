<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Декартово дерево</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" type="image/x-icon" href="../favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" >
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<div id="header">
<h1 class="title">Декартово дерево</h1>
</div>
<h1 id="декартово-дерево">Декартово дерево</h1>
<p>Рене Декарт (фр. <em>René Descartes</em>) — великий французский математик и философ XVII века.</p>
<p>Рене Декарт не является создателем декартова дерева, но он является создателем декартовой системы координат, которую мы все знаем и любим.</p>
<p>Декартово дерево же определяется и строится так:</p>
<ul>
<li>Нанесём на плоскость набор из <span class="math inline">\(n\)</span> точек. Их <span class="math inline">\(x\)</span> зачем-то назовем <em>ключем</em>, а <span class="math inline">\(y\)</span> <em>приоритетом</em>.</li>
<li>Выберем самую верхнюю точку (с наибольшим <span class="math inline">\(y\)</span>, а если таких несколько — любую) и назовём её <em>корнем</em>.</li>
<li>От всех вершин, лежащих слева (с меньшим <span class="math inline">\(x\)</span>) от корня, рекурсивно запустим этот же процесс. Если слева была хоть одна вершина, то присоединим корень левой части в качестве левого сына текущего корня.</li>
<li>Аналогично, запустимся от правой части и добавим корню правого сына.</li>
</ul>
<p>Заметим, что если все <span class="math inline">\(y\)</span> и <span class="math inline">\(x\)</span> различны, то дерево строится однозначно.</p>
<p>Если нарисовать получившуюся структуру на плоскости, то получится действительно дерево — по традиции, корнем вверх:</p>
<div class="figure">
<img src="https://hsto.org/storage/habraeffect/a1/0a/a10a744def8f325a1019502ecc175ef6.png" alt="treap" />
<p class="caption">treap</p>
</div>
<p>Таким образом, декартово дерево — это одновременно <em>бинарное дерево</em> по <span class="math inline">\(x\)</span> и <em>куча</em> по <span class="math inline">\(y\)</span>. Поэтому ему придумали много альтернативных названий:</p>
<ul>
<li>Дерамида (дерево + пирамида)</li>
<li>ПиВо (пирамида + дерево)</li>
<li>КуРево (куча + дерево)</li>
<li>Treap (tree + heap)</li>
</ul>
<p>## Бинарные деревья</p>
<p>С небольшими модификациями, декартово дерево умеет всё то же, что и любое <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">бинарное дерево поиска</a>, например:</p>
<ul>
<li>добавить число <span class="math inline">\(x\)</span> в множество</li>
<li>определить, есть ли в множестве число <span class="math inline">\(x\)</span></li>
<li>найти первое число, не меньшее <span class="math inline">\(x\)</span> (<code>lower_bound</code>)</li>
<li>найти количество чисел в промежутке <span class="math inline">\([l, r]\)</span></li>
</ul>
<p>При этом все операции — за <span class="math inline">\(O(\log n)\)</span>.</p>
<p>На самом деле, бинарных деревьев очень много. В большинстве из них время выполнения операций пропорционально высоте дерева, поэтому в них придумываются разные инварианты, позволяющие эту высоту минимизировать до <span class="math inline">\(O(\log n)\)</span>.</p>
<h2 id="приоритеты-и-асимптотика">Приоритеты и асимптотика</h2>
<p>В декартовом дереве логарифмическая высота дерева гарантируется не инвариантами и эвристиками, а законами теории вероятностей: оказывается, что если все приоритеты (<span class="math inline">\(y\)</span>) выбирать случайно, то средняя глубина вершины будет логарифмической. Поэтому ДД ещё называют рандомизированным деревом поиска.</p>
<p><strong>Теорема</strong>. Ожидание глубины вершины в декартовом дереве равно <span class="math inline">\(O(n \log n)\)</span>.</p>
<p>Если не знаете, что такое ожидание, то на доказательство забейте: это будет на занятии по теорверу в конце года. Сейчас его можно пропустить.</p>
<p><strong>Доказательство</strong><em>. Введем функцию <span class="math inline">\(a(x, y)\)</span> равную единице, если <span class="math inline">\(x\)</span> является предком <span class="math inline">\(y\)</span>, и нулем в противном случае. Такие функции называются </em>индикаторами*.</p>
<p>Глубина вершины равна количеству её предков — прим. К. О. Таким образом, она равна</p>
<p><span class="math display">\[d_i = \sum_{j=1}^n a(j, i)\]</span></p>
<p>Её матожидание равно</p>
<p><span class="math display">\[E[d_i] = E[\sum_{j \neq i} a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} p(j, i)\]</span></p>
<p>где <span class="math inline">\(p(x, y)\)</span> это веряотность, что <span class="math inline">\(a(x, y) = 1\)</span>. Здесь мы воспользовались важным свойством <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D0%BE%D0%B9_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D1%8B#.D0.9B.D0.B8.D0.BD.D0.B5.D0.B9.D0.BD.D0.BE.D1.81.D1.82.D1.8C_.D0.BC.D0.B0.D1.82.D0.B5.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BE.D0.B6.D0.B8.D0.B4.D0.B0.D0.BD.D0.B8.D1.8F">линейности</a>: матожидание суммы чего угодно равна сумме матожиданий этого чего угодно.</p>
<p>Ок, теперь осталось посчитать эти вероятности и сложить. Но сначала нам понадобится вспомогательное утверждение.</p>
<p><strong>Лемма</strong>. Вершина <span class="math inline">\(x\)</span> является предком <span class="math inline">\(y\)</span>, если у неё приоритет больше, чем у всех вершин из отрезка <span class="math inline">\((x, y]\)</span> (без ограничения общности, будем считать, что <span class="math inline">\(x &lt; y\)</span>).</p>
<p><strong>Необходимость</strong>. Если это не так, то где-то между <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> есть вершина с большим приоритетом, чем <span class="math inline">\(x\)</span>. Она не может быть потомком <span class="math inline">\(x\)</span>, а значит <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> будут разделены.</p>
<p><strong>Достаточность</strong>. Если справа будет какая-то вершина с большим приоритетом, то её левым сыном будет какая-то вершина, которая будет являться предком <span class="math inline">\(x\)</span>. Таким образом, всё, что справа от <span class="math inline">\(y\)</span>, ни на что влиять не будет.</p>
<p>У всех вершин на любом отрезке одинаковая вероятность иметь наибольший приоритет. Объединяя этот факт с результатом леммы, мы можем получить выражение для искомых вероятностей:</p>
<p><span class="math display">\[p(x, y) = \frac{1}{y-x+1}\]</span></p>
<p>Теперь, чтобы найти матожидание, эти вероятности надо просуммировать:</p>
<p><span class="math display">\[E[d_i] = \sum_{j \neq i} p(j, i) = \sum_{j \neq i} \frac{1}{|i-j|+1} \leq \sum_{i=1}^n \frac{1}{n} = O(\log n)\]</span></p>
<p>Перед последним переходом мы получили сумму гармонического ряда.</p>
<p>Примечательно, что ожидаемая глубина вершин зависит от их позиции: вершина из середины должна быть примерно в два раза глубже, чем крайняя.</p>
<p><strong>Упражнение</strong>*. Выведите из этого доказательства асимптотику <code>quicksort</code>.</p>
<h2 id="реализация">Реализация</h2>
<p>Декартово дерево удобно писать на указателях и структурах. Поэтому мы <a href="http://sereja.me/a/segtree">рассказали</a> дерево отрезков на указателях, а не стандартную <a href="http://e-maxx.ru/algo/segment_tree">рекурсию на 5 параметрах</a>. Не знаете, что это такое — посмотрите в предыдущем конспекте.</p>
<p>Создадим структуру <code>Node</code>, в которой будем хранить ключ и приоритет, а также указатели на левого и правого сына. Указателя на корень дерева достаточно для идентификации всего дерева. Поэтому, когда мы будем говорить «функция принимает два дерева» на самом деле будут иметься в виду указатели на их корни. К нулевому указателю же мы будем относиться, как к «пустому» дереву.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
    <span class="dt">int</span> key, prior;
    Node *l = <span class="dv">0</span>, *r = <span class="dv">0</span>;
    Node (<span class="dt">int</span> _key) { key = _key, prior = rand(); }
};</code></pre></div>
<p>Объявим две вспомогательные функции, изменяющие структуру деревьев: одна будет разделять деревья, а другая объединять. Как мы увидим, через них можно легко выразить почти все функции, которые нам потом понадобятся.</p>
<h3 id="merge">Merge</h3>
<p>Принимает два дерева (два корня, <span class="math inline">\(L\)</span> и <span class="math inline">\(R\)</span>), про которые известно, что в левом все вершины имеют меньший ключ, чем все в правом. Их нужно объединить в одно дерево так, чтобы ничего не сломалось: по ключам это всё ещё дерево, а по приоритетами — куча.</p>
<p>Сначала выберем, какая вершина будет корнем. Здесь всего два кандидата — левый корень <span class="math inline">\(L\)</span> или правый <span class="math inline">\(R\)</span> — просто возьмем тот, у кого приоритет больше.</p>
<p>Пусть, для однозначности, это был левый корень. Тогда левый сын корня итогового дерева должен быть левым сыном <span class="math inline">\(L\)</span>. С правым сыном сложнее: возможно, его нужно смерджить с <span class="math inline">\(R\)</span>. Поэтому рекурсивно сделаем <code>merge(l-&gt;r, r)</code> и запишем результат в качестве правого сына.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node* merge (Node *l, Node *r) {
    <span class="kw">if</span> (!l) <span class="kw">return</span> r;
    <span class="kw">if</span> (!r) <span class="kw">return</span> l;
    <span class="kw">if</span> (l-&gt;prior &gt; r-&gt;prior) {
        l-&gt;r = merge(l-&gt;r, r);
        <span class="kw">return</span> l;
    }
    <span class="kw">else</span> {
        r-&gt;l = merge(l, r-&gt;l);
        <span class="kw">return</span> r;
    }
}</code></pre></div>
<h3 id="split">Split</h3>
<p>Принимает дерево и ключ <span class="math inline">\(x\)</span>, по которому его нужно разделить на два: <span class="math inline">\(L\)</span> должно иметь все ключи не больше <span class="math inline">\(x\)</span>, а <span class="math inline">\(R\)</span> должно иметь все ключи больше <span class="math inline">\(x\)</span>.</p>
<p>В этой функции мы сначала решим, в каком из деревьев должен быть корень, а потом рекурсивно разделим его правую или левую половину и присоединим, куда надо:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;Node*, Node*&gt; Pair;

Pair split (Node *p, <span class="dt">int</span> x) {
    <span class="kw">if</span> (!p) <span class="kw">return</span> {<span class="dv">0</span>, <span class="dv">0</span>};
    <span class="kw">if</span> (p-&gt;key &lt;= x) {
        Pair q = split(p-&gt;r, x);
        p-&gt;r = q.first;
        <span class="kw">return</span> {p, q.second};
    }
    <span class="kw">else</span> {
        Pair q = split(p-&gt;l, x);
        p-&gt;l = q.second;
        <span class="kw">return</span> {q.first, p};
    }
}</code></pre></div>
<h3 id="пример-вставка">Пример: вставка</h3>
<p><code>merge</code> и <code>split</code> сами по себе не очень полезные, но помогут написать все остальное.</p>
<p>Вот так, например, будет выглядеть код, добавляющий <span class="math inline">\(x\)</span> в сет.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node *root = <span class="dv">0</span>;

<span class="dt">void</span> insert (<span class="dt">int</span> x) {
    Pair q = split(root, x);
    Node *t = <span class="kw">new</span> Node(x);
    root = merge(q.first, merge(t, q.second));
}</code></pre></div>
<h3 id="пример-модификация-для-суммы-на-отрезке">Пример: модификация для суммы на отрезке</h3>
<p>Иногда нам нужно написать какие-то модификации для более продвинутых операций.</p>
<p>Например, нам может быть интересно иногда считать сумму чисел на отрезке. Для этого в вершине нужно хранить также своё число и сумму на своем «отрезке».</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
    <span class="dt">int</span> val, sum;
    <span class="co">// ...</span>
};</code></pre></div>
<p>При <code>merge</code> и <code>split</code> надо будет поддерживать эту сумму актуальной.</p>
<p>Вместо того, чтобы модифицировать и <code>merge</code>, и <code>split</code> под наши хотелки, напишем вспомогательные функцию <code>upd</code>, которую будем вызывать при обновлении детей вершины.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sum (Node* v) { <span class="kw">return</span> v ? v-&gt;sum : <span class="dv">0</span>; }
<span class="co">// обращаться по пустому указателю нельзя -- выдаст ошибку</span>

<span class="dt">void</span> upd (Node* v) { v-&gt;sum = sum(v-&gt;l) + sum(v-&gt;r) + v-&gt;val; }</code></pre></div>
<p>В <code>merge</code> и <code>split</code> теперь можно просто вызывать <code>upd</code> перед тем, как вернуть вершину, и тогда ничего не сломается:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node* merge (Node *l, Node *r) {
    <span class="co">// ...</span>
    <span class="kw">if</span> (...) {
        l-&gt;r = merge(l-&gt;r, r);
        upd(l);
        <span class="kw">return</span> l;
    }
    <span class="kw">else</span> {
        <span class="co">// ...</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;Node*, Node*&gt; Pair;

Pair split (Node *p, <span class="dt">int</span> x) {
    <span class="co">// ...</span>
    <span class="kw">if</span> (...) {
        <span class="co">// ...</span>
        upd(p);
        <span class="kw">return</span> {p, q.second};
    }
    <span class="kw">else</span> {
        <span class="co">// ...</span>
    }
}</code></pre></div>
<p>Тогда при запросе суммы нужно просто вырезать нужный отрезок и запросить эту сумму:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> sum (<span class="dt">int</span> l, <span class="dt">int</span> r) {
    Pair rq = split(root, r);
    Pair lq = split(rq.first, l);
    <span class="dt">int</span> res = sum(lr.second);
    root = merge(lq.first, merge(lq.second, rq.second));
    <span class="kw">return</span> res;
}</code></pre></div>
<h1 id="неявный-ключ">Неявный ключ</h1>
<p>Обычное декартово дерево — это структура для множеств, каждый элемент которых имеет какой-то ключ. Эти ключи задают на этом множестве какой-то порядок, и все запросы к ДД обычно как-то привязаны к этому порядку.</p>
<p>Но что, если у нас есть запросы, которые этот порядок как-то нетривиально меняют? Например, если у нас есть массив, в котором нужно уметь выводить сумму на произвольном отрезке и «переворачивать» произвольный отрезок. Если бы не было второй операции, мы бы просто использовали индекс элемента в качестве ключа, но с операцией переворота нет способа их быстро поддерживать актуальными.</p>
<p>Решение такое: выкинем ключи, а вместо них будем поддерживать информацию, которая поможет неявно восстановить ключ, когда он нам будет нужен. А именно, будем хранить вместе с каждой вершиной размер её поддерева:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
    <span class="dt">int</span> key, prior, size = <span class="dv">1</span>;
    <span class="co">//              ^ размер поддерева</span>
    Node *l = <span class="dv">0</span>, *r = <span class="dv">0</span>;
    Node (<span class="dt">int</span> _key) { key = _key, prior = rand(); }
};</code></pre></div>
<p>Размеры поддеревьев будем поддерживать по аналогии с суммой — напишем вспомогательную функцию, которую будем вызывать после каждого структурного изменения вершины.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> size (Node *v) { <span class="kw">return</span> v ? v-&gt;size : <span class="dv">0</span>; }

<span class="dt">void</span> upd (Node *v) { v-&gt;size = <span class="dv">1</span> + size(v-&gt;l) + size(v-&gt;r); }</code></pre></div>
<p><code>merge</code> не меняется, а вот в <code>split</code> нужно использовать позицию корня вместо его ключа.</p>
<p>Про <code>split</code> теперь удобнее думать как &quot;вырежи первые <code>k</code> элементов&quot;.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> pair&lt;Node*, Node*&gt; Pair;

Pair split (Node *p, <span class="dt">int</span> k) {
    <span class="kw">if</span> (!p) <span class="kw">return</span> {<span class="dv">0</span>, <span class="dv">0</span>};
    <span class="kw">if</span> (size(p-&gt;l) + <span class="dv">1</span> &lt;= k) {
        Pair q = split(p-&gt;r, k - size(p-&gt;l) - <span class="dv">1</span>);
        <span class="co">//                   ^ правый сын не знает количество вершин слева от него</span>
        p-&gt;r = q.first;
        upd(p);
        <span class="kw">return</span> {p, q.second};
    }
    <span class="kw">else</span> {
        Pair q = split(p-&gt;l, k);
        p-&gt;l = q.second;
        upd(p);
        <span class="kw">return</span> {q.first, p};
    }
}</code></pre></div>
<p>Всё. Теперь у нас есть клёвая гибкая структура, которую можно резать как угодно.</p>
<h3 id="пример-ctrlx-ctrlv">Пример: ctrl+x, ctrl+v</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node* ctrlx (<span class="dt">int</span> l, <span class="dt">int</span> r) {
    Pair q1 = split(root, r);
    Pair q2 = split(q1.first, l);
    root = merge(q2.first, q1.second);
    <span class="kw">return</span> q2.second;
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ctrlv (Node *v, <span class="dt">int</span> k) {
    Pair q = split(root, k);
    root = merge(q.first, merge(v, q.second));
}</code></pre></div>
<h3 id="пример-переворот">Пример: переворот</h3>
<p>Нужно за <span class="math inline">\(O(\log n)\)</span> обрабатывать запросы переворота произвольных подстрок: значение <span class="math inline">\(a_l\)</span> поменять с <span class="math inline">\(a_r\)</span>, <span class="math inline">\(a_{l+1}\)</span> поменять с <span class="math inline">\(a_{r-1}\)</span> и т. д.</p>
<p>Будем хранить в кажой вершине флаг, который будет означать, что её подотрезок перевернут:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
    <span class="dt">bool</span> rev;
    <span class="co">// ...</span>
};</code></pre></div>
<p>Поступим по аналогии с ДО — когда мы когда-либо встретим такую вершину, мы поменяем ссылки на её детей, а им самим передадим эту метку:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> push (node *v) {
    <span class="kw">if</span> (v-&gt;rev) {
        swap(v-&gt;l, v-&gt;r);
        <span class="kw">if</span> (v-&gt;l)
            v-&gt;rev ^= <span class="dv">1</span>;
        <span class="kw">if</span> (v-&gt;r)
            v-&gt;rev ^= <span class="dv">1</span>;
    }
    v-&gt;rev = <span class="dv">0</span>;
}</code></pre></div>
<p>Аналогично, эту функцию будем вызывать в начале <code>merge</code> и <code>split</code>.</p>
<p>Саму функцию <code>reverse</code> реализуем так: вырезать нужный отрезок, поменять флаг.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reverse (<span class="dt">int</span> l, <span class="dt">int</span> r) {
    Pair q1 = split(root, r);
    Pair q2 = split(q1.first, l)
    q2.second-&gt;rev ^= <span class="dv">1</span>;
    root = merge(q2.first, merge(q2.second, q1.second));
}</code></pre></div>
<h1 id="функциональное-программирование">Функциональное программирование*</h1>
<p>Реализация большинства операций всегда примерно одинаковая — вырезаем отрезок с <span class="math inline">\(l\)</span> по <span class="math inline">\(r\)</span>, что-то с ним делаем и склеиваем обратно.</p>
<p>Дублирующийся код — это плохо. Давайте используем всю мощь плюсов и определим функцию, которая принимает другую функцию, которая уже делает полезные вещи на нужном отрезке.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> apply (<span class="dt">int</span> l, <span class="dt">int</span> r, <span class="kw">auto</span> f) {
    Pair q1 = split(root, r);
    Pair q2 = split(q1.first, l)
    q2.second = f(q2.second);
    root = merge(q2.first, merge(q2.second, q1.second));
}

<span class="dt">void</span> reverse (Node *v) {
    <span class="kw">if</span> (v)
        v-&gt;rev ^= <span class="dv">1</span>;
}</code></pre></div>
<p>Применять её нужно так:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">apply(l, r, reverse);</code></pre></div>
<p>Это работает в плюсах, начиная с <code>g++14</code>.</p>
<p>Для простых операций можно даже написать лямбду:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">apply(l, r, [](Node *v){
    <span class="kw">if</span> (v)
        v-&gt;rev ^= <span class="dv">1</span>;
});</code></pre></div>
<h1 id="персистентность">Персистентность*</h1>
<p>Так же, как и с ДО, персистентной версией ДД можно решать очень интересные задачи.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления и вставки в произвольные позиции.</p>
</blockquote>
<p>Построим персистентное ДД. Тогда просто вызвав два <code>split</code>-а, мы можем получить копию любой подстроки (указатель вершину), которую потом можно вставлять куда угодно, при этом оригинальную подстроку мы не изменим.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления, вставки в произвольные позиции <strong>и сравнение произвольных подстрок</strong>.</p>
</blockquote>
<p>Можно в вершинах хранить <strong>полиномиальный хэш</strong> соответствующей подстроки. Тогда мы можем проверять равенство подстрок сравниванием хэшей вершин, полученных теми же двумя сплитами.</p>
<p>Чтобы полноценно сравнивать стоки лексикографически, можно применить бинарный поиск: перебрать длину совпадающего суффикса, и, когда она найдется, посмотреть на следующий символ.</p>
<p>Реализация почти такая же, как и для всех персистентных структур на ссылках — перед тем, как идти в какую-то вершину, нужно создать её копию и идти в неё. Создадим для этого вспомогательную функцию <code>copy</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node* copy (Node *v) { <span class="kw">return</span> <span class="kw">new</span> Node(*v); }</code></pre></div>
<p>Во всех методах мы будем начинать с копирования всех упоминаемых в ней вершин. Например, персистентный <code>split</code> начнётся так:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Pair split (Node *p, <span class="dt">int</span> x) {
    p = copy(p);
    <span class="co">// ...</span>
}</code></pre></div>
<p>В ДО просто создавать копии вершин было достаточно. Этого обычно достаточно для всех детерминированных структур данных, но в ДД всё сложнее. Оказывается существует тест, который «валит» приоритеты: можно раскопировать много версий одной вершины, а все остальные — удалить. Тогда у всех вершин будет один и тот же приоритет, и дерево превратится в «бамбук», в котором все операции будут работать за линию.</p>
<p>У этой проблемы есть очень элегантное решение — избавиться от приоритетов, и делать теперь следующее переподвешивание: если размер левого дерева равен <span class="math inline">\(L\)</span>, а размер правого <span class="math inline">\(R\)</span>, то будем подвешивать за левое с вероятностью <span class="math inline">\(\frac{L}{L+R}\)</span>, иначе за правое.</p>
<p><strong>Теорема</strong>. Такое переподвешивание эквивалентно приоритетам.</p>
<p><strong>Доказательство</strong>. Покажем, что все вершины всё так же имеют равную вероятность быть корнем. Докажем по индукции:</p>
<ul>
<li>Лист имеет вероятность 1 быть корнем себя (база индукции)</li>
<li>Переход индукции — операция <code>merge</code>. Любая вершина левого дерева была корнем с вероятностью <span class="math inline">\(\frac{1}{L}\)</span> (по предположению индукции), а после слияния она будет корнем всего дерева с вероятностью <span class="math inline">\(\frac{1}{L} \cdot \frac{L}{L+R} = \frac{1}{L+R}\)</span>. С вершинами правого дерева аналогично.</li>
</ul>
<p>Получается, что при таком переподвешивании всё так же каждая вершина любого поддерева равновероятно могла быть его корнем, а на этом основывалось наше доказательство асимптотики ДД.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Node* merge (Node *l, Node *r) {
    <span class="kw">if</span> (!l) <span class="kw">return</span> r;
    <span class="kw">if</span> (!r) <span class="kw">return</span> l;
    l = copy(l), r = copy(r);
    <span class="kw">if</span> (rand() % (size(l) + size(r)) &lt; size(l)) {
        <span class="co">// ...</span>
    }
    <span class="kw">else</span> {
        <span class="co">// ...</span>
    }
}</code></pre></div>
<p>Философский вопрос: можно ли декартово дерево называть декартовым, если из него удалить и <span class="math inline">\(x\)</span>, и <span class="math inline">\(y\)</span>?</p>
</body>
</html>
