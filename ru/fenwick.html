<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
<div style="border: 1px solid #A7A; border-left: 7px solid rgb(204, 153, 204); padding: 6px; padding-left: 8px; padding-bottom: 6px; font-size: 14px; line-height: 1.5em">
<img src="http://lurkmore.so/images/e/e1/Nohate.jpg" /> <strong>НЯ!</strong><br />
Эта статья полна любви и обожания.<br />
Возможно, стоит добавить <a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">ещё больше</a>?
</div>
# Дерево Фенвика Дерево Фенвика или бинарно индеквированное дерево (англ. *binary indexed tree*) — структура данных, которая на многих (но не всех) задачах заменяет собой дерево отрезков, но при этом работает в 3-4 раза быстрее, занимает минимально возможное количество памяти (столько же, скоько массив такой же длины), намного быстрее пишется и легче обобщается на большие размерности. ## Определение Пусть дан массив $a$ длины $n$. Деревом Фенвика будем называть массив $t$ той же длины, который объявим так: $$ t_i = \sum_{k=F(i)}^i a_k $$ где $F$ это какая-то функцию, для которой выполнено $F(i) \leq i$. Конкретно её определим потом. Когда нам нужна сумма на отрезке, мы будем сводить этот запрос к двум суммам на префиксе ($sum(l, r) = sum(r) - sum(l-1)$), каждый из которых будем считать по этой формуле: $$ sum(k) = t_k + sum(F(k)-1) $$ Когда мы изменяем $k$-ю ячейку исходного массива, мы обновляем все $t_i$, в которых учтена эта ячейка. $F$ можно выбрать так, что и «спусков» при подсчете суммы, и интересных нам $t_i$ при обновлении будет будет $O(\log n)$. Популярны две функции: * $F_1(x) =$ `x &amp; (x + 1)` * $F_2(x) =$ `x - (x &amp; -x) + 1` Первый вариант описан на викиконспектах и емаксе и поэтому более известен. Второй, как мы дальше увидим, более простой для запоминания и кодинга, а так же более гибкий — например, там можно делать бинпоиск по префиксным суммам. Его мы и будем использовать. **Disclaimer**: наверное, меньше четверти умеющих писать эту структуру полностью понимают, как она работает. Анализ действительно весьма сложный, поэтому мы приведём его в конце, а пока абстрагируйтесь и примите на веру, что любой префикс разбивается на $O(\log n)$ отрезков вида $[F(i), i]$, и любой элемент входит в не более $O(\log n)$ таких отрезков. ## Реализация Из-за того, что $F(0) = 1 &gt; 0$ и поэтому $[0, F(0)]$ не является корректным отрезком, нам будет удобнее хранить массив в 1-индексации и не использовать $t_0$. ```c++ int t[maxn]; // возвращает сумму на префиксе int sum (int r) { int res = 0; for (; r &gt; 0; r -= r &amp; -r) res += t[r]; return res; } int sum (int l, int r) { return sum(r) - sum(l-1); } // обновляет нужные t void add (int k, int x) { for (; k &lt;= n; k += k &amp; -k) t[k] += x; } ``` Автор отмечает красивую симметрию в формулах `r += r &amp; -r` и `k -= k &amp; -k`, которой нет в «традиционной» версии. ## Многомерный случай &gt; $k$-мерное дерево Фенвика пишется в $(k+1)$ строчку Нужно добавить всего одну такую же строчку в `sum`, `add`, а также при подсчете суммы на прямоугольнике вместо двух запросов к префиксным суммам использовать четыре. `sum` перепишется следующим образом: ```c++ int sum (int r1, int r2) { int res = 0; for (int i = r1; i &gt; 0; i -= i &amp; -i) for (int j = r2; j &gt; 0; j -= j &amp; -j) ans += t[i][j]; return res; } ``` В $k$-мерном случае, в соответствии с принципом включений-исключений, для запроса суммы нужно $2^k$ запросов суммы на префиксах. Если размерности больше, чем позволяет память, то можно вместо массива `t` использовать хэш-таблицу — так потенциально потребуется $O(q \log^2 A)$ памяти ($A$ — максимальная координата), но это всё равно один из самых безболезненных способов решать достаточно простые задачи на двумерные структуры. Автор в своё время таким образом [решил](https://pastebin.com/DPemaJeW) какую-то задачу на 2d-сумму с USACO 2017. ## Бинпоиск Оказывается, можно производить бинарный поиск (точнее, спуск) по префиксным суммам за $O(\log n)$. ```c++ // возвращает индекс, на котором сумма уже больше int lower_bound (int s) { int k = 0; for (int l = logn; l &gt;= 0; l--) { if (k + (1&lt;= k &gt; i - (i &amp; -i)`. Будем перебирать префиксы TODO Мы знаем, что $t_i$ вложены друг в друга. Минимальный подходящий $i$ равен $k$. Какой следующий? Нам нужно для каждого $i$ уметь находить его непосредственного родителя. Можно представить дерево так: ячейка 2^k содержит все TODO: сначала объявить дерево как дерево и описать его структуру словами, а потом уже показывать реализацию. ## Название Потому что $F$ использует битовые операции, по-английски структура называется «Binary Indexed Tree». Почему дерево Фенвика — дерево? Тут нужно немного воображения. На самом деле BIT в общем случае — набор деревьев. Можно показать, что множества элементов, учтенных в $t_i$ и $t_j$, либо не пересекаются, либо одно является подмножеством другого. Значит, между $t_i$ можно ввести отношение вложенности, и тогда дерево Фенвика можно представить как набор деревьев (не обязательно бинарных). В частном случае, когда длина массива равна $2^k$, то дерево будет только одно.
<div>
<img src="https://mc.yandex.ru/watch/53961409" />
</div>
</body>
</html>
