<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Обходы графов - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/dfs.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/dfs.md'>История</a>
    </div>
</div>
<h1 id="обходы-графов">Обходы графов</h1>
<p>В этой статье рассмотрены основные применения обхода в глубину: топологическая сортировка, нахождение компонент сильной связности, решение задачи 2-SAT, нахождение мостов и точек сочленения, а также построение эйлерова пути и цикла в графе.</p>
<h2 id="поиск-в-глубину">Поиск в глубину</h2>
<p><strong>Поиском в глубину</strong> (англ. <em>depth-first search</em>, <strong>DFS</strong>) называется рекурсивный алгоритм обхода дерева или графа, начинающий в корневой вершине (в случае графа её может быть выбрана произвольная вершина) и рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span>;</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dt">bool</span> used[maxn]; <span class="co">// тут будем отмечать посещенные вершины</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">void</span> dfs(<span class="dt">int</span> v) {</a>
<a class="sourceLine" id="cb1-5" title="5">    used[v] = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="cf">for</span> (<span class="dt">int</span> u : g[v])</a>
<a class="sourceLine" id="cb1-7" title="7">        <span class="cf">if</span> (!used[u])</a>
<a class="sourceLine" id="cb1-8" title="8">            dfs(v);</a>
<a class="sourceLine" id="cb1-9" title="9">}</a></code></pre></div>
<p>Немного его модифицируем, а именно будем сохранять для каждой вершины, в какой момент мы в неё вошли и в какой вышли — соответствующие массивы будем называть <code>tin</code> и <code>tout</code>.</p>
<p>Как их заполнить: заведем таймер, отвечающий за «время» на текущем состоянии обхода, и будем инкрементировать его каждый раз, когда заходим или выходим из вершины:</p>
<pre><code>int tin[maxn], tout[maxn];
int t = 0;

void dfs(int v) {
    tin[v] = t++;
    for (int u : g[v])
        if (!used[u])
            dfs(u);
    tout[v] = t++;
}</code></pre>
<p>Времена входа или выхода пригождается во многих графовых алгоритмах — далее мы разберем несколько.</p>
<h1 id="мосты-и-точки-сочленения">Мосты и точки сочленения</h1>
<p>Пусть дан связный неориентированный граф. <em>Мостом</em> называется ребро, при удалении которого граф становится несвязным.</p>
<p>Запустим DFS из произвольной вершины и введем новые виды ребер :</p>
<ul>
<li><p>«Основные» рёбра обхода (англ. <em>tree edge</em>) — те, по которым были переходы в DFS.</p></li>
<li><p>Обратные рёбра — то, по которым не было переходов в DFS.</p></li>
</ul>
<p>Пусть есть ребро <span class="math inline">\(u \rightarrow v\)</span>. В каком случае оно является мостом? Понятно, что обратное ребро не может быть мостом, потому что мы уже посещали обе вершины и следовательно есть путь по ребрам самого ДФС. Теперь разберемся с ребрами ДФС. Они являются мостом, только если нет пути по обратным ребрам в какого-то из предков <span class="math inline">\(v\)</span>. Так как иначе мы можем удалить это ребро, но при этом останется путь по обратным ребрам.</p>
<p>Давайте докажем, что если путь до предка существует, то существует и путь, такой, что нам достаточно пройти по одному обратному ребру. Пусть такого пути не существует, но при этом есть какой-то путь из <span class="math inline">\(n\)</span> обратных ребер, тогда давайте посмотрим куда могут вести эти ребра, они могут вести либо в поддерево вершины <span class="math inline">\(u\)</span>, либо в нее саму, либо в наддерево, в случае поддерева или самой вершины мы можем их убрать, так как есть путь по ребрам ДФС, в случае наддерева же нам достаточно сохранить только одно ребро в наддерево.</p>
<p>Тогда давайте введем <span class="math inline">\(dp_{i}\)</span> - минимальный <span class="math inline">\(\space{\rm tin}\)</span> такой вершины, до которой мы можем добраться за какое-то количество ребер ДФС и одно обратное. Как его пересчитывать. Очень просто : у нас есть три возможных значения динамики.</p>
<ol start="3" type="1">
<li><p><span class="math inline">\(dp_{i} = min(tin_{i}, dp_{i})\)</span></p></li>
<li><p><span class="math inline">\(dp_{i} = min(dp_{i}, dp_{son})\)</span>, где <span class="math inline">\(son\)</span> - сын <span class="math inline">\(i\)</span>-й вершины</p></li>
<li><p><span class="math inline">\(dp_{i} = min(dp_{i}, tin_{back})\)</span>, где <span class="math inline">\(back\)</span> - вершина, для которой есть обратное ребро из <span class="math inline">\(i\)</span>-й вершины.</p></li>
</ol>
<p>Научимся понимать, какое ребро - ребро ДФС, а какое обратное. Если ребро ведет в уже использованную вершины, то это обратное ребро, иначе ребро ДФС.</p>
<pre><code>int timer, tin[MAXN], dp[MAXN];

void dfs(int u, int p) {
    used[u] = true;
    tin[u] = dp[v] = timer++;
    for (auto to : g[v]) {
        if (to == p) {
            continue;
        }
        if (used[to]) {
            dp[u] = min(dp[u], tin[to]);
        }
        else {
            dfs(to, u);
            dp[u] = min(dp[u], dp[to]);
        }
        if (dp[to] &gt; tin[u]) {
            //ребро - мост
        }
    }
}</code></pre>
<h1 id="точки-сочленения">Точки сочленения</h1>
<p>Точка сочленения - вершина, при удалении которой граф становится несвязным.</p>
<p>Первое, что надо заметить, что мост и точка сочленения очень похожи, а что если они и ищутся одинаково. Давайте подумаем, что такое точка сочленения в рамках обратных ребер, это вершина у которой можно добраться до предка используя обратные и ребра ДФС вниз. Но тогда как изменится нахождение точек сочленения, единственное отличие, что у мостов надо было чтобы у предка было время входа строго больше, сейчас же нам достаточно и нестрогого неравенства, так как если из вершины можно добраться до нее самой, то она все равно точка сочленения. Также вылезает один крайний случай, а именно корень, так как в корень мы всегда войдем раньше других вершин, но тут решение очень простое, давайте посмотрим, сколько несвязных поддеревьев у корня.</p>
<pre><code>int timer, tin[MAXN], dp[MAXN];

void dfs(int u, int p = -1) {
    used[u] = 1;
    tin[u] = dp[u] = timer++;
    int children = 0;
    for (auto to : g[u]) {
        if (to == p)  {
            continue;
        }
        if (used[to]) {
            dp[u] = min(dp[u], tin[to]);
        }
        else {
            dfs(to, u);
            dp[u] = min(dp[u], dp[to]);
        }
        if (dp[to] &gt;= tin[u] &amp;&amp; p != -1) {
            //v - точка сочленения;
        }
        ++children;
    }
    if (p == -1 &amp;&amp; children &gt; 1) {
        //u - точка сочленения;
    }
}</code></pre>
<h2 id="топологическая-сортировка">Топологическая сортировка</h2>
<p>Задача о топологической сортировке графа звучит так:</p>
<blockquote>
<p>Дан ориентированный граф, нужно расставить его вершины в массиве так, чтобы все ребра шли вправо по массиву.</p>
</blockquote>
<p>Эта же задача очень часто встречается в реальной жизни. Например, у вас есть много зависимостей вида “в библиотеке А используется библиотека B”, и вам нужно загрузить все библиотеки в таком порядке, чтобы никогда не загружать A до B.</p>
<p>Или, например, у вас есть список зависимых дел - “чтобы сделать А, надо сначала сделать B”, и вам нужно понять, в каком порядке делать все дела.</p>
<p>Во-первых, сразу заметим, что граф с циклом топологически отсортировать не получится - как ни располагай цикл в массиве, все время идти вправо по ребрам цикла не получится, потому что в итоге должен оказаться в самой левой вершине цикла.</p>
<p>Во-вторых, верно обратное! Если цикла нет, то его обязательно можно топологически отсортировать. Попытаемся придумать как, заодно придумаем алгоритм.</p>
<p>Заметим, что вершину, из которой не ведет ни одно ребро, можно всегда поставить последней. И такая вершина всегда есть в графе без циклов (если всегда есть внешнее ребро, то есть цикл). Из этого сразу следует доказательство: просто будем класть в массив вершину, из которой ничего не ведет и убирать ее из графа. Массив потом надо будет развернуть.</p>
<p>Алгоритм же сразу получается, если внимательно посмотреть на <strong>время выхода</strong> вершин. Вершина, из которой мы вышли в DFS-е первой - как раз та, из которой ничего не выходит. Ведь если из нее есть ребро, то только в уже посещенную, но мы не могли выйти из нее, ведь мы берем самую первую из которой мы вышли. Значит, это одна из серых вершин, в котороые мы вошли, и не вышли, и это цикл.</p>
<p>Из этого следует, что достаточно просто брать вершины в порядке выхода из DFS, то есть в конце DFS, например, просто класть эту вершину в конец массива с ответом. Ну и этот массив надо удет перевернуть, чтобы все ребра шли вправо, а не влево.</p>
<h2 id="компоненты-сильной-связности">Компоненты сильной связности</h2>
<p>Мы только что научились топологически сортировать ациклические графы. А что же делать с циклическими графами? Ведь в них тоже хочется найти какую-то структуру.</p>
<p>Для этого обычно вводят такое понятие как “сильная связность”. В ориентированных графах две вершины связаны сильно, если существует путь из одной в другую и наоборот. Проще говоря, они обе лежат на каком-то цикле.</p>
<p>Понятно, что такое отношение транзитивно: если А и B сильно связны, и B и C сильно связны, то A и C тоже сильно связны. Поэтому все вершины распадаются на такие компоненты сильной связности - такое разбиение вершин, что внутри одной компоненты все вершины сильно связаны, а между вершинами разных компонент сильно связности нет.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Graph_Condensation.svg/640px-Graph_Condensation.svg.png" alt="Example" /><figcaption>Example</figcaption>
</figure>
<p>Самый простой пример сильно-связной компоненты - это цикл. Но это может быть и полный граф, и любое сложное пересечение нескольких циклов.</p>
<p>Часто рассматривают граф самих компонент сильной связности. На катинке выше их шесть, и между ними остаются ребра из изначально графа. Очевидно, что такой граф уже удет ациклических: иначе компоненты на цикле нужно было бы объединить в одну.</p>
<h2 id="конденсация-графа">Конденсация графа</h2>
<p>Задача о конденсации графа звучит так:</p>
<blockquote>
<p>Дан ориентированный граф <span class="math inline">\(G\)</span>, множество вершин которого <span class="math inline">\(V\)</span> и множество рёбер — <span class="math inline">\(E\)</span>. Конденсацией назовем сжатие каждой компоненты сильной связности в одну вершину. Каждой вершине графа конденсации соответствует компонента сильной связности графа <span class="math inline">\(G\)</span>, а ориентированное ребро между двумя вершинами <span class="math inline">\(C_i\)</span> и <span class="math inline">\(C_j\)</span> графа конденсации проводится, если найдётся пара вершин <span class="math inline">\(u \in C_i, v \in C_j\)</span>, между которыми существовало ребро в исходном графе, т.е. <span class="math inline">\((u,v) \in E\)</span>.</p>
</blockquote>
<blockquote>
<p>Необходимо найти, какие вершины лежат в каждой компоненте сильной связности и построить граф конденсации.</p>
</blockquote>
<p><strong>Теорема.</strong> Запустим DFS. Пусть <span class="math inline">\(C\)</span> и <span class="math inline">\(C^\prime\)</span> — две различные компоненты сильной связности, и пусть в графе конденсации между ними есть ребро <span class="math inline">\((C,C^\prime)\)</span>. Тогда <span class="math inline">\(\max\limits_{c\in C}(\space{\rm tout}[c]) &gt; \max\limits_{c^\prime\in C^\prime}({\rm tout}[c^\prime])\)</span>.</p>
<p>При доказательстве возникают два принципиально различных случая в зависимости от того, в какую из компонент первой зайдёт обход в глубину$:</p>
<p>Первой была достигнута компонента <span class="math inline">\(C\)</span>. Это означает, что в какой-то момент времени обход в глубину заходит в некоторую вершину <span class="math inline">\(v\)</span> компоненты <span class="math inline">\(C\)</span>, при этом все остальные вершины компонент <span class="math inline">\(C\)</span> и <span class="math inline">\(C^\prime\)</span> ещё не посещены. Но, т.к. по условию в графе конденсаций есть ребро <span class="math inline">\((C,C^\prime)\)</span>, то из вершины <span class="math inline">\(v\)</span> будет достижима не только вся компонента <span class="math inline">\(C\)</span>, но и вся компонента <span class="math inline">\(C^\prime\)</span>. Это означает, что при запуске из вершины <span class="math inline">\(v\)</span> обход в глубину пройдёт по всем вершинам компонент <span class="math inline">\(C\)</span> и <span class="math inline">\(C^\prime\)</span>, а, значит, они станут потомками по отношению к <span class="math inline">\(v\)</span> в дереве обхода в глубину, т.е. для любой вершины <span class="math inline">\(u \in C \cup C^\prime, u \ne v\)</span> будет выполнено <span class="math inline">\({\rm tout}[v] &gt; {\rm tout}[u]\)</span>, ч.т.д.</p>
<p>Обратный случай рассматривается проще, из <span class="math inline">\(C^\prime\)</span> нельзя добраться до <span class="math inline">\(C\)</span>, а следовательно доказано.</p>
<p>Из этого и следует первая часть решения - давайте отсортируем вершины по убыванию времени выхода (будто топсорт, но на циклическом графе). Рассмотрим компоненту сильной связности первой вершины, назовем ее <span class="math inline">\(C^\prime\)</span>. В эту компоненту точно нет никаких рёбер из других компонент (иначе <span class="math inline">\(\max\limits_{c\in C}(\space{\rm tout}[c]) &gt; \max\limits_{c^\prime\in C^\prime}({\rm tout}[c^\prime])\)</span>, а первая вершина - это вообще-то максимум времени выхода). Поэтому если мы развернем все ребра, то из этой вершины все еще будет достижима своя компонента сильной связности <span class="math inline">\(C^\prime\)</span>, и больше точно ничего - если раньше не было ребер из других компонент, то после разворота ребер не стало ребер в другие компоненты.</p>
<p>Так что второй шаг такой - разворачиваем ребра, запускаем DFS в таком порядке, ищем компоненты связности как в обычном графе. Попутно можно строить и граф конденсации.</p>
<pre><code>vector&lt;int&gt; g[N], gr[N];
bool used[N];
vector&lt;int&gt; order, component;

void dfs1(int v) {
    used[v] = true;
    for (int i = 0; i &lt; g[v].size(); i++) {
        if (!used[g[v][i]]) {
            dfs1(g[v][i]);
        }
    }
    order.push_back (v);
}

void dfs2(int v) {
    used[v] = true;
    component.push_back(v);
    for (int i = 0; i &lt; gr[v].size(); i++) {
        if (!used[gr[v][i]]) {
            dfs2(gr[v][i]);
        }
    }
}

int main() {
    for (;;) {
        g[a].push_back(b);
        gr[b].push_back(a);
    }
    for (int i = 0; i &lt; n; i++){
        if (!used[i]) {
            dfs1(i);
        }
    }
    for (int i = 0; i &lt; n; i++) {
        used[i] = 0;
    }
    reverse(order.begin(), order.end());
    for (int i = 0; i &lt; n; i++) {
        int v = order[i];
        if (!used[v]) {
            dfs2 (v);
        }
    }
}</code></pre>
<p>Еще раз вкратце:</p>
<ol type="1">
<li><p>Сортируем вершины в порядке убывания времени выхода.</p></li>
<li><p>Проходимся по массиву вершин в том порядке на равернутом графе и запускаем на нем DFS, выделяя компоненты сильной связности.</p></li>
</ol>
<h2 id="sat">2-SAT</h2>
<p>Вспомним, что такое конъюнкция (логическое И, обозначается знаком * или <span class="math inline">\(\vee\)</span> или &amp;.) и дизъюнкция (логическое ИЛИ, обозначается знаком + или <span class="math inline">\(\wedge\)</span> или |), конъюкция возвращает 1 тогда и только тогда, когда обе переменные - 1, а дизъюнкция, возвращает 0, когда обе - 0.</p>
<p>Давайте теперь возьмем конъюнкцию дизъюнктов, а именно И от ИЛИ от переменных (или НЕ переменных). Например, такое выражение:</p>
<pre><code>(a | b) &amp; (!c | d) &amp; (!a | !b) // (А ИЛИ B) И (НЕ C ИЛИ D) И (НЕ A ИЛИ НЕ B)</code></pre>
<p>Задача SAT заключается в том, чтобы найти такие значения переменных, при которых это выражение становится истинным, ии сказать, что таких нет. Заметьте, что у нас в каждой скобке в этом примере ровно две переменные, в таком случае задача называется 2-SAT, и именно ее мы и хотим решить. Для примера выше решением является <span class="math inline">\(a=1, b=0, c=0, d=1\)</span> (убедитесь, что все скобки стали True).</p>
<p>Причем тут графы? А вот часто в разных математических задачах надо внезапно ввести граф и он тут же помогает решить задачу.</p>
<p>Приведем сначала выоажение к другому виду - импликативному. Заметим, что выражение вида a | b эквивалентно <span class="math inline">\(!a \rightarrow b\)</span> или<span class="math inline">\(!b \rightarrow a\)</span>.</p>
<p>Построим граф импликаций: для каждой переменной в графе будет по две вершины, обозначим их через <span class="math inline">\(x_{i}\)</span> и <span class="math inline">\(!x_{i}\)</span>. Рёбра в графе будут соответствовать импликациям.</p>
<p>Теперь заметим, что если для какой-то переменной <span class="math inline">\(x_{i}\)</span> выполняется, что из <span class="math inline">\(x_{i}\)</span> достижимо <span class="math inline">\(!x_{i}\)</span>, а из <span class="math inline">\(!x_{i}\)</span> достижимо <span class="math inline">\(x_{i}\)</span>, то задача решения не имеет. Действительно, какое бы значение для переменной <span class="math inline">\(x_{i}\)</span> мы бы ни выбрали, мы всегда придём к противоречию - что должно быть выбрано и обратное ему значение. Оказывается, что это условие является не только достаточным, но и необходимым (доказательством этого факта будет описанный ниже алгоритм). Переформулируем данный критерий в терминах теории графов. Напомним, что если из одной вершины достижима вторая и наоборот, то эти две вершины находятся в одной компоненте сильной связности. Тогда мы можем сформулировать критерий существования решения следующим образом:</p>
<p>Для того, чтобы данная задача 2-SAT имела решение, необходимо и достаточно, чтобы для любой переменной <span class="math inline">\(x_{i}\)</span> вершины <span class="math inline">\(x_{i}\)</span> и <span class="math inline">\(!x_{i}\)</span> находились в разных компонентах сильной связности графа импликаций.</p>
<p>Пусть решение существует и нам надо его найти.</p>
<p>Заметим, что, несмотря на то, что решение существует, для некоторых переменных может выполняться, что из <span class="math inline">\(x\)</span> достижимо <span class="math inline">\(!x\)</span> или из <span class="math inline">\(!x\)</span> достижимо <span class="math inline">\(x\)</span>. В таком случае выбор одного из значений переменной <span class="math inline">\(x\)</span> будет приводить к противоречию, в то время как выбор другого - не будет. Научимся выбирать из двух значений то, которое не приводит к возникновению противоречий. Сразу заметим, что, выбрав какое-либо значение, мы должны запустить из него обход в глубину/ширину и пометить все значения, которые следуют из него, т.е. достижимы в графе импликаций. Соответственно, для уже помеченных вершин никакого выбора между <span class="math inline">\(x\)</span> и <span class="math inline">\(!x\)</span> делать не нужно, для них значение уже выбрано и зафиксировано. Нижеописанное правило применяется только к непомеченным ещё вершинам.</p>
<p>Утверждается следующее. Пусть <span class="math inline">\(\space{\rm comp}[V]\)</span> обозначает номер компоненты сильной связности, которой принадлежит вершина <span class="math inline">\(V\)</span>, причём номера упорядочены в порядке топологической сортировки компонент сильной связности в графе компонентов (т.е. более ранним в порядке топологической сортировки соответствуют большие номера: если есть путь из <span class="math inline">\(v\)</span> в <span class="math inline">\(w\)</span>, то <span class="math inline">\(\space{\rm comp}[v] \leq \space{\rm comp}[w]\)</span>). Тогда, если <span class="math inline">\(\space{\rm comp}[x] &lt; \space{\rm comp}[!x]\)</span>, то выбираем значение !x, иначе выбираем x.</p>
<p>Докажем, что при таком выборе значений мы не придём к противоречию. Пусть, для определённости, выбрана вершина <span class="math inline">\(x\)</span> (случай, когда выбрана вершина <span class="math inline">\(!x\)</span>, доказывается также).</p>
<p>Во-первых, докажем, что из <span class="math inline">\(x\)</span> не достижимо <span class="math inline">\(!x\)</span>. Действительно, так как номер компоненты сильной связности <span class="math inline">\(\space{\rm comp}[x]\)</span> больше номера компоненты <span class="math inline">\(\space{\rm comp}[!x]\)</span> , то это означает, что компонента связности, содержащая <span class="math inline">\(x\)</span>, расположена левее компоненты связности, содержащей <span class="math inline">\(!x\)</span>, и из первой никак не может быть достижима последняя.</p>
<p>Во-вторых, докажем, что из любой вершины <span class="math inline">\(y\)</span>, достижимой из <span class="math inline">\(x\)</span> недостижима <span class="math inline">\(!y\)</span>. Докажем это от противного. Пусть из <span class="math inline">\(x\)</span> достижимо <span class="math inline">\(y\)</span>, а из <span class="math inline">\(y\)</span> достижимо <span class="math inline">\(!y\)</span>. Так как из <span class="math inline">\(x\)</span> достижимо <span class="math inline">\(y\)</span>, то, по свойству графа импликаций, из <span class="math inline">\(!y\)</span> будет достижимо <span class="math inline">\(!x\)</span>. Но, по предположению, из <span class="math inline">\(y\)</span> достижимо <span class="math inline">\(!y\)</span>. Тогда мы получаем, что из <span class="math inline">\(x\)</span> достижимо <span class="math inline">\(!x\)</span>, что противоречит условию, что и требовалось доказать.</p>
<p>Итак, мы построили алгоритм, который находит искомые значения переменных в предположении, что для любой переменной <span class="math inline">\(x\)</span> вершины <span class="math inline">\(x\)</span> и <span class="math inline">\(!x\)</span> находятся в разных компонентах сильной связности. Выше показали корректность этого алгоритма. Следовательно, мы одновременно доказали указанный выше критерий существования решения.</p>
<h1 id="эйлеров-путь-и-цикл">Эйлеров путь и цикл</h1>
<p>Эйлеров путь - это путь в графе, проходящий через все его рёбра. Эйлеров цикл - это эйлеров путь, являющийся циклом.</p>
<p>Научимся понимать, есть ли эйлеров цикл/путь в графе, давайте считать, что граф неориентированный. Изначально поймем, что граф должен состоять из одной компоненты и может содержать изолированные вершины.</p>
<p>Чтобы проверить, существует ли эйлеров путь, нужно воспользоваться следующей теоремой.</p>
<blockquote>
<p>Пусть дан неориентированный <strong>связный</strong> цикл. Эйлеров цикл существует тогда и только тогда, когда степени всех вершин чётны. Эйлеров путь существует тогда и только тогда, когда количество вершин с нечётными степенями равно двум (или нулю, в случае существования эйлерова цикла).</p>
</blockquote>
<p>Кстати, аналогичная теорема есть и для ориентированного графа (можете сами попытаться сформулировать).</p>
<p>Доказать это можно например через лемму о рукопожатиях.</p>
<p>Как теперь мы будем решать задачу нахождения цикла в предположении, что он точно есть. Давайте запустимся из произвольной вершины, пройдем по любому ребру и удалим его.</p>
<hr />
<pre><code>void findeulerpath(int v){
    stack &gt;s;
    s.push({v, -1});
    while (!s.empty()) {
        v = s.top().first;
        int x = s.top().second;
        for (int i = 0; i &lt; g[v].size(); i++){
            pair e = g[v][i];
            if(!u[e.second]){
                u[e.second]=1;
                s.push(e);
                break;
            }
        }
        if (v == s.top().first) {
            if (~x) {
                p.push_back(x);
            }
            s.pop();
        }
    }
}</code></pre>
<h2 id="проверка-на-двудольность">Проверка на двудольность</h2>
<p>Корректной раскраской графа в два цвета назывется такая раскраска, что никакое ребро не соединяет две вершины одного цвета. Графы, которые можно так раскрасить, называют еще двудольными.</p>
<p>Пусть первая вершина графа принадлежит первой доли, тогда все вершины, для которых есть ребро в первую, должны принадлежить второй и так далее, но тогда заметим, что если в какой-то момент мы хотем покрасить уже покращенную вершину не в ее цвет, то граф не двудольный, проверить это можно например с помощью дфса : запустим дфс от каждой еще не посешенной вершины.</p>
<pre><code>int n;
vector&lt;int&gt; g[N];

vector&lt;bool&gt; part(n, -1);
void dfs(int u, int color) {
    if (part[u] != color &amp;&amp; part[u] != -1) {
        cout &lt;&lt; &quot;NO&quot;;
        exit(0);
    }
    if (part[u] == color) {
        return;
    }
    for (int i = 0; i &lt; g.size(); i++) {
        dfs(g[u][i], 1 - color);
    }
}</code></pre>
</body>
</html>
