<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
# Метод отжига * Эвристический метод глобальной оптимизации * Работает с дискретными функциями в предположении, что у близких «точек» близкое значение, и есть что-то типа градиента * Очень простой в написании * Никаких гарантий нет, но хорошо работает на практике * Метод настолько мощный, что иногда им можно сдать задачи, у которых автором предполагалось адекватное решение (пример: [Ильдар Гайнуллин сдает отжигом div2E на динамику по подмножествам](http://codeforces.com/contest/745/submission/23067030)) ![](https://camo.githubusercontent.com/574bf26bf301827efaa18748440fa77fab8c5a4f/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f642f64352f48696c6c5f436c696d62696e675f776974685f53696d756c617465645f416e6e65616c696e672e676966) ## Постановка задачи Имеется некоторая функция $f(x)$, которую мы хотим минимизировать. Наука решать эту задачу в общем случае не умеет, и вряд ли когда-либо научится. TODO: описание алгоритма, физическая аналогия, конструирование гладких функций При решении конкретной задачи нужно менять только функцию `fitness` и, возможно, параметры алгоритма. ## Ферзи Рассмотрим такую задачу: дана шахматная доска $n \times n$ и $n$ ферзей. Нужно расставить их так, чтобы они не били друг друга. Будем кодировать состояние перестановкой чисел от $1$ до $n$. Такое представление кодирует не все состояния, но оно точно не учитывает те, где ферзи бьют друг друга по вертикали или горизонтали. Выберем такую функцию: fitness(p) = число пар ферзей, которые бьют друг друга. Важная деталь: скорость одной итерации прямо пропорционально скорости работы `fitness`, поэтому очень важно реализовать её эффективно. Конкретно здесь её можно реализовать за $O(n^2)$ (используется в коде для наглядности), $O(n)$ и даже $O(1)$. Мы будем использовать `python`, потому что в нём удобнее строить графики. Эквивалентный код на C++ приведена сразу после. ```python import random # Эти библиотеки будут нужны, чтобы рисовать графики: import matplotlib.pyplot as plt %matplotlib inline import seaborn as sns sns.set() ``` ```python def fitness(p): s = 0 for i in range(len(p)): d = 1 for j in range(i): if abs(i-j) == abs(p[i]-p[j]): # ферзи стоят на одной диагонали d = 0 s += d return s ``` ```python n = 100 # кол-во ферзей k = 1000 # кол-во итераций p = list(range(n)) # исходная перестановка scores = [] t = 1 for i in range(k): # уменьшаем температуру t *= 0.99 # этот параметр лучше перебрать руками # копируем перестановку и делаем небольшое изменение q = p[:] a, b = random.sample(range(n), 2) q[a], q[b] = q[b], q[a] # считаем разницу fitness и решаем, нужно ли переходить в новое состояние d = fitness(q) - fitness(p) if d &gt; 0 or random.random() &lt; math.exp(d/t): p = q[:] scores += [fitness(q)] print('Best score:', max(scores)) plt.plot(scores) plt.show() ``` Best score: 95 ![png](annealing_files/annealing_11_1.png) Примерно эквивалентный код на C++: ```python const int n = 100, k = 1000; int f(vector p) { int s = 0; for (int i = 0; i &lt; n; i++) { int d = 1; for (int j = 0; j &lt; i; j++) if abs(i-j) == abs(p[i]-p[j]): d = 0; s += d; } return s; } double rnd() { return double(rand()) / RAND_MAX; } int main() { for (int i = 0; i &lt; n; i++) v[i] = i; int ans = 1; double t = 1; for (int i = 0; i &lt; k; i++) { t *= 0.99; vector u = v; swap(u[rand()%n], u[rand()%n]); int val = f(u); if (val &gt; ans || rnd() &lt; exp((val-ans)/t)) v = u, ans = val; if (ans == n) break; } for (int x : v) cout &lt;&lt; x+1 &lt;&lt; &quot; &quot;; return 0; } ```
<div>
<img src="https://mc.yandex.ru/watch/53961409" />
</div>
</body>
</html>
