<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>suffix_automaton</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
</head>
<body>
<h1 id="введение" class="unnumbered unnumbered">Введение</h1>
<p>Рассмотрим задачу поиска образцов в тексте. Дан текст <span class="math inline">\(T\)</span> и <span class="math inline">\(n\)</span> образцов <span class="math inline">\(S_i\)</span>, для каждого из образцов нужно узнать, встречается ли он в тексте. Есть два основных подхода к решению этой задачи. Первый — алгоритм Ахо-Корасик, который строит по набору образцов автомат, распознающий строки, в которых встречаются данные образцы. Второй — использование суффиксных структур, под которыми обычно подразумевают суффиксный массив, суффиксный автомат или суффиксное дерево. Данная лекция по большей части будет посвящена последним двум из них, их связи и применении в решении задач.</p>
<h1 id="наивное-решение" class="unnumbered unnumbered">Наивное решение</h1>
<p>Возьмём все суффиксы <span class="math inline">\(T\)</span> и объединим их в бор, в нём каждой подстроке <span class="math inline">\(T\)</span> будет соответствовать ровно одна вершина. Теперь мы можем за <span class="math inline">\(O(|T|^2)\)</span> времени на построение бора и <span class="math inline">\(O(|S_i|)\)</span> на запрос узнавать, входит ли <span class="math inline">\(S_i\)</span> в <span class="math inline">\(T\)</span>. От квадратичной сложности можно уйти двумя способами, ведущими к суффиксному дереву и суффиксному автомату соответственно.</p>

<figure>
<img src="img/abbcbc_automaton.png" alt="Суффиксное дерево cbcbba" /><figcaption>Суффиксное дерево <span class="math inline">\(cbcbba\)</span></figcaption>
</figure>

<figure>
<img src="img/cbcbba_tree.png" alt="Суффиксное дерево cbcbba" /><figcaption>Суффиксное дерево <span class="math inline">\(cbcbba\)</span></figcaption>
</figure>
<h1 id="суффиксное-дерево">Суффиксное дерево</h1>
<p>Любой нисходящий путь в этом боре будет подстрокой <span class="math inline">\(T\)</span>, значит если из вершины <span class="math inline">\(v\)</span> нет других исходящих рёбер, можно заменить путь <span class="math inline">\(u \topto{\al} v \topto{\bb} w\)</span> на ребро <span class="math inline">\(u \topto{\al \bb} w\)</span>, храня при этом строку <span class="math inline">\(\al \bb\)</span> в виде пары чисел <span class="math inline">\([l;r]\)</span>, указывающей на её местоположение в <span class="math inline">\(T\)</span>. Такая сжатая структура называется суффиксным деревом и занимает <span class="math inline">\(O(|T|)\)</span> памяти.</p>
<h1 id="суффиксный-автомат">Суффиксный автомат</h1>
<p>Детерминированный конечный автомат (далее автомат) — это пятёрка <span class="math inline">\(A = (Q, \Sigma, \delta, q_0, F)\)</span>, где <span class="math inline">\(Q\)</span> — множество состояний, <span class="math inline">\(\Sigma\)</span> — алфавит, <span class="math inline">\(\delta \subset Q \times \Sigma \times Q\)</span> — множество переходов, <span class="math inline">\(q_0 \in Q\)</span> — начальное состояние, <span class="math inline">\(F \subset Q\)</span> — множество финальных состояний.</p>
<p>Всякому автомату можно сопоставить ориентированный граф такой что состояния автомата — это вершины графа, а переходы — это дуги помеченные символами из алфавита. Соответственно, в таком графе должна быть выделена некоторая вершина <span class="math inline">\(q_0\)</span> (начальное состояние) и набор вершин <span class="math inline">\(F\)</span> (финальные состояния). Кроме того, из любого состояния не может быть двух переходов по одному и тому же символу (детерминированность).</p>
<p>Состояние <span class="math inline">\(q\)</span> принимает строку <span class="math inline">\(s\)</span>, если есть путь из <span class="math inline">\(q_0\)</span> в <span class="math inline">\(q\)</span> такой что если выписать все символы, которые мы встретили на этом пути, мы получим строку <span class="math inline">\(s\)</span>. Автомат принимает строку <span class="math inline">\(s\)</span>, если её принимает хотя бы одно из финальных состояний. Множество строк принимаемых автоматом будем называть его языком.</p>
<p>Суффиксным автоматом строки <span class="math inline">\(s\)</span> будем называть <em>минимальный</em> автомат, который принимает все суффиксы строки и только их. Под минимальностью подразумевается, что число состояний в нём должно быть наименьшим возможным.</p>
<p>Суффиксный автомат не только ориентированный, но и ациклический граф, ведь множество принимаемых им строк конечно, а цикл позволил бы принять сколь угодно длинную строку. Рассмотрим факты, позволяющие нам уточнить природу суффиксного автомата.</p>
<p>Пусть <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span> — строки, которые принимает состояние <span class="math inline">\(q\)</span> некоторого автомата <span class="math inline">\(A\)</span>. Тогда для любой строки <span class="math inline">\(x\)</span> строки <span class="math inline">\(ax\)</span> и <span class="math inline">\(bx\)</span> принимаются или не принимаются <span class="math inline">\(A\)</span> одновременно.</p>
<p>Независимо от того, как мы “пришли” в состояние <span class="math inline">\(q\)</span>, если мы пройдём из него по пути, соответствующему строке <span class="math inline">\(x\)</span>, мы сможем точно сказать, в какое состояние мы попадём и, в частности, будет ли оно финальным.</p>
<p>Правым контекстом <span class="math inline">\(X(q)\)</span> состояния <span class="math inline">\(q\)</span> назовём множество строк <span class="math inline">\(x\)</span>, переводящих <span class="math inline">\(q\)</span> в одно из финальных состояний. Соответственно, назовём правым контекстом строки <span class="math inline">\(a\)</span> множество <span class="math inline">\(X(a)\)</span> строк <span class="math inline">\(x\)</span> таких что <span class="math inline">\(ax\)</span> принимается автоматом.</p>
<p>Правый контекст строки совпадает с правым контекстом состояния, которое её принимает, поэтому правые контексты языка можно рассматривать независимо от конкретного автомата:</p>
<p>Рассмотрим множество <span class="math inline">\(R\)</span> непустых правых контекстов всех возможных слов над <span class="math inline">\(\Sigma\)</span>. В любом автомате, задающем данный язык будет хотя бы <span class="math inline">\(|R|\)</span> состояние.</p>
<p>Рассмотрим любой правый контекст в <span class="math inline">\(R\)</span>. Пусть он порождён строкой <span class="math inline">\(a\)</span>, тогда в автомате должно быть некоторое состояние <span class="math inline">\(q\)</span>, принимающее строку <span class="math inline">\(a\)</span> и имеющее такой правый контекст, иначе автомат бы не смог принять строку <span class="math inline">\(ax\)</span>. При этом все эти состояния будут различными, так как у них будут различный правые контексты.</p>
<p>Существует автомат, на котором эта оценка достигается.</p>
<p>Если в автомате есть состояние с пустым правым контекстом, мы можем удалить его, не изменим принимаемый язык. Иначе пусть в автомате есть два состояния <span class="math inline">\(q_1\)</span>, <span class="math inline">\(q_2\)</span> такие что <span class="math inline">\(X(q_1) = X(q_2)\)</span>. Мы можем удалить состояние <span class="math inline">\(q_2\)</span> и перевести переходы, ведущие в него в состояние <span class="math inline">\(q_1\)</span>. Множество принимаемых строк от этого не изменится, следовательно, мы можем продолжать эту процедуру, пока число состояний не будет равно числу различных непустных правых контекстов.</p>
<p>Таким образом, мы доказали:</p>
<p>Автомат является минимальным тогда и только тогда, когда правые контексты всех его состояний попарно различны и не пусты.</p>
<p>В случае суффиксного автомата правый контекст <span class="math inline">\(X(a)\)</span> строки <span class="math inline">\(a\)</span> взаимно однозначно соответствует множеству правых позиций вхождений строки <span class="math inline">\(a\)</span> в строку <span class="math inline">\(s\)</span>. Действительно, если <span class="math inline">\(ax\)</span> принимается автоматом, то есть, является суффиксом, то <span class="math inline">\(s = yax\)</span>, а строке <span class="math inline">\(x\)</span> мы можем сопоставить позицию <span class="math inline">\(|s|-|x|-1\)</span>. Таким образом, каждое состояние автомата принимает строки с одинаковым множеством <em>правых</em> позиций их вхождений и обратно, все строки с таким множеством позиций принимаются этим состоянием.</p>
<h2 id="связь-между-суффиксным-автоматом-и-суффиксным-деревом" class="unnumbered unnumbered">Связь между суффиксным автоматом и суффиксным деревом</h2>
<p>Рассмотрим ребро в суффиксном дереве строки <span class="math inline">\(T\)</span>, а точнее все подстроки <span class="math inline">\(T\)</span>, которым соответствует или “внутренняя” вершина ребра, или вершина, в которой ребро заканчивается. Для любой строки <span class="math inline">\(x\)</span> и любой пары строк <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> из рассматриваемого множества строк, строки <span class="math inline">\(xa\)</span> и <span class="math inline">\(xb\)</span> являются или не являются префиксами строки <span class="math inline">\(s\)</span> одновременно.</p>
<p>Пусть <span class="math inline">\(|a| &lt; |b|\)</span>. Тогда <span class="math inline">\(a\)</span> является предком <span class="math inline">\(b\)</span> в боре, то есть, её префиксом, значит, её множество вхождений точно содержит множество вхождений строки <span class="math inline">\(b\)</span>. Допустим, существует позиция <span class="math inline">\(|x|\)</span>, в которой есть вхождение строки <span class="math inline">\(a\)</span>, но не строки <span class="math inline">\(b\)</span>.</p>
<p>Рассмотрим строку <span class="math inline">\(a&#39;\)</span>, которая является максимальным префиксом строки <span class="math inline">\(b\)</span>, который можно встретить в той позиции. Если <span class="math inline">\(a&#39;\)</span> не упирается в конец строки, то её можно продолжить, как минимум, двумя различными символами чтобы она осталась подстрокой <span class="math inline">\(T\)</span>. Значит, соответствующая ей вершина в дереве имеет степень больше двух и должна разбивать ребро, на котором находится, что конфликтует с предположением о том, что <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span> взяты с одного ребра.</p>
<p>Если же <span class="math inline">\(a&#39;\)</span> нельзя продолжить, то она всё ещё должна разбивать ребро, т.к. является суффиксом строки и её вершина не будет удалена при сжатии рёбер.</p>
<p>Аналогичным образом можно показать, что для любой строки <span class="math inline">\(a\)</span> все строки <span class="math inline">\(b\)</span> с таким же множеством строк <span class="math inline">\(x\)</span> находятся на соответствующем строке <span class="math inline">\(a\)</span> ребре, то есть, есть биекция между рёбрами суффиксного дерева и множествами левых позиций вхождений строк в <span class="math inline">\(T\)</span>. Отсюда:</p>
<p>Для любого состояния <span class="math inline">\(q\)</span> суффиксного автомата строки <span class="math inline">\(T\)</span> найдётся вершина <span class="math inline">\(q&#39;\)</span> суффиксного дерева развернутой строки <span class="math inline">\(T\)</span> такая, что множество строк, принимаемых состоянием <span class="math inline">\(q\)</span>, совпадает с развёрнутым множеством строк, таких что соответствующая им вершина в дереве лежит на ребре, ведущем в <span class="math inline">\(q&#39;\)</span> (включая строку, соответствующую <span class="math inline">\(q&#39;\)</span>).</p>
<p>Это целиком описывает состояния автомата и позволяет разработать алгоритм его построения.</p>
<h1 id="построение-суффиксного-автомата">Построение суффиксного автомата</h1>
<p>Пусть длина самой короткой строки, которая принимается состоянием <span class="math inline">\(q\)</span> равна <span class="math inline">\(k\)</span>. Тогда суффиксная ссылка <span class="math inline">\(link(q)\)</span> будет вести из этого состояния в состояние, которое принимает эту же строку без первого символа.</p>
<p>Обратившись к суффиксному дереву мы поймём, что в нём она будет вести в предка вершины <span class="math inline">\(q&#39;\)</span>. Таким образом, суффиксные ссылки образуют дерево, которое соответствует суффиксному дереву развернутой строки. Также будем обозначать длину самой длинной строки, которая принимается состоянием <span class="math inline">\(q\)</span> как <span class="math inline">\(len(q)\)</span>. Длина самой короткой строки из <span class="math inline">\(q\)</span> будет равна <span class="math inline">\(len(link(q)) + 1\)</span>.</p>
<p>Будем дописывать символы в конец строки <span class="math inline">\(T\)</span> по одному и при этом поддерживать для неё корректный автомат с деревом суффиксных ссылок. Пусть у нас есть автомат для строки <span class="math inline">\(T\)</span> и она принимается его состоянием <span class="math inline">\(last\)</span>. Мы хотим получить автомат для строки <span class="math inline">\(Tc\)</span>. Нам нужно, чтобы для каждого суффикса новой строки существовало состояние, которое его примет. При этом нам нужно сохранить минимальность автомата.</p>
<p>Добавим состояние, которое принимает всю строку <span class="math inline">\(Tc\)</span> и назовём его <span class="math inline">\(new\)</span>. Правый контекст <span class="math inline">\(Tc\)</span> состоит из единственной строки — пустой, значит, в <span class="math inline">\(new\)</span> будут входить те и только те суффиксы, которые мы встретили в строке впервые. Все такие строки можно получить дописыванием символа <span class="math inline">\(c\)</span> к суффиксам <span class="math inline">\(T\)</span>, которые принимаются состоянием, из которого ещё нет перехода по данному символу. Таким образом, чтобы новые суффиксы принимались, нам необходимо будет “попрыгать” по суффиксным ссылкам и добавить переходы по символу <span class="math inline">\(c\)</span> в состояние <span class="math inline">\(new\)</span>, пока не придём в корень или не обнаружим, что переход по символу <span class="math inline">\(c\)</span> из состояния уже есть.</p>
<p>Если мы пришли в корень, значит, <em>все</em> непустые суффиксы строки <span class="math inline">\(Tc\)</span> принимаются состоянием <span class="math inline">\(new\)</span> и мы можем положить <span class="math inline">\(link(new) = q_0\)</span> и завершить работу.</p>
<p>Иначе мы нашли состояние <span class="math inline">\(q&#39;\)</span>, из которого переход по символу <span class="math inline">\(c\)</span> уже есть. Значит, суффиксы длины <span class="math inline">\(\leq len(q&#39;) + 1\)</span> уже встречались в строке, и новых переходов в состояние <span class="math inline">\(new\)</span> мы проводить не будем. Однако, для состояния <span class="math inline">\(new\)</span> ещё нужно посчитать суффиксную ссылку. Наибольшей строкой в ней будет суффикс строки <span class="math inline">\(Tc\)</span> длины <span class="math inline">\(len(q&#39;) + 1\)</span>. В данный момент он находится в состоянии <span class="math inline">\(t\)</span>, в которое ведёт переход по символу <span class="math inline">\(c\)</span> из состояния <span class="math inline">\(q&#39;\)</span>, но в нём могуть быть также строки большей длины. Таким образом, если <span class="math inline">\(len(t) = len(q&#39;) + 1\)</span>, то <span class="math inline">\(t\)</span> и есть искомая суффиксная ссылка. Проведя её, мы завершим обновление автомата.</p>
<p>Иначе <span class="math inline">\(t\)</span> — состояние, которое принимает как строки, являющиеся суффиксами строки, так и строки, которые ими не являются, из-за этого мы не можем корректно определить его финальность. Чтобы решить данный конфликт мы должны будем отщепить от <span class="math inline">\(t\)</span> состояние <span class="math inline">\(t&#39;\)</span>, которое примет все строки, которые принимаются <span class="math inline">\(t\)</span>, но имеют длину <span class="math inline">\(\leq len(q&#39;) + 1\)</span>, то есть, тот самый кусок с суффиксами. Для этого скопируем в <span class="math inline">\(t&#39;\)</span> переходы и суффиксную ссылку из <span class="math inline">\(t\)</span>, а длину установим равной <span class="math inline">\(len(q&#39;) + 1\)</span>. Затем установим <span class="math inline">\(link(new) = link(t) = t&#39;\)</span>. Наконец, чтобы “перебросить” в него нужные строки из <span class="math inline">\(t\)</span>, пройдёмся по суффиксным ссылкам состояния <span class="math inline">\(q&#39;\)</span> пока переходы по <span class="math inline">\(c\)</span> ведут в <span class="math inline">\(t\)</span> и переправим эти переходы в <span class="math inline">\(t&#39;\)</span>. Таким образом, мы перенаправим все пути интересующей нас длины, которые ранее проходили через вершину <span class="math inline">\(t\)</span> в вершину <span class="math inline">\(t&#39;\)</span>.</p>
<p>В некотором смысле эта процедура соответствует построению суффиксного дерева добавлением суффиксов в возрастающем (по длине) порядке, приведём код на языке C++, выполняющий её:</p>
<p>``` {.c++ language=“C++”} const int maxn = 2e5 + 42; // Максимальное число состояний map&lt;char, int&gt; to[maxn]; // Переходы int link[maxn]; // Суффиксные ссылки int len[maxn]; // Длины максимальных строк в состояниях int last = 0; // Состояние, соответствующее всей строке int sz = 1; // Общее число состояний</p>
<p>void add_letter(char c) // Дописываем символ в конец { int p = last; // Записываем в p состояние строки s last = sz++; // Создаём для строки sc новое состояние len[last] = len[p] + 1; for(; to[p][c] == 0; p = link[p]) // (1) to[p][c] = last; // Прыгаем по ссылкам, создавая переходы if(to[p][c] == last) { // Если мы оказались здесь, то символ c встречен впервые link[last] = 0; return; } int q = to[p][c]; if(len[q] == len[p] + 1) { // Если переход сплошной, то q - суфф ссылка link[last] = q; return; } // Расщепляем q на два состояния, одно из которых cl, // А второе получит тот же номер, что и q имело ранее int cl = sz++; to[cl] = to[q]; // (2) link[cl] = link[q]; len[cl] = len[p] + 1; link[last] = link[q] = cl; for(; to[p][c] == q; p = link[p]) // (3) to[p][c] = cl; // Перенаправляем переходы там, где нужно } ```</p>
<h1 id="время-работы">Время работы</h1>
<p>Покажем линейность работы данного алгоритма. На каждом шаге есть три места, которые выполняются не за <span class="math inline">\(O(1)\)</span>:</p>
<ol type="1">
<li><p>Прыжки по ссылкам <span class="math inline">\(last\)</span> для создания переходов в <span class="math inline">\(new\)</span>.</p></li>
<li><p>Копирование переходов из <span class="math inline">\(t\)</span> в <span class="math inline">\(t&#39;\)</span>.</p></li>
<li><p>Прыжки по ссылкам <span class="math inline">\(q&#39;\)</span> для перенаправления переходов из <span class="math inline">\(t\)</span> в <span class="math inline">\(t&#39;\)</span>.</p></li>
</ol>
<p>В первых двух пунктах происходит создание очередного перехода в автомате. Покажем, что всего переходов будет <span class="math inline">\(O(n)\)</span>. Разделим все переходы <span class="math inline">\(\delta(v, c) = u\)</span> из <span class="math inline">\(v\)</span> в <span class="math inline">\(u\)</span> по символу <span class="math inline">\(c\)</span> на два класса — “сплошные”, для которых <span class="math inline">\(len(v) + 1 = len(u)\)</span> и все остальные.</p>
<p>Т.к. в каждое состояние, кроме начального, ведёт ровно один сплошной переход, сплошных переходов будет не больше, чем состояний, а их <span class="math inline">\(O(n)\)</span>.</p>
<p>Рассмотрим теперь несплошные переходы. Каждому такому переходу можно поставить в соответствие строку <span class="math inline">\(acb\)</span>, где <span class="math inline">\(a\)</span> — длиннейшая строка, которую принимает состояние <span class="math inline">\(v\)</span>, а <span class="math inline">\(b\)</span> — длиннейшая строка, которую можно вывести из состояния <span class="math inline">\(u\)</span>. Данная строка является суффиксом <span class="math inline">\(s\)</span> (иначе мы могли бы продлить <span class="math inline">\(b\)</span> вправо). Кроме того <span class="math inline">\(|a| = len(v)\)</span>, отсюда можно сделать вывод, что <span class="math inline">\(|a|\)</span> составлена исключительно из сплошных переходов. Значит, по произвольному суффиксу мы можем определить рассмотренный несплошной переход, как первый, который встретим, “скармливая” его строке. Значит, такое отображение взаимооднозначное и сплошных переходов не больше, чем суффиксов в строке. Отсюда следует, что суммарно переходов в автомате <span class="math inline">\(O(n)\)</span>.</p>
<p>Наконец, докажем линейность третьего пункта. Для удобства назовём <span class="math inline">\(link(link(q))\)</span> второй суффиксной ссылкой состояния <span class="math inline">\(q\)</span>. Также будем использовать такие обозначения: <span class="math inline">\(last\)</span> — состояние, соответствующее строке <span class="math inline">\(s\)</span>, <span class="math inline">\(new\)</span> — состояние строки <span class="math inline">\(sc\)</span>, <span class="math inline">\(p\)</span> — состояние, которое “прыгает” в циклах (можно видеть в коде). Т.к. <span class="math inline">\(sc\)</span> не могла встречаться в суффиксном автомате <span class="math inline">\(s\)</span>, из состояния <span class="math inline">\(last\)</span> изначально нет перехода по <span class="math inline">\(c\)</span>, поэтому в цикле (1) мы сделаем хотя бы один шаг. Отсюда <span class="math inline">\(len(link(p)) \leq len(link(link(last)))\)</span> (действительно, изначально <span class="math inline">\(p = last\)</span>, после первой итерации <span class="math inline">\(p = link(last) \rightarrow len(link(p)) = len(link(link(last)))\)</span>, на всех последующих итерациях длина <span class="math inline">\(len(link(p))\)</span> не увеличивается, значит, упомянутое неравенство верно.</p>
<p>Когда мы вышли из цикла (1), мы имеем <span class="math inline">\(\delta(p, c) = q\)</span>. Очевидно, если есть переход из состояния <span class="math inline">\(p\)</span> в состояние <span class="math inline">\(q\)</span>, то если мы допишем символ <span class="math inline">\(c\)</span> к самой короткой строке из <span class="math inline">\(p\)</span>, длина которой равна <span class="math inline">\(len(link(p)) + 1\)</span>, то получим строку, которая будет не короче, чем самая короткая строка, принимаемая состоянием <span class="math inline">\(q\)</span>, длина которой равна <span class="math inline">\(len(link(q)) + 1\)</span>. То есть, <span class="math inline">\(len(link(p)) + 2 \geq len(link(q)) + 1 \rightarrow len(link(p)) + 1 \geq len(link(q))\)</span>.</p>
<p>После выхода из цикла (1) куда бы мы ни поставили суффиксную ссылку из <span class="math inline">\(new\)</span>, вторая суффиксная ссылка точно будет <span class="math inline">\(link(q)\)</span>. Отсюда <span class="math inline">\(link(q) = link(link(new)) \rightarrow len(link(q)) = len(link(link(new)))\)</span>.</p>
<p>Теперь посмотрим на цикл (3). Он будет выполняться пока <span class="math inline">\(\delta(p, c) = q\)</span>, то есть, как было упомянуто выше <span class="math inline">\(len(link(p)) + 1 \geq len(link(q))\)</span>. При этом изначально <span class="math inline">\(len(link(link(last))) \geq len(link(p))\)</span>. Так как <span class="math inline">\(len(link(q)) = len(link(link(new)))\)</span>, а также на каждом шаге <span class="math inline">\(len(link(p))\)</span> уменьшается, получаем, что весь цикл отработает не дольше, чем за <span class="math inline">\(len(link(link(last))) - len(link(link(new)))\)</span>, то есть, за разность максимальных длин, принимаемых вторыми суффиксными ссылками состояний, соответствующих всей строке.</p>
<p>Наконец, собирая всё полученное воедино, получим такое неравенство: <span class="math inline">\(len(link(link(last))) + 1 \geq len(link(p)) + 1 \geq len(link(q)) = len(link(link(new)),\)</span> отсюда <span class="math inline">\(len(link(link(last))) + 1 \geq len(link(link(new)))\)</span>, которое означает, что на каждом шаге длина второй суффиксной ссылки либо уменьшилась, либо увеличилась не больше, чем на единицу (а значит, её суммарное уменьшение не превосходит <span class="math inline">\(O(n)\)</span>). Линейность алгоритма доказана!</p>
<h1 id="применение-в-решении-задач">Применение в решении задач</h1>
<ol type="1">
<li><p><strong>Число различных подстрок.</strong> Дана строка <span class="math inline">\(s\)</span>, необходимо посчитать количество её различных подстрок. В каждом состоянии встречаются строки длины от <span class="math inline">\(len(link(q)) + 1\)</span> до <span class="math inline">\(len(q)\)</span>. Всего <span class="math inline">\(len(q) - len(link(q))\)</span> строк. Просуммировав эту величину по всем состояниям, получим ответ.</p>
<p><em>Упражнение:</em> решите эту же задачу за <span class="math inline">\(O(n)\)</span>, учитывая, что к строке <span class="math inline">\(s\)</span> символы дописываются по одному и после каждого нового символа необходимо сказать текущее число различных подстрок строки <span class="math inline">\(s\)</span>.</p>
<p><em>Упражнение*:</em> Возьмём задачу из предыдущего упражнения и скажем, что теперь мы можем не только дописывать символы <em>в конец</em>, но и удалять их <em>с начала</em> строки. Вам требуется отвечать на те же запросы. Время работы решения всё ещё должно линейно зависеть от размера входа. <em>Подсказка:</em> иногда алгоритм Укконена также бывает полезен.</p></li>
<li><p><strong>Поиск подстрок в тексте.</strong> Пропустив строку через автомат мы сможем сказать, входит ли она в текст. Допустим, мы хотим узнать какую-то информацию о её вхождениях. Например, нам нужно выдать любое конкретное вхождение. Как мы уже знаем, каждому вхождению соответствует строка <span class="math inline">\(x\)</span> такая что <span class="math inline">\(ax\)</span> — суффикс <span class="math inline">\(s\)</span>. Или, проще говоря, путь из состояния <span class="math inline">\(q\)</span> в какое-то финальное состояние. Динамикой по автомату как ациклическому ориентированному графу мы можем найти длину какого-нибудь такого пути (например, для определённости минимального или максимального). Отметим, что аналогичной динамикой считаются многие другие полезные значения, например, количество строк в правом контексте состояния (или, что то же самое, количество вхождений строк из состояния в <span class="math inline">\(s\)</span>).</p>
<p>Альтернативным решением будет обратиться к дереву суффиксных ссылок, которое, как мы помним, является суффиксным деревом для <span class="math inline">\(s^T\)</span>. Как мы упоминали в самом начале, любая подстрока строки <span class="math inline">\(s\)</span> является префиксом одного из суффиксов исходной строки. Таким образом, если мы запишем в каждую “суффиксную” вершину индекс соответствующего ей суффикса, то все позиции вхождений строки <span class="math inline">\(t\)</span> в <span class="math inline">\(s\)</span> можно будет обнаружить в поддереве вершины, которая соответствует строке <span class="math inline">\(t\)</span>. Значит, в частности, динамикой можно будет найти самое первое или самое последнее вхождение.</p>
<p>Более того, учитывая, что в последнем случае мы работали с деревом, мы можем обойти его таким образом, чтобы на каждом шаге иметь в вершине множество возможных позиций, в которых встречаются строки из соответствующего состояния. Для этого нужно применить идею быстрого слияния множеств, когда мы всегда добавляем элементы из меньшего множества в большее, а не наоборот. Тогда такой обход потребует <span class="math inline">\(O(n \log n)\)</span> операций добавления в множество, т.к. каждый раз когда мы переносим между множествами элемент <span class="math inline">\(k\)</span>, размер нового множества будет как минимум, в два раза больше старого, в котором он хранился.</p>
<p><em>Упражнение*:</em> дана строка <span class="math inline">\(s\)</span>. Найти число строк <span class="math inline">\(t\)</span> таких, что они имеют хотя бы <span class="math inline">\(3\)</span> <em>непересекающихся</em> вхождения в строку <span class="math inline">\(s\)</span>.</p></li>
<li><p><strong>Наибольшая общая подстрока.</strong> Нам дано <span class="math inline">\(k\)</span> строк <span class="math inline">\(s_1, s_2, \dots, s_k\)</span>. Нужно найти наибольшую строку <span class="math inline">\(t\)</span>, которая встречается в каждой из строк <span class="math inline">\(s_i\)</span>. Одно из возможных решений — построить автомат для строки <span class="math inline">\(s_1 t_1 s_2 t_2 \dots s_n t_n\)</span>, где <span class="math inline">\(t_i\)</span> — уникальный для каждой строки символ-разделитель. Теперь мы можем завести динамику <span class="math inline">\(dp[q][i]\)</span>, в которой хранить <span class="math inline">\(1\)</span>, если из состояния <span class="math inline">\(q\)</span> можно добраться до состояния, из которого есть переход по <span class="math inline">\(t_i\)</span>, не проходя при этом через другие символы-разделители. Это будет равносильно тому, что строки из <span class="math inline">\(q\)</span> входят в <span class="math inline">\(s_i\)</span>. Как и в прошлый раз, динамику можно пересчитывать по топологической сортировке автомата как ориентированного ациклического графа. Итого решение будет работать за <span class="math inline">\(O(k \cdot \sum |s_i|)\)</span>.</p>
<p><em>Упражнение*:</em> решить указанную задачу за <span class="math inline">\(O(\sum |s_i|)\)</span>.</p></li>
</ol>
</body>
</html>
